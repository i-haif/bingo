<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haifun&#39;s blog</title>
  
  
  <link href="https://haifuns.com/atom.xml" rel="self"/>
  
  <link href="https://haifuns.com/"/>
  <updated>2025-02-23T13:53:31.045Z</updated>
  <id>https://haifuns.com/</id>
  
  <author>
    <name>haifun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【JVM】G1垃圾回收器</title>
    <link href="https://haifuns.com/2025/02/23/jvm-g1/"/>
    <id>https://haifuns.com/2025/02/23/jvm-g1/</id>
    <published>2025-02-23T13:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<p>G1垃圾回收器（垃圾优先回收器）：</p><ul><li>垃圾回收优先，优先回收垃圾，不会等到空间全部占满然后进行回收</li><li>停顿预测模型，预测一次回收可以回收的分区数量，以满足对停顿时间的要求</li><li>化整为零的分区机制，内存分为n个大小相同的分区（Region），这种灵活可变的Region机制是G1控制停顿时间的核心设计</li></ul><p>G1内存模型：HeapRegion是G1垃圾回收器内存管理的基本单位，也是最小单位。</p><p>分区类型：</p><ul><li>新生代分区：Young Heap Region YHR</li><li>自由分区：Free Heap Region FHR</li><li>老年代分区：Old Heap Region OHR</li><li>大对象分区：Humongous Heap Region HHR</li></ul><p>ParNew+CMS与G1内存模型对比：</p><ul><li>ParNew+CMS，新生代（Eden、Survivor1、Survivor2）、老年代<ul><li>优势：管理简单，小内存时垃圾回收不会造成很大的停顿</li><li>劣势：大内存停顿时间长，例如分配64G给JVM，Eden区20-30G，回收一次Eden区可能需要2-3s</li></ul></li></ul><h1 id="HeapRegion"><a href="#HeapRegion" class="headerlink" title="HeapRegion"></a>HeapRegion</h1><p>G1如何设置HeapRegion大小：</p><ol><li>手动式，通过参数 G1HeapRegionSize 设置，默认为0，范围限制为1-32MB，需要是2的n次方</li><li>启发式判断，G1根据内存（堆内存大小、分区数）自动计算</li></ol><p>HeapRegion大小对垃圾回收的影响：</p><ol><li>Region过小<ol><li>找可以使用的Region难度增加</li><li>跨区存储概率增加</li></ol></li><li>Region过大<ol><li>Region回收价值判断麻烦</li><li>回收判定过程复杂，标记对象时对象多引用多、遇到跨代跨区存储还需要额外处理</li></ol></li></ol><p>Region大小计算：</p><ol><li>计算公式：<code>region_size = max((InitialHeapSize+MaxHeapSize)/2/2048,1MB)</code>，范围[1,32]MB<ol><li>堆分区个数默认为2048，这个数字会根据具体内存大小自动计算，不能手动指定分区个数</li><li>堆内存大小默认最大96MB（MaxHeapSize，+Xmx），最小0MB（InitialHeapSize，+Xms）</li></ol></li><li>e.g.<ol><li>只指定Region大小，设置Region大小为2MB，则G1总内存为2024*2MB=4GB，分区数2048</li><li>指定堆内存且最大值等于最小值，设置堆内存Xms=Xmx=32GB，则RegionSize=max((32GB+32GB)/2/2048,1MB)=16MB</li><li>指定堆内存且最大值不等于最小值，Xms=32GB，Xmx=128GB，则RegionSize=max((32GB+128GB)/2/2048,1MB)=32MB，G1会自动计算分区个数，分区范围在32GB/32MB=1024 ~ 128GB/32GB=4096之间</li></ol></li><li>如果RegionSize不符合规则，G1会自动和2^n对齐，找数字里包含的最大的2的n次幂</li></ol><h1 id="内存扩展机制"><a href="#内存扩展机制" class="headerlink" title="内存扩展机制"></a>内存扩展机制</h1><p>新生代内存分配方式：</p><ol><li>参数指定方式<ol><li>指定新生代大小，设置MaxNewSize、NewSize，设置Xmn相等于同时设置Xmn=MaxNewSize=NewSize</li><li>指定新生代比例，NewRatio，只设置NewRatio时MaxNewSize=NewSize=heapSize/(NewRatio+1)，如果同时设置MaxNewSize、NewSize、NewRatio则NewRatio会被忽略</li></ol></li><li>G1启发式推断<ol><li>没有指定MaxNewSize、NewSize，或只设置其中一个，则G1会根据G1MaxNewSizePercent（默认60%）和G1NewSizePercent（默认5%）配置计算初始化和最大新生代大小</li></ol></li></ol><p>一般来说，在使用G1垃圾回收器时，不推荐自己指定新生代大小，而是让G1自动推断。除非是经过长时间观察找到了一个合理的<strong>新生代范围</strong>(MaxNewSize!=NewSize)。G1的新生代动态扩展可以帮助动态调整YGC所需时间。</p><p>G1扩展新分区时机&amp;规则：</p><ol><li>参数GCTimeRatio设置GC与应用耗时时间比，默认值9，如果GC时间占比超过10%则需要进行动态扩展</li><li>参数G1ExpandByPercentOfAvailable设置每次扩展从未使用内存中申请比例，默认值20，并且最小1MB，最大为已使用内存大小</li></ol><p>内存扩展流程：</p><ol><li>新生代不足 -&gt; 新生代扩展 -&gt; 找自由分区 -&gt; 自由分区不足 -&gt; 从堆内存申请新分区 -&gt; 加入新生代分区列表</li><li>后台线程抽样 -&gt; GC时间占比超过10% -&gt; 自动扩展新生代分区 -&gt; 找自由分区 -&gt; 自由分区不足 -&gt; 从堆内存申请新分区 -&gt; 加入新生代分区列表</li></ol><h1 id="停顿预测模型"><a href="#停顿预测模型" class="headerlink" title="停顿预测模型"></a>停顿预测模型</h1><p>G1中的停顿预测模型为衰减标准差算法，公式如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">davg(n) = Vn，n=1</span><br><span class="line">davg(n) = (1-α)*Vn + α*davg(n-1)，n&gt;1</span><br></pre></td></tr></tbody></table></figure><p>α为衰减因子，是一个小于1的固定值，值越小，最新GC数据对结果影响越大。</p><p>例如α=0.6，GC次数为3，第一次回收2GB用时200ms，第二次回收5GB用时300ms，第三次回收了3GB用时500ms，那么计算结果如下：</p><p>davg(1)=2GB/200ms<br>davg(2)=(1-0.6)*5GB/300ms + 0.6*2GB/200ms<br>davg(3)=(1-0.6)*3GB/500ms + 0.6*((1-0.6)*5GB/300ms + 0.6*2GB/200ms)</p><p>从davg(3)中可以看出，权重最大的就是最后一次GC。</p><p>基于衰减算法模型的垃圾回收过程：</p><ol><li>获取历史GC数据</li><li>使用衰减平均值算法模型计算衰减平均值，评估垃圾回收能力</li><li>根据目标停顿时间和当前回收能力选择一定数量的Region</li><li>执行垃圾回收</li></ol><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><p>G1中使用TLAB（Thread Local Allocation Buffer）机制来进行对象分配，即每个线程都一个自己的本地分配缓冲区，专门用于对象的快速分配。</p><p>使用TLAB机制只需要在线程创建时对堆内存加锁，减少了锁冲突导致的串行化执行问题，实现了对象分配时的无锁化。</p><h2 id="TLAB原理"><a href="#TLAB原理" class="headerlink" title="TLAB原理"></a>TLAB原理</h2><p>TLAB过小，会导致TLAB被快速填满，从而导致对象不走TLAB分配，效率会变差。TLAB过大会造成内存碎片，拖慢回收效率。</p><p>TLAB在初始化时大小通过公式计算：TLABSize = Eden * 2 * 1% / 线程数。</p><p>G1中如果TLAB满了，有两种方式分配：</p><ol><li>重新申请一个TLAB给当前线程</li><li>直接通过堆内存分配对象</li></ol><p>G1中存在一个refill_waste值，在JVM虚拟机内部维护，表示一个TLAB可以浪费的内存大小。也就是说，一个TLAB中最多可以剩余refill_waste空闲空间就可以认为TLAB满了。refill_waste可以通过TLABRefillWasteFraction调整，表示TLAB可以浪费的比例，默认值64，即可以浪费1/64。</p><p>分配对象空间不足时处理流程：</p><ol><li>对象所需空间大于refill_waste，则直接在TLAB外分配（这个过程不同的GC算法有不同的规则），也就是在堆内存直接分配。</li><li>对象所需空间小于refill_waste，则重新申请一个TLAB，用来存储新创建的对象，重新申请时会动态调整refill_waste和TLAB大小，以适应当前系统分配对象的情况。<ol><li>如果申请TLAB失败，则进入堆加锁分配，失败则尝试扩展分区，申请Region失败则走垃圾回收（YoungGC，MixedGC），垃圾回收次数超过阈值则进行最终尝试，失败直接结束并OOM。</li></ol></li></ol><p>最终分配尝试流程：</p><ol><li>第一次FullGC，不回收软引用，完成后尝试分配对象，成功则结束，不成功进行第二次GC</li><li>第二次FullGC，回收软引用，完成后尝试分配对象，成功则结束，不成功则OOM</li></ol><p>TLAB通过指针碰撞法来判断是否有可用的连续内存，top指针指向空闲内存开始位置，end指针指向整个TLAB结束位置，在分配对象时判断待分配对象空间和剩余空间大小（end - top）关系即可。</p><p>TLAB长度固定，有可能会产生无法使用的内存空间，这些内存碎片由虚拟对象进行填充。</p><p>TLABSize最大值为RegionSize/2，大对象&gt;TLABSize直接走慢速分配，到大对象分区分配。大对象在分配时，会判断是否启动垃圾回收和并发标记。</p><h1 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h1><h2 id="记忆集RememberSet"><a href="#记忆集RememberSet" class="headerlink" title="记忆集RememberSet"></a>记忆集RememberSet</h2><p>记忆集是一组K-V结构，记录跨代引用关系，在GC时，可以借助记忆集和GCRoots快速解决同代引用及跨代引用的可达性分析问题，避免每次都将堆中所有对象都标记一遍。</p><p>G1中的记忆集是以Region为最小内存管理维度，存储Region里所有对象被引用的引用关系，K为引用方对象所在Region地址，V为数组，存放引用方对象所在卡页在卡表中的下标。</p><p>G1记忆集中记录的引用关系类型：</p><ol><li>老年代Region到新生代Region的引用关系，用来解决新生代回收时跨代引用</li><li>老年代Region到老年代Region的引用关系，用来解决混合回收老年代选择部分Region回收时引用</li></ol><h2 id="位图BitMap"><a href="#位图BitMap" class="headerlink" title="位图BitMap"></a>位图BitMap</h2><p>G1中使用位图来描述内存使用状态，主要是在混合回收的并发标记阶段，用来提升内存是否使用的判定效率。</p><h2 id="卡表CardTable"><a href="#卡表CardTable" class="headerlink" title="卡表CardTable"></a>卡表CardTable</h2><p>G1中使用全局卡表来描述整个堆的内存使用情况，本质上与位图类似，区别是描述内容比位图更多。卡表用一个字节来描述512字节的内存使用情况，以及垃圾回收过程中的状态信息。</p><p>G1使用记忆集+卡表来解决分代模型中跨代引用关系判定和追踪问题。记忆集+卡表机制在时间和空间上做了平衡，在找老年代引用对象时，实际上就是遍历对应卡页的内存，按照对象长度的内存空间为步长遍历整体性能不会很差。</p><h2 id="DCQ机制"><a href="#DCQ机制" class="headerlink" title="DCQ机制"></a>DCQ机制</h2><p>G1通过DCQ（Dirty Card Queue）脏数据队列来更新RSet，当引用关系发生变更时，发送变更消息到DCQ，Refine线程异步消费并更新RSet。</p><p>Refine线程最大线程数为G1ConcRefinementThreads+1，每个线程都关联一个DCQ，每个DCQ长度为256，当DCQ写满就申请一个新的DCQ并把老的DCQ提交到DCQ Set里，即二级缓存DCQS。当DCQS不能存放更多的DCQ时，会由工作线程处理这个DCQ。</p><p>G1给每个变更屏障操作前加了一个写屏障，用来增强操作，主要作用为：</p><ol><li>过滤掉不需要写的引用变更操作，比如新生代到新生代的引用、同一个Region的引用等</li><li>把正常的变更数据写入一条到DCQ里</li></ol><p>G1给DCQS做了四个区域，由参数G1ConcRefinementGreenZone、G1ConcRefinementYellowZone、G1ConcRefinementRedZone划分，默认都是0，如果没有设置则由G1自动推断。四个区域如下：</p><ol><li>白区，[0,green)，不启动Refine线程处理DCQ</li><li>绿区，[green,yellow)，根据DCQS元素个数来计算启动Refine线程个数</li><li>黄区，[yellow,red)，所有Refine线程都参与到DCQ处理</li><li>红区，[red,正无穷)，所有Refine线程以及系统工作线程都参与DCQ处理</li></ol><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>G1回收器相关参数：</p><ol><li>-XX:+UseG1GC，使用G1垃圾回收器</li><li>-XX:G1HeapRegionSize，Region分区大小，最小值1MB，最大值32MB，且只能是2的n次幂</li><li>-Xms -Xmx，堆内存最大值最小值</li><li>-XX:NewSize -XX:MaxNewSize，新生代最小值和最大值，这个最大值最小值在G1里一般不需要设置，G1会自动计算出来一个值，从5%的Region数量开始，最大为60%</li><li>-XX:G1NewSizePercent -XX:G1MaxNewSizePercent，新生代region数量下限，默认5%-60%</li><li>-XX:SurvivorRatio，新生代Eden和Survivor的比例，默认8，即eden:s1:s2=8:1:1</li><li>-XX:MaxGCPauseMills，最大GC暂停时间。这是一个大概值，JVM会尽可能的满足此值</li><li>-XX:NewRatio，new/old代的大小比例，默认2，只设置一个NewRatio和只设置一个Xmn相当</li><li>-XX:ParallelGCThreads，参与回收的线程数量，默认和CPU核数相等</li></ol><h2 id="YoungGC"><a href="#YoungGC" class="headerlink" title="YoungGC"></a>YoungGC</h2><p>YoungGC流程：</p><ol><li>从GCRoot触发标记存活对象<ol><li>暂停Refine线程，由GC线程消费DCQS并更新RSet，把RSet也作为GCRoot执行对象标记</li><li>把GCRoot+RSet直接引用的对象所有field放到栈里，遍历栈，直到找到所有存活对象</li></ol></li><li>复制存活对象到Survivor区</li><li>回收垃圾对象<ol><li>整理卡表</li><li>重构RSet</li><li>释放分区</li><li>尝试回收大对象</li></ol></li><li>动态调整新生代Region数量<ol><li>GCTimeRatio+G1ExpandByPercentOfAvailable参数，GC时间占比超过10%就需要扩展新生代内存</li><li>调整新生代分区数量和Refinement Zone阈值</li></ol></li><li>判断是否需要开启并发标记<ol><li>老年代内存使用率达到45%，在YGC结束后开启并发标记</li></ol></li></ol><p><img src="https://img.haifuns.com/jvm/g1-ygc.png" alt="YGC流程"></p><h2 id="MixedGC"><a href="#MixedGC" class="headerlink" title="MixedGC"></a>MixedGC</h2><p>MixedGC流程：</p><ol><li>初始标记，Stop The World，伴随一次YGC，YGC结束时会判断是否需要开启并发标记</li><li>并发标记<ol><li>起始对象：Survivor区存活对象+GCRoots引用的老年代对象+RSet</li><li>使用位图+三色标记法标记对象是否存活，黑色-存活，灰色-存活但子对象未遍历完全，白色-死亡</li><li>SATB(Snapshot-At-The-Beginning)对象引用的快照状态，通过写屏蔽放入到SATB队列用来记录工作线程造成的引用变化</li></ol></li><li>最终标记，STW，针对并发标记阶段由于系统运行造成的错标漏标情况进行修正，本质上是把SATB队列里的对象重新标记</li><li>预回收阶段<ol><li>根据RSet+BitMap完成存活对象的统计工作，按结果给Region排序</li><li>更新prevBitMap位图，为下一次并发标记做准备（如果回收成功，则忽略）</li><li>重置RSet，如果标记后分区没有对象被引用则删除旧的引用关系</li><li>清理全部都是垃圾的分区</li></ol></li><li>混合回收阶段<ol><li>选择一些分区（Collect Set）进行回收，把分区内存活对象复制到空闲分区，清理原分区</li><li>Collect Set算法依据回收性价比，单位时间内能回收的垃圾越多性价比越高，回收能力看对象转移效率，也就是存活对象越少性价比越高</li><li>G1MixedGCLiveThresholdPercent，如果一个分区存活对象达到默认85%就不加入到CSet</li><li>G1HeapWastePercent，如果选择的CSet可以回收的垃圾占总堆5%才会开始回收，否则不回收</li><li>G1MixedGCCountTarget，最多分8次完成回收，每回收一次都再次判断G1HeapWastePercent</li><li>G1OldCSetRegionThresholdPercent，每次回收掉的分区数不能超过整个堆分区数量的10%</li></ol></li></ol><h2 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h2><p>FullGC流程（STW）：<br>0. 前置处理，保存对象头、锁等信息</p><ol><li>标记存活对象，分区并行+任务窃取提高性能</li><li>计算对象的新地址，单个线程处理的多个Region存活对象压缩到同一个Region</li><li>更新引用对象的地址</li><li>移动对象完成压缩（复制覆盖操作）</li><li>复制后的处理<ol><li>尝试调整整个堆分区的数量大小</li><li>遍历整个堆，重构RSet</li><li>清除dirty card队列，更新卡表，把所有分区设置为Old分区</li><li>记录GC信息，更新新生代大小，选择一些分区作为新生代，重新构建Eden</li></ol></li></ol><p>补充：G1新特性，字符串去重优化，筛选条件：</p><ol><li>如果在YGC阶段<ol><li>当字符串需要复制到S区，根据年龄判断达到阈值StringDeduplicationAgeThreshold则参与去重</li><li>当字符串需要晋升到Old区，并且对象年龄小于阈值StringDeduplicationAgeThreshold则参与去重</li></ol></li><li>如果在FullGC阶段，只需判断字符串对象是否年龄小于阈值，因为完成GC后所有分区都会被标记为Old分区</li></ol><p>找到所有需要去重的字符串后，会把这些字符串放到一个队列，开启一个后台线程利用HashTable结构完成去重操作。官方数据，经过去重操作能够节省约13%的内存，提升明显。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;G1垃圾回收器（垃圾优先回收器）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收优先，优先回收垃圾，不会等到空间全部占满然后进行回收&lt;/li&gt;
&lt;li&gt;停顿预测模型，预测一次回收可以回收的分区数量，以满足对停顿时间的要求&lt;/li&gt;
&lt;li&gt;化整为零的分区机制，内存分为n个大小相同的分</summary>
      
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】改表是否会锁表？</title>
    <link href="https://haifuns.com/2024/04/07/mysql-onlineddl/"/>
    <id>https://haifuns.com/2024/04/07/mysql-onlineddl/</id>
    <published>2024-04-07T10:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<p>改表是否会锁表，取决于使用的改表方案，不同的改表方案通常会有不同的锁表时长。下面将分别介绍 MySQL 原生 Online-DDL 以及开源第三方工具 gh-ost 两种改表方案。</p><h1 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online-DDL"></a>Online-DDL</h1><p>Online-DDL算法：</p><ul><li>COPY，mysql5.6前</li><li>INPLACE，mysql5.6</li><li>INSTANT，mysql8.0</li></ul><p>在执行 DDL 操作时，不管何种算法，都会经历准备（prepare）、执行（DDL）、提交（commit）三个阶段。不同之处是在三个阶段中分别作了不同的处理。</p><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><ol><li>准备阶段：<ol><li>对表加元数据共享锁，读取 .frm 元数据；（此时 DDL 不能并行，DML 可以并行）</li><li>共享锁升级为排他锁；（此时 DDL、DML 都不能并行）</li><li>在 server 层通过 create like 语句，创建临时表，engine 层也生成对应 .ibd、.frm 文件；（8.0 之后没有 .frm 文件）</li></ol></li><li>执行阶段：<ol><li>修改临时表元数据；（加列）</li><li>拷贝原表数据到临时表；（最耗时，按行 copy）</li><li>删除原表及文件；</li><li>重命名临时表及文件；</li></ol></li><li>提交阶段：<ol><li>提交事务，释放锁；</li></ol></li></ol><p>COPY算法整个流程期间都持有锁，既不能写入数据也不能查询数据，容易造成数据库堵塞，因此并不实用。</p><h2 id="INPLACE"><a href="#INPLACE" class="headerlink" title="INPLACE"></a>INPLACE</h2><ol><li>准备阶段：<ol><li>对表加元数据共享锁，并升级为排他锁；（此时 DML 不能并行）</li><li>判断是否使用 inplace 算法，判断语句是 rebuild table 还是 no-rebuild，rebuild 在原表所在的路径下创建 .frm 和 .ibd 临时中转文件；（在 engine 层克隆，而不是像 copy 那样，在 server 层创建（create like））</li><li>申请 row log 空间，用于存放 DDL 执行阶段产生的 DML 操作；（no-rebuild不需要）</li></ol></li><li>执行阶段：<ol><li>释放排他锁，保留元数据共享锁；（此时 DML 可以并行）</li><li>扫描原表主键以及二级索引的所有数据页，生成 B+ 树，存储到临时文件中；（在引擎层扫描，最耗时）</li><li>将所有对原表的 DML 操作记录在日志文件 row log 中并回放；</li></ol></li><li>提交阶段：<ol><li>升级元数据共享锁，产生排他锁锁表；（此时 DML 不能并行）</li><li>重做 row log 中的内容；（no-rebuild 不需要）</li><li>重命名原表文件，将临时文件改名为原表文件名，删除原表文件；</li><li>提交事务，变更完成；</li></ol></li></ol><p>INPLACE 算法无需拷贝全表数据到新表，但还是需要 IN-PLACE 方式（原地，无需生成新的临时表）重建整表。这种情况下，在 DDL 的初始准备和最后结束两个阶段时需要加排他 DML锁（metadata lock，元数据锁），除外，DDL 期间不会阻塞 DML。</p><p>虽然准备、提交两个阶段都无法进行 CRUD，但实际上，整个 DDL 过程执行阶段时间占比最长，对于业务层来说，绝大部分时间可以保证正常访问。</p><h2 id="INSTANT"><a href="#INSTANT" class="headerlink" title="INSTANT"></a>INSTANT</h2><p>只需修改数据字典中的元数据，无需拷贝数据也无需重建整表，同样，也无需加排他 DML 锁，原表数据也不受影响。整个 DDL 过程几乎是瞬间完成的，也不会阻塞 DML。</p><p>这个新特性是8.0.12引入的（腾讯DBA团队贡献），目前只支持添加列等少量操作。</p><h1 id="gh-ost"><a href="#gh-ost" class="headerlink" title="gh-ost"></a>gh-ost</h1><p>gh-ost 是 GitHub 开源的一款 MySQL 在线 DDL 改表工具。它的主要优点包括：</p><ol><li>不阻塞：在改表过程中，对原表的读写操作不会被阻塞。</li><li>减少主从延迟：通过在从库上执行改表操作，可以减少主从复制的延迟。</li><li>可控的副本流量：可以控制改表过程中的副本流量，避免对数据库服务器造成过大压力。</li><li>支持暂停和恢复：在改表过程中，可以随时暂停和恢复改表操作。</li><li>安全：在改表过程中，如果出现问题，可以立即切换回原表，不会丢失数据。</li><li>可观察性：提供了丰富的监控和日志，可以实时查看改表的进度和状态。</li><li>灵活性：支持各种复杂的改表操作，包括添加/删除/修改列、添加/删除索引等。</li><li>测试模式：可以在不实际执行改表操作的情况下，验证改表的过程和结果。</li></ol><h2 id="gh-ost-改表原理"><a href="#gh-ost-改表原理" class="headerlink" title="gh-ost 改表原理"></a>gh-ost 改表原理</h2><p>gh-ost 工具基于中间表增量迁移数据 + rename 表替换完成改表动作。通过创建一个与原表结构相同的_ghost_表，然后将原表的数据逐行复制到_ghost_表中，同时捕获并复制原表上的数据变更。当数据复制完成后，将_ghost_表重命名为原表，完成改表操作。</p><p>其中耗时主要发生在数据迁移阶段，该阶段不锁表，rename 表替换阶段会有短暂锁表，但通常为秒级。</p><h2 id="gh-ost-改表耗时"><a href="#gh-ost-改表耗时" class="headerlink" title="gh-ost 改表耗时"></a>gh-ost 改表耗时</h2><p>改表操作是动态执行的，耗时与集群负载/主从延迟/业务写入量/网络等多种外部因素息息相关，目前没有精确的改表速度评估方式。经验评估方式有2种：</p><ol><li>根据表数据行数预估：1w行/s；</li><li>根据表空间大小预估：1G/5min；</li></ol><p>（仅供参考，实际执行速度可能会偏差较大。建议预留充足时间，避免影响业务进度。）</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><blockquote><p>通常情况下，我们期望 RDS 改表锁表时间为秒级，同时通过避开高峰期执行，从而减少对业务产生的影响。</p></blockquote><p>改表方案选择：</p><ol><li>有主键/唯一键 &amp;&amp; 没有外键：使用 gh-ost 进行改表，改表结束阶段会出现短暂锁表；</li><li>没有主键/唯一键 &amp;&amp; 行数 &lt; 10w &amp;&amp; 表大小 &lt; 100M：直接使用MySQL原生的改表方案，改表期间会出现间歇性锁表；</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/weixin_45238761/article/details/125343029">MySQL Online DDL详解</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html">MySQL官方文档 innodb-online-ddl</a></li><li><a href="https://dev.mysql.com/blog-archive/mysql-8-0-innodb-now-supports-instant-add-column/">MySQL8.0 腾讯游戏 DBA 团队贡献秒级加列功能，官方blog</a></li><li><a href="https://github.com/github/gh-ost">github/gh-ost</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;改表是否会锁表，取决于使用的改表方案，不同的改表方案通常会有不同的锁表时长。下面将分别介绍 MySQL 原生 Online-DDL 以及开源第三方工具 gh-ost 两种改表方案。&lt;/p&gt;
&lt;h1 id=&quot;Online-DDL&quot;&gt;&lt;a href=&quot;#Online-DDL&quot; </summary>
      
    
    
    
    <category term="数据库" scheme="https://haifuns.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://haifuns.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>OLAP-ApacheDoris</title>
    <link href="https://haifuns.com/2023/09/11/olap-doris/"/>
    <id>https://haifuns.com/2023/09/11/olap-doris/</id>
    <published>2023-09-11T10:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Doris 是一个基于 MPP 架构的高性能、实时的分析型数据库，仅需亚秒级响应时间即可返回海量数据下的查询结果，不仅可以支持高并发的点查询场景，也能支持高吞吐的复杂分析场景。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><ul><li>Aggregate Key，聚合模型，按照指定的聚合方式（SUM/REPLACE/MAX/MIN）自动聚合，读时合并。<ul><li>通过过预聚合，极大地降低聚合查询时所需扫描的数据量和查询的计算量，非常适合有固定模式的报表类查询场景。但是该模型对 count(*) 查询很不友好。同时因为固定了 Value 列上的聚合方式，在进行其他类型的聚合查询时，需要考虑语意正确性。</li></ul></li><li>Unique Key，唯一模型，保证主键唯一性约束，有读时合并和写时合并两种实现方式，读时合并等同于 Aggregate Key + REPLACE，写时合并在数据导入阶段进行新增和标记删除、查询性能更好。<ul><li>无法利用 ROLLUP 等预聚合带来的查询优势。</li><li>仅支持整行更新，如果既需要唯一主键约束，又需要更新部分列（例如将多张源表导入到一张 Doris 表的情形），则可以考虑使用 Aggregate 模型，同时将非主键列的聚合类型设置为 REPLACE_IF_NOT_NULL。</li></ul></li><li>Duplicate Key，重复模型，没有主键也不聚合，数据重复时保存多份，仅排序。<ul><li>适合任意维度的 Ad-hoc 查询。虽然同样无法利用预聚合的特性，但是不受聚合模型的约束，可以发挥列存模型的优势（只读取相关列，而不需要读取所有 Key 列）。</li></ul></li></ul><h1 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h1><p>Doris 中数据以 Table 形式描述，Table 包含 Row 和 Column，其中：</p><ul><li>Row：一行数据</li><li>Column：描述一行数据中的不用字段。Doris 中 Column 分为 Key 和 Value 两类，即业务角度的维度列和指标列。从聚合模型角度看，Key 列相同的行会聚合成一行，其中 Value 列的聚合方式在建表时指定。</li></ul><p>在 Doris 存储引擎中，Table 由多个 Partition（分区）组成，Partition 是逻辑上的最小管理单元，数据导入和删除仅能针对一个 Partition 进行。每个 Partition 包含多个 Tablet（数据分片/数据分桶），Tablet 是数据移动、复制等操作的最小物理存储单元。</p><p>Doris 支持分区和分桶两层的数据划分方式，第一层是 Partition，支持 Range 和 List 两种划分方式，第二层是 Bucket（Tablet），仅支持 Hash 划分方式。也可以使用一层分区，只能使用 Bucket 划分。</p><p>分区列必须是 Key 列，支持多列分区，分区数量没有上限。分桶列对于 Aggregate 和 Unique 模型必须为 Key 列，Duplicate 模型可以是 Key 列和 Value 列。</p><h1 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h1><p>ROLLUP 即在 Base 表的基础上将数据按照指定粒度进行进一步聚合以获得更粗粒度的聚合数据。ROLLUP 的数据基于 Base 表产生，并且在物理上是单独存储的。</p><p>ROLLUP 也可以用来调整前缀索引，只需建立一个与 Base 列一致但是顺序不一致的 ROLLUP。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>Doris 支持两种索引：</p><ul><li>内建的智能索引<ul><li>前缀索引：将一行数据的前 36 个字节（遇到 VARCHAR 直接截断，并且最多使用 VARCHAR 20 个字节）作为这行数据的前缀。</li><li>ZoneMap 索引：对每列自动维护的索引信息，包含 Min/Max、Null 值个数等。</li></ul></li><li>手动创建的二级索引<ul><li>BloomFilter 索引：布隆过滤器索引，适用于高基数列过滤。</li><li>Bitmap 索引：位图索引，用来加快查询速度。</li></ul></li></ul><h1 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h1><p>物化视图是将预先计算（根据定义好的 SELECT 语句）的数据集存储在 Doris 中的一种特殊表。既能对原始明细数据进行任意维度的分析，也能快速的对固定维度进行分析查询。</p><p>物化视图是 ROLLUP 的超集，在覆盖 ROLLUP 功能的同时，还支持更丰富的聚合函数。</p><hr><ul><li><a href="https://doris.apache.org/zh-CN/docs/1.2/data-table/data-model/">Apache Doris官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apache Doris 是一个基于 MPP 架构的高性能、实时的分析型数据库，仅需亚秒级响应时间即可返回海量数据下的查询结果，不仅可以支持高并发的点查询场景，也能支持高吞吐的复杂分析场景。&lt;/p&gt;
&lt;h1 id=&quot;数据模型&quot;&gt;&lt;a href=&quot;#数据模型&quot; class=&quot;</summary>
      
    
    
    
    <category term="OLAP" scheme="https://haifuns.com/categories/OLAP/"/>
    
    
    <category term="Doris" scheme="https://haifuns.com/tags/Doris/"/>
    
  </entry>
  
  <entry>
    <title>向量检索技术（了解）</title>
    <link href="https://haifuns.com/2023/07/14/vectorsearch/"/>
    <id>https://haifuns.com/2023/07/14/vectorsearch/</id>
    <published>2023-07-14T04:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>随着互联网的不断发展，产生了各种各样的海量数据，比如图片、文本、视频和语音等非结构化数据，这些数据可以通过人工智能技术提取出特征向量，然后通过对这些特征向量的计算和检索来实现对非结构化数据的分析和检索，如何对非结构化的向量数据进行高效检索即为向量检索技术的核心问题。</p><p>向量检索的应用场景非常丰富，比如：</p><ul><li>推荐系统：广告推荐、猜你喜欢等；</li><li>图片识别：以图搜图，通过图片检索图片。具体应用如：车辆检索和商品图片检索等；</li><li>自然语言处理：基于语义的文本检索和推荐，通过文本检索近似文本；</li><li>声纹匹配，音频检索；</li><li>文件去重：通过文件指纹去除重复文件；</li></ul><h1 id="向量距离计算"><a href="#向量距离计算" class="headerlink" title="向量距离计算"></a>向量距离计算</h1><h2 id="浮点型向量计算方式"><a href="#浮点型向量计算方式" class="headerlink" title="浮点型向量计算方式"></a>浮点型向量计算方式</h2><ul><li>内积（IP）/点积（DP）：两个向量在方向上的差异，内积值越大夹角越小越相似。通常用于推荐场景。</li><li>欧式（L2）：两点之间最短的直线距离，距离值越小越相似。能够体现个体数值特征的绝对差异，更多的用于需要从维度的数值大小中体现差异的分析，如使用用户行为指标分析用户价值的相似度或差异。</li><li>曼哈顿（L1）：两个点在标准坐标系上绝对轴距总和。</li><li>余弦（Cosine）：两个向量之间的夹角余弦值，余弦相似度值越大夹角越小越相似。归一化后，内积与余弦相似度计算公式等价。</li></ul><p>余弦距离和内积距离更多的是从方向上区分差异，而对绝对的数值不敏感，更多的用于使用用户对内容评分来区分兴趣的相似度和差异，同时修正了用户间可能存在的度量标准不统一的问题。</p><p>举例：统计两部剧的用户观看行为，用户A的观看向量为(0,1)，用户B为(1,0)；此时二者的余弦距很大，而欧氏距离相对较小；我们分析两个用户对于不同视频的偏好，更关注相对差异，显然应当使用余弦距离或内积距离。</p><h2 id="二值型向量计算方式"><a href="#二值型向量计算方式" class="headerlink" title="二值型向量计算方式"></a>二值型向量计算方式</h2><ul><li>汉明距离（Hamming）：二进制字符串之间的距离。两个等长字符串之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。</li><li>杰卡德距离（Jaccard）：数据集之间的相似度，计算方式为数据集交集的个数和并集个数的比值。</li><li>谷本距离（Tanimoto）：对于二值变量，谷本系数等价于杰卡德距离。</li></ul><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><p>向量检索的本质是近似最近邻（ANN，Approximate Nearest Neighbors）搜索，通过尽可能减小查询向量的搜索范围，从而提高查询速度。目前业界的近邻搜索算法主要分为基于树、图、量化和哈希四类。</p><ul><li>基于树<ul><li>KD树</li><li>Annoy</li></ul></li><li>基于图<ul><li>NSW</li><li>HNSW</li></ul></li><li>基于量化<ul><li>SQ</li><li>PQ</li></ul></li><li>基于哈希<ul><li>LSH</li></ul></li></ul><p>KD树（K-dimension tree），每次选择一个维度切割成两个子区域，构建形成树结构，搜索时利用树进行二分查找从而缩小搜索范围。</p><p>Annoy（Approximate Nearest Neighbors Oh Yeah），用超平面把高维空间分割成多个子空间，并把这些子空间以树型结构存储的索引方式。查询时顺着树结构找到距离目标向量较近的一些子空间，然后比较这些子空间里的所有向量。</p><p>K-Means聚类算法，通过不断分类找平均点，直到分类趋于稳定，搜索时只需要找出距离最近的聚类中心，以达到缩小范围的目的。但是会存在遗漏的问题，需要衡量聚类数量。</p><p>导航小世界（NSW，Navigable Small World），图结构建立过程：每次新增向量都和最近的几个向量建立连接。在搜索的过程中按照先粗快后细慢的方式快速导航到目标节点。</p><p>分层的导航小世界（HNSW，Hierarchical Navigable Small World），在NSW的基础上增加多个层级结构，最下层是包含所有节点的图结构，越往上层包含的节点数越少，最上面的节点最稀疏。搜索时上层连线长便于快速导航，下层连线短便于精细化搜索。</p><p>标量量化（ SQ，ScalarQuantization ），将每一个维度量化成指定位数的一个数，比如将32位的int量化成8位的int，通过损失一定的精度，缩减存储和计算成本，比较简单。</p><p>乘积量化（PQ，Produce Quantization），把向量用质心（聚类中心）编码表示，称为量化。质心编码对应一个码本，在高维向量中存在维度灾难问题，码本可能大到不可接受，此时可以先降维，将高维向量先分成多个低纬子向量，然后对每个子向量进行k-means聚类训练。子空间拆分实际上是把聚类数量或者说码本大小的增长从指数模式变成加法模式，从而节省内存。</p><p>位置敏感哈希（LSH，Locality Sensitive Hashing），位置越近或者越相近发生碰撞的概率越高，碰撞的向量放在同一个桶里。搜索时先计算查询向量的哈希值，找到相应的桶，从而实现缩小查询范围。</p><p>其他ANN算法见：<a href="https://github.com/erikbern/ann-benchmarks">ANN-Benchmark</a></p><h1 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h1><ul><li><a href="https://milvus.io/">Milvus</a></li><li><a href="https://www.pinecone.io/">Pinecone</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着互联网的不断发展，产生了各种各样的海量数据，比如图片、文本、视频和语音等非结构化数据，这些数据可以通过人工智能技术提取出特征向量，然后通过对这些特征向量的计算和检索来实现对非结构化数据的分析和检索，如何对非结构化的向量数据进行高效检索即为向量检索技术的核心问题。&lt;/p&gt;</summary>
      
    
    
    
    <category term="向量检索" scheme="https://haifuns.com/categories/%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2/"/>
    
    
    <category term="向量检索" scheme="https://haifuns.com/tags/%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>区块链概念</title>
    <link href="https://haifuns.com/2023/06/06/blockchain/"/>
    <id>https://haifuns.com/2023/06/06/blockchain/</id>
    <published>2023-06-06T11:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>比特币（BTC）是一种基于去中心化，采用点对点网络与共识主动性，开放源代码，以区块链作为底层技术的加密货币，比特币起源于中本聪于 2008 年 10 月 31 日发表的论文，2009 年 1 月 3 日，创世区块诞生。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链（Blockchain）是比特币的一个重要概念，区块链本质上是一串使用密码学方法产生的资料块（称为“区块”，block）。新增的区块总能链接到上一个区块，即整条区块链的尾部。比特币点对点网络将所有的交易历史都存储在“区块链”中，所以区块链可以看作记录着比特币交易的账本。</p><p>确认一项交易的过程通过解决一系列数学难题的工作量证明机制来实现。工作量证明机制需要电脑运算一定的时间才能解决，这就使得攻击者无法重写、修改交易历史，除非他能够拥有相对比特币点对点网络系统更强大的计算能力，从而能以更快的速度产生区块链（称为”51%攻击”）。</p><p>工作量证明机制的难度由系统自动调节，所以新区块的生成平均需时 10 分钟。整个比特币点对点网络的节点都会自动检测交易和区块的有效性，并忽略任何违背规则的交易和区块，比如那些产生错误数量的区块，或多次发送同一份额比特币的交易行为。</p><p>参与处理区块的客户端可以得到一定量新发行的比特币，以及相关的交易手续费。为了得到这些新产生的比特币，参与处理区块的客户端需要付出大量的时间和计算力，这些资料处理者称为“矿工”，资料处理活动称之为“挖矿”。</p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。以太坊的概念首次在 2013 年由程序员维塔利克·布特林受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在 2014 年通过 ICO 众筹开始得以发展。以太坊亦被称为“第二代的区块链平台”，仅次于比特币。</p><p>以太坊虚拟机是以太坊的关键组成部分之一，它为以太坊上智能合约的部署和运行提供了必要的环境。任何人都可以运行一段虚拟机程序，并通过网络的共识机制被所有人所接受。以太坊虚拟机赋予了区块链技术极大的灵活性，在此之上可以非常容易地构建各种去中心化应用（Dapp），像去中心化金融（Defi）等都是基于以太坊虚拟机构建的应用。</p><p>以太坊虚拟机（EVM）可以看做是以太坊网络中的一台规范化计算机，其状态得到以太坊网络中所有人的一致同意。 每个参与以太坊网络的人（每个以太坊节点）都会保存一份这台计算机的状态。 此外，任何参与者都可以广播请求这台计算机进行任意计算。 每当广播这样的请求网络时，网络上的其他参与者就会验证、确认并进行（“执行”）计算。 这个命令会导致 EVM 的状态变化，并且在整个网络中传播。</p><p>多条交易记录以及 EVM 的当前状态被打包成区块，存储在区块链中。区块链通过共识机制，各个节点完成校验达成一致后进行存储，确保了数据的一致性，并防止被恶意篡改。</p><h2 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h2><blockquote><p>数字加密货币大致可以分为原生币（coin）和代币（token）两大类。前者如 BTC、ETH 等，拥有自己的区块链。后者如 Tether、TRON、ONT 等，依附于现有的区块链。市场上流通的基于以太坊的代币大都遵从 ERC20 协议。</p></blockquote><p>NFT 的全称是 Non-Fungible Tokens（非同质化代币），具有不可分割、不可替代、独一无二等特点。每个代币可以代表一个独特的数字资料，作为虚拟商品所有权的电子认证或证书。由于其不能互换的特性，非同质化代币可以代表数字资产，如画作、艺术品、声音、视频、游戏中的项目或其他形式的创意作品。虽然作品本身是可以无限复制的，但这些代表它们的代币在其底层区块链上能被完整追踪，故能为买家提供所有权证明。诸如以太币、比特币等加密货币都有自己的代币标准以定义对 NFT 的使用。</p><p>以太坊社区采用了许多标准，有助于在项目的不同实现中保持统一的兼容性（例如以太坊客户和虚拟钱包)，并确保智能合约和 dapps 仍保持兼容。ERC-721 就是其中 NFT 相关的标准。随着 NFT 的普及和 ERC721 的应用，出现了 ERC721 合约的改良版。当中包括 ERC721A。ERC721A 是 IERC721 的一种实现，在一次交易中铸造多个 NFT 可显著节省 Gas Fee。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块是指一批交易的组合，并且包含链中上一个区块的哈希。 这将区块连接在一起（成为一个链），因为哈希是从区块数据中加密得出的。 这可以防止欺诈，因为以前的任何区块中的任何改变都会使后续所有区块无效，而且所有哈希都会改变，所有运行区块链的人都会注意到。这样就防止了有人对历史数据进行篡改。</p><p>所有已在网络历史上提交给以太坊网络的区块的序列，称为区块链。 每个区块都包含对前一个区块的引用，这有助于我们在所有区块间（同时在精确的历史记录）上保持顺序。在以太网中，我们可以将区块链视为一个可靠的分布式数据库，用于存储整个以太网的历史、以及当前状态。</p><p>以太坊网络中，一个区块中包含如下信息：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>timestamp</td><td>开采区块的时间</td></tr><tr><td>blockNumber</td><td>区块链中区块的长度</td></tr><tr><td>baseFeePerGas</td><td>要将交易纳入区块，每个 gas 所需的最低费用</td></tr><tr><td>difficulty</td><td>开采所需的努力</td></tr><tr><td>mixHash</td><td>该区块的唯一标识符</td></tr><tr><td>parentHash</td><td>前一区块的唯一标识符，相当于指向前一区块的指针</td></tr><tr><td>nonce</td><td>哈希，当与 mixHash 结合使用时，可以证明该块已经通过了工作量证明</td></tr><tr><td>transactions</td><td>包含在区块中的交易</td></tr><tr><td>stateRoot</td><td>系统的整个状态：帐户余额、合约存储、合约代码和帐户随机数</td></tr></tbody></table><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><p>在创建账户时会随之生成对应的地址和私钥，地址用来唯一确定账户，私钥用来给交易签名，掌握私钥就等于掌握其对应地址中存放的资产。</p><p>以太坊的账户有 2 种类型：</p><ul><li>外部拥有的账户：被私钥的所有者控制且没有任何代码与之关联。</li><li>合约账户：被合约代码控制且有代码与之关联。</li></ul><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>以以太坊中的交易为例，一次交易部分信息如下：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Transaction Fee</td><td>交易总费用（base fee per gas + max priority fee per gas）* gas</td></tr><tr><td>Gas Price</td><td>gas 价格</td></tr><tr><td>Gas limit</td><td>交易可以消耗的最大 gas 数量</td></tr><tr><td>Gas Usage</td><td>实际使用了多少 gas</td></tr><tr><td>Base fee</td><td>每个 gas 消耗的网络基础费</td></tr><tr><td>Max fee</td><td>愿意为交易支付的最高 gas 价格</td></tr><tr><td>Max Priority fee</td><td>最大 gas 价格 + 矿工小费</td></tr><tr><td>Burnt</td><td>实际烧掉多少 gas</td></tr><tr><td>value</td><td>从发件人向收件人转移 ETH 的金额 （以 WEI 为单位，1ETH = 1*10^8WEI）</td></tr><tr><td>from</td><td>发送地址</td></tr><tr><td>to</td><td>接收地址，如果为合约帐户，交易将执行合约代码</td></tr></tbody></table><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>以太坊最重要的技术贡献就是智能合约。智能合约是存储在区块链上的程序，可以协助和验证合约的谈判和执行。</p><p>因为合约内容公开，合约可以证明其宣称的功能是真实的，例如虚拟赌场可以证明它是公平的。另一方面，区块链上的所有用户都可以看到基于区块链的智能合约，这会导致包括安全漏洞在内的所有漏洞都可见，并且可能无法迅速修复。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="出块（挖矿）原理"><a href="#出块（挖矿）原理" class="headerlink" title="出块（挖矿）原理"></a>出块（挖矿）原理</h2><ol><li>字符串：前块头部+账单+时间+随机数</li><li>Hash：SHA256(SHA256(字符串))</li><li>要求前 n 位是 0</li></ol><h2 id="难度-n-的确定"><a href="#难度-n-的确定" class="headerlink" title="难度 n 的确定"></a>难度 n 的确定</h2><p>出块平均概率 (1/2)^n ，要保证每 10min 出一个块，通过调整 n 的大小使得，2^n=10*60*矿机总算力</p><h2 id="交易防伪"><a href="#交易防伪" class="headerlink" title="交易防伪"></a>交易防伪</h2><ol><li>电子签名，使用非对称加密：私钥、公钥，ECDSA 算法</li><li>双重支付问题<ul><li>余额检查：区块链追溯</li><li>双重支付：区块顺序性</li></ul></li><li>防止篡改<ul><li>最长链原则：分叉以最长链为准</li></ul></li></ol><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="工作量证明（PoW）"><a href="#工作量证明（PoW）" class="headerlink" title="工作量证明（PoW）"></a>工作量证明（PoW）</h2><p>为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。其简单的原理可以理解为，通过寻找一个随机数 nonce，使得 Hash（mixHash, nonce）的前 n 位为 0。这个方法很容易验证一个 nonce 是否合法，但是求解这个 nonce 的过程则非常耗时，几乎只能通过暴力搜索的方式得到，需要消耗大量的计算资源。最先求解到 nonce 的矿工获得大家的认可，他打包出的区块被所有节点添加到区块链的末尾，在完成区块的创建后，这个矿工会获得新铸造的币 和这个区块内所有的交易费用，作为奖励。</p><p>PoW 的优点是完全去中心化、公平，缺点是浪费资源、处理性能较低。</p><h2 id="权益证明（PoS）"><a href="#权益证明（PoS）" class="headerlink" title="权益证明（PoS）"></a>权益证明（PoS）</h2><p>权益证明机制，即拥有越多股权，就可以获得更多奖励。这里的股权是指持有的数字货币的数量和时间，根据它来分配权益，类似股票的分红制度。</p><p>持有的币越多，持有的时间越长，即币龄（币龄=持币数*持币时间）越大，就能拿到越多的分红，也就有更大的记账权利。</p><p>PoS 的优点是耗能少、作恶成本高昂、达成共识的时间短。缺点是持币趋于集中化、流动性变差。</p><h2 id="委托权益证明（DPoS）"><a href="#委托权益证明（DPoS）" class="headerlink" title="委托权益证明（DPoS）"></a>委托权益证明（DPoS）</h2><p>DPoS 在 PoS 基础上优化而来的，通过投票选举的方式，选出生产者，代表他们履行权利和义务，而不是用算力来决定。</p><p>如果生产者不称职，随时可能会被投票出局。投票的权重和分配的收益，都是按照持有的加密货币数量占总量的百分比来计算的，51%的股东的投票结果是不可逆且有约束力的。</p><p>DPoS 的优点是记账节点数量少、协作高效、记账效率高。其缺点是减弱了去中心化的程度。</p><ul><li><a href="https://bitcoin.org/zh_CN/">比特币社区</a></li><li><a href="https://ethereum.org/zh/">以太坊社区</a></li><li><a href="https://andersbrownworth.com/blockchain/">区块链示例</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;比特币&quot;&gt;&lt;a href=&quot;#比特币&quot; class=&quot;headerlink&quot; title=&quot;比特币&quot;&gt;&lt;/a&gt;比特</summary>
      
    
    
    
    <category term="区块链" scheme="https://haifuns.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="https://haifuns.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="以太坊" scheme="https://haifuns.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT Prompt</title>
    <link href="https://haifuns.com/2023/05/29/chatgpt-prompt/"/>
    <id>https://haifuns.com/2023/05/29/chatgpt-prompt/</id>
    <published>2023-05-29T02:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写-Prompt-的原则"><a href="#编写-Prompt-的原则" class="headerlink" title="编写 Prompt 的原则"></a>编写 Prompt 的原则</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><h3 id="编写清晰、具体的指令"><a href="#编写清晰、具体的指令" class="headerlink" title="编写清晰、具体的指令"></a>编写清晰、具体的指令</h3><p>通过提供尽可能清晰和具体的指令来表达希望模型执行的操作，这将引导模型给出正确的输出，并减少得到无关或不正确响应的可能。编写清晰的指令不意味着简短的指令，因为在许多情况下，更长的提示实际上更清晰且提供了更多上下文，这实际上可能导致更详细更相关的输出。</p><p>具体策略如下：</p><ol><li>使用分隔符清晰地表示输入的不同部分，分隔符可以是：```，””，&lt;&gt;，<tag>，&lt;\tag&gt;等</tag></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">把用三个双引号括起来的文本总结成一句话。</span><br><span class="line">"""</span><br><span class="line">你应该提供尽可能清晰、具体的指示，以表达你希望模型执行的任务。\</span><br><span class="line">这将引导模型朝向所需的输出，并降低收到无关或不正确响应的可能性。\</span><br><span class="line">不要将写清晰的提示与写简短的提示混淆。\</span><br><span class="line">在许多情况下，更长的提示可以为模型提供更多的清晰度和上下文信息，从而导致更详细和相关的输出。</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>要求结构化的输出，可以是 JSON、HTML 等格式</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请生成包括书名、作者和类别的三本虚构书籍清单，\</span><br><span class="line">并以 JSON 格式提供，其中包含以下键：book_id、title、author、genre。</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>要求模型检查是否满足条件</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">您将获得由三个引号括起来的文本。\</span><br><span class="line">如果它包含一系列的指令，则需要按照以下格式重新编写这些指令：</span><br><span class="line"></span><br><span class="line">第一步 - ...</span><br><span class="line">第二步 - ...</span><br><span class="line">...</span><br><span class="line">第N步 - ...</span><br><span class="line"></span><br><span class="line">如果文本中不包含一系列的指令，则直接写“未提供步骤”。</span><br><span class="line"></span><br><span class="line">"""</span><br><span class="line">泡一杯茶很容易。首先，需要把水烧开。\</span><br><span class="line">在等待期间，拿一个杯子并把茶包放进去。\</span><br><span class="line">一旦水足够热，就把它倒在茶包上。\</span><br><span class="line">等待一会儿，让茶叶浸泡。几分钟后，取出茶包。\</span><br><span class="line">如果你愿意，可以加一些糖或牛奶调味。\</span><br><span class="line">就这样，你可以享受一杯美味的茶了。</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>提供少量示例</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你的任务是以一致的风格回答问题。</span><br><span class="line"></span><br><span class="line">&lt;孩子&gt;: 教我耐心。</span><br><span class="line"></span><br><span class="line">&lt;祖父母&gt;: 挖出最深峡谷的河流源于一处不起眼的泉眼；最宏伟的交响乐从单一的音符开始；最复杂的挂毯以一根孤独的线开始编织。</span><br><span class="line"></span><br><span class="line">&lt;孩子&gt;: 教我韧性。</span><br></pre></td></tr></tbody></table></figure><h3 id="给模型时间去思考"><a href="#给模型时间去思考" class="headerlink" title="给模型时间去思考"></a>给模型时间去思考</h3><p>如果模型匆忙地得出了错误的结论，应该尝试重新构思查询，请求模型在提供最终答案之前进行一系列相关的推理。换句话说，如果给模型一个在短时间或用少量文字无法完成的任务，它可能会猜测错误。这种情况对人来说也是一样的，如果让某人在没有时间计算出答案的情况下完成复杂的数学问题，他们也可能会犯错误。因此，在这些情况下，可以指示模型花更多时间思考问题，这意味着它在任务上花费了更多的计算资源。</p><p>具体策略如下：</p><ol><li>指定完成任务所需的步骤</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-用一句话概括下面用&lt;&gt;括起来的文本。</span><br><span class="line">2-将摘要翻译成英语。</span><br><span class="line">3-在英语摘要中列出每个名称。</span><br><span class="line">4-输出一个 JSON 对象，其中包含以下键：English_summary，num_names。</span><br><span class="line"></span><br><span class="line">请使用以下格式：</span><br><span class="line">文本：&lt;要总结的文本&gt;</span><br><span class="line">摘要：&lt;摘要&gt;</span><br><span class="line">翻译：&lt;摘要的翻译&gt;</span><br><span class="line">名称：&lt;英语摘要中的姓名列表&gt;</span><br><span class="line">输出 JSON：&lt;带有 English_summary 和 num_names 的 JSON&gt;</span><br><span class="line"></span><br><span class="line">Text: &lt;在一个迷人的村庄里，兄妹杰克和吉尔出发去一个山顶井里打水。\</span><br><span class="line">他们一边唱着欢乐的歌，一边往上爬，\</span><br><span class="line">然而不幸降临——杰克绊了一块石头，从山上滚了下来，吉尔紧随其后。\</span><br><span class="line">虽然略有些摔伤，但他们还是回到了温馨的家中。\</span><br><span class="line">尽管出了这样的意外，他们的冒险精神依然没有减弱，继续充满愉悦地探索。&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>指导模型在下结论之前找出一个自己的解法</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">请判断学生的解决方案是否正确，请通过如下步骤解决这个问题：</span><br><span class="line">    - 首先，自己解决问题。</span><br><span class="line">    - 然后将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。在自己完成问题之前，请勿决定学生的解决方案是否正确。</span><br><span class="line"></span><br><span class="line">使用以下格式回答：</span><br><span class="line">    实际解决方案和步骤：实际解决方案和步骤文本</span><br><span class="line">    学生的解决方案和实际解决方案是否相同：是或否</span><br><span class="line">    学生的成绩：正确或不正确</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">    我正在建造一个太阳能发电站，需要帮助计算财务。 </span><br><span class="line">    - 土地费用为每平方英尺100美元</span><br><span class="line">    - 我可以以每平方英尺250美元的价格购买太阳能电池板</span><br><span class="line">    - 我已经谈判好了维护合同，每年需要支付固定的10万美元，并额外支付每平方英尺10美元</span><br><span class="line">    作为平方英尺数的函数，设发电站的大小为x平方英尺，首年运营的总费用是多少。</span><br><span class="line"></span><br><span class="line">学生的解决方案：</span><br><span class="line">    1. 土地费用：100x</span><br><span class="line">    2. 太阳能电池板费用：250x</span><br><span class="line">    3. 维护费用：100000+100x</span><br><span class="line">    总费用：100x+250x+100000+100x=450x+100000</span><br><span class="line">    </span><br><span class="line">实际解决方案和步骤：</span><br></pre></td></tr></tbody></table></figure><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>模型偶尔会生成一些看似真实实则编造的虚假知识。在训练过程中模型接触了大量的知识，它并没有完全记住所见的信息，因此并不清楚自己知识的边界。这意味着它可能会尝试回答有关晦涩主题的问题，并编造听起来合理但实际上并不正确的答案，这些编造的想法可以称为幻觉。</p><p>可以使用一些前文介绍的技巧以尝试在构建自己的应用程序时避免这种情况。另一种减少幻觉的策略是先要求模型找到文本中的任何相关引用，然后要求它使用这些引用来回答问题，这种追溯源文档的方法通常对减少幻觉非常有帮助。</p><h1 id="迭代式提示"><a href="#迭代式提示" class="headerlink" title="迭代式提示"></a>迭代式提示</h1><p>当你有一个想法需要使用 LLM 完成时，可以尝试编写第一个 Prompt，满足：清晰明确，并且给系统足够的时间思考。然后运行并查看结果，如果第一次效果不好，那么就找出为什么指令不够清晰或为什么没有给算法足够的时间思考，以便改进想法、改进提示等等，循环多次，直到找到的 Prompt。</p><h1 id="文本概括"><a href="#文本概括" class="headerlink" title="文本概括"></a>文本概括</h1><p>目前 LLM 在文本概括任务上展现了强大的水准，以下是文本概括 Prompt 最佳实践侧重点：</p><ul><li>限制输出文本长度</li><li>关键角度侧重，通过增加Prompt提示，来体现对于某个特定角度的侧重</li><li>关键信息提取，要求LLM进行“文本提取(Extract)”而非“文本概括(Summarize)”</li></ul><h1 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h1><p>推断任务可以看作是模型接收文本作为输入并执行某种分析的过程。这可能涉及提取标签、提取实体、理解文本情感等等。如果你想要从一段文本中提取正面或负面情感，在传统的机器学习工作流程中，需要收集标签数据集、训练模型、确定如何在云端部署模型并进行推断。这样做可能效果还不错，但是这个过程需要很多工作。而且对于每个任务，如情感分析、提取实体等等，都需要训练和部署单独的模型。</p><p>大型语言模型的一个非常好的特点是，对于许多这样的任务，你只需要编写一个prompt即可开始产生结果，而不需要进行大量的工作。这极大地加快了应用程序开发的速度。你还可以只使用一个模型来执行许多不同的任务，而不需要弄清楚如何训练和部署许多不同的模型。</p><h2 id="推断情感"><a href="#推断情感" class="headerlink" title="推断情感"></a>推断情感</h2><p>以下是一个从产品评论中推断情感的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">从评论文本中识别以下项目：</span><br><span class="line">- 情绪（正面或负面）</span><br><span class="line">- 审稿人是否表达了愤怒？（是或否）</span><br><span class="line">- 评论者购买的物品</span><br><span class="line">- 制造该物品的公司</span><br><span class="line"></span><br><span class="line">评论用三个双引号分隔。将您的响应格式化为 JSON 对象，以 “Sentiment”、“Anger”、“Item” 和 “Brand” 作为键。</span><br><span class="line">如果信息不存在，请使用 “未知” 作为值。</span><br><span class="line">让你的回应尽可能简短。</span><br><span class="line">将 Anger 值格式化为布尔值。</span><br><span class="line"></span><br><span class="line">评论文本: """</span><br><span class="line">我需要一盏漂亮的卧室灯，这款灯具有额外的储物功能，价格也不算太高。\</span><br><span class="line">我很快就收到了它。在运输过程中，我们的灯绳断了，但是公司很乐意寄送了一个新的。\</span><br><span class="line">几天后就收到了。这款灯很容易组装。我发现少了一个零件，于是联系了他们的客服，他们很快就给我寄来了缺失的零件！\</span><br><span class="line">在我看来，Lumina 是一家非常关心顾客和产品的优秀公司！"""</span><br></pre></td></tr></tbody></table></figure><h2 id="推断主题"><a href="#推断主题" class="headerlink" title="推断主题"></a>推断主题</h2><p>接下来是一个针对长文本推断主题的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">确定以下给定文本中讨论的五个主题。</span><br><span class="line"></span><br><span class="line">每个主题用1-2个单词概括。</span><br><span class="line"></span><br><span class="line">输出时用逗号分割每个主题。</span><br><span class="line"></span><br><span class="line">给定文本: """在政府最近进行的一项调查中，要求公共部门的员工对他们所在部门的满意度进行评分。</span><br><span class="line">调查结果显示，NASA 是最受欢迎的部门，满意度为 95％。</span><br><span class="line"></span><br><span class="line">一位 NASA 员工 John Smith 对这一发现发表了评论，他表示：</span><br><span class="line">“我对 NASA 排名第一并不感到惊讶。这是一个与了不起的人们和令人难以置信的机会共事的好地方。我为成为这样一个创新组织的一员感到自豪。”</span><br><span class="line"></span><br><span class="line">NASA 的管理团队也对这一结果表示欢迎，主管 Tom Johnson 表示：</span><br><span class="line">“我们很高兴听到我们的员工对 NASA 的工作感到满意。</span><br><span class="line">我们拥有一支才华横溢、忠诚敬业的团队，他们为实现我们的目标不懈努力，看到他们的辛勤工作得到回报是太棒了。”</span><br><span class="line"></span><br><span class="line">调查还显示，社会保障管理局的满意度最低，只有 45％的员工表示他们对工作满意。</span><br><span class="line">政府承诺解决调查中员工提出的问题，并努力提高所有部门的工作满意度。"""</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为特定主题制作新闻提醒：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">判断主题列表中的每一项是否是给定文本中的一个话题，</span><br><span class="line"></span><br><span class="line">以列表的形式给出答案，分为主体和结果两列，结果用 0 或 1表示。</span><br><span class="line"></span><br><span class="line">主题列表：美国航空航天局、当地政府、工程、员工满意度、联邦政府</span><br><span class="line"></span><br><span class="line">给定文本: """在政府最近进行的一项调查中，要求公共部门的员工对他们所在部门的满意度进行评分。</span><br><span class="line">调查结果显示，NASA 是最受欢迎的部门，满意度为 95％。</span><br><span class="line"></span><br><span class="line">一位 NASA 员工 John Smith 对这一发现发表了评论，他表示：</span><br><span class="line">“我对 NASA 排名第一并不感到惊讶。这是一个与了不起的人们和令人难以置信的机会共事的好地方。我为成为这样一个创新组织的一员感到自豪。”</span><br><span class="line"></span><br><span class="line">NASA 的管理团队也对这一结果表示欢迎，主管 Tom Johnson 表示：</span><br><span class="line">“我们很高兴听到我们的员工对 NASA 的工作感到满意。</span><br><span class="line">我们拥有一支才华横溢、忠诚敬业的团队，他们为实现我们的目标不懈努力，看到他们的辛勤工作得到回报是太棒了。”</span><br><span class="line"></span><br><span class="line">调查还显示，社会保障管理局的满意度最低，只有 45％的员工表示他们对工作满意。</span><br><span class="line">政府承诺解决调查中员工提出的问题，并努力提高所有部门的工作满意度。"""</span><br></pre></td></tr></tbody></table></figure><h1 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h1><p>LLM 非常擅长将输入转换成不同的格式，例如多语种文本翻译、拼写及语法纠正、语气调整、格式转换等。</p><h2 id="文本翻译"><a href="#文本翻译" class="headerlink" title="文本翻译"></a>文本翻译</h2><p>中文转英语：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将以下中文翻译成英语: \ </span><br><span class="line">"""您好，我想订购一个搅拌机。"""</span><br></pre></td></tr></tbody></table></figure><p>识别语种：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请告诉我以下文本是什么语种：</span><br><span class="line">"""Combien coûte le lampadaire?"""</span><br></pre></td></tr></tbody></table></figure><p>多语种翻译：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请将以下文本分别翻译成中文、英文、法语和西班牙语：</span><br><span class="line">"""I want to order a basketball."""</span><br></pre></td></tr></tbody></table></figure><p>翻译+正式语气：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请将以下文本翻译成中文，分别展示成正式与非正式两种语气：</span><br><span class="line">"""Would you like to order a pillow?"""</span><br></pre></td></tr></tbody></table></figure><p>通用翻译器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先告诉我以下三个引号括起来的文本是什么语种，直接输出语种，如法语，无需输出标点符号 \</span><br><span class="line">然后请将原始文本翻译为中文和英文 \</span><br><span class="line"></span><br><span class="line">按照如下格式输出：</span><br><span class="line"></span><br><span class="line">原始语言：?</span><br><span class="line">中文翻译：?</span><br><span class="line">英文翻译：?</span><br><span class="line"></span><br><span class="line">原始文本："""La performance du système est plus lente que d'habitude."""</span><br></pre></td></tr></tbody></table></figure><h2 id="语气-x2F-风格调整"><a href="#语气-x2F-风格调整" class="headerlink" title="语气/风格调整"></a>语气/风格调整</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将以下文本翻译成商务信函的格式: </span><br><span class="line">"""王总，我小赵，上回你说咱部门要采购的显示器是多少寸来着？"""</span><br></pre></td></tr></tbody></table></figure><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将以下信息从JSON转换为HTML表格，保留表格标题和列名：</span><br><span class="line">"""{ "resturant employees" :[ </span><br><span class="line">    {"name":"Shyam", "email":"shyamjaiswal@gmail.com"},</span><br><span class="line">    {"name":"Bob", "email":"bob32@gmail.com"},</span><br><span class="line">    {"name":"Jai", "email":"jai87@gmail.com"}</span><br><span class="line">]}"""</span><br></pre></td></tr></tbody></table></figure><h2 id="拼写及语法纠正"><a href="#拼写及语法纠正" class="headerlink" title="拼写及语法纠正"></a>拼写及语法纠正</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请校对并更正以下三个引号括起来的文本，注意纠正文本保持原始语种，无需输出原始文本。</span><br><span class="line">如果您没有发现任何错误，请说“未发现错误”。</span><br><span class="line">    </span><br><span class="line">例如：</span><br><span class="line">输入：I are happy.</span><br><span class="line">输出：I am happy.</span><br><span class="line"></span><br><span class="line">"""The girl with the black and white puppies have a ball."""</span><br></pre></td></tr></tbody></table></figure><h2 id="综合样例：文本翻译-拼写纠正-风格调整-格式转换"><a href="#综合样例：文本翻译-拼写纠正-风格调整-格式转换" class="headerlink" title="综合样例：文本翻译+拼写纠正+风格调整+格式转换"></a>综合样例：文本翻译+拼写纠正+风格调整+格式转换</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">针对以下三个引号之间的英文评论文本，</span><br><span class="line">首先进行拼写及语法纠错，</span><br><span class="line">然后将其转化成中文，</span><br><span class="line">再将其转化成优质淘宝评论的风格，从各种角度出发，分别说明产品的优点与缺点，并进行总结。</span><br><span class="line">润色一下描述，使评论更具有吸引力。</span><br><span class="line"></span><br><span class="line">最终输出 markdown 格式的结果：</span><br><span class="line">【优点】xxx</span><br><span class="line">【缺点】xxx</span><br><span class="line">【总结】xxx</span><br><span class="line"></span><br><span class="line">注意，只需填写xxx部分，并分段输出。</span><br><span class="line"></span><br><span class="line">"""Got this for my daughter for her birthday cuz she keeps taking \</span><br><span class="line">mine from my room.  Yes, adults also like pandas too.  She takes \</span><br><span class="line">it everywhere with her, and it's super soft and cute.  One of the \</span><br><span class="line">ears is a bit lower than the other, and I don't think that was \</span><br><span class="line">designed to be asymmetrical. It's a bit small for what I paid for it \</span><br><span class="line">though. I think there might be other options that are bigger for \</span><br><span class="line">the same price.  It arrived a day earlier than expected, so I got \</span><br><span class="line">to play with it myself before I gave it to my daughter."""</span><br></pre></td></tr></tbody></table></figure><h1 id="文本扩展"><a href="#文本扩展" class="headerlink" title="文本扩展"></a>文本扩展</h1><p>扩展是将短文本输入到大型语言模型中，让模型生成更长的文本。例如将大型语言模型用作头脑风暴的伙伴。但这种做法也存在一些问题，例如某人可能会使用它来生成大量垃圾邮件。因此，应该以负责任和有益的方式使用大型语言模型的这些功能。</p><p>以下是一个根据客户评价和评论情感生成定制电子邮件实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">你是一位客户服务的AI助手。</span><br><span class="line">你的任务是给一位重要客户发送邮件回复。</span><br><span class="line">根据客户通过{{{}}}包含的评价，生成回复以感谢客户的评价。提醒模型使用评价中的具体细节</span><br><span class="line">用简明而专业的语气写信。</span><br><span class="line">作为“AI客户代理”签署电子邮件。</span><br><span class="line">客户评论：</span><br><span class="line">{{{他们在11月份的季节性销售期间以约49美元的价格出售17件套装，折扣约为一半。\</span><br><span class="line">但由于某些原因（可能是价格欺诈），到了12月第二周，同样的套装价格全都涨到了70美元到89美元不等。\</span><br><span class="line">11件套装的价格也上涨了大约10美元左右。\</span><br><span class="line">虽然外观看起来还可以，但基座上锁定刀片的部分看起来不如几年前的早期版本那么好。\</span><br><span class="line">不过我打算非常温柔地使用它，例如，\</span><br><span class="line">我会先在搅拌机中将像豆子、冰、米饭等硬物研磨，然后再制成所需的份量，\</span><br><span class="line">切换到打蛋器制作更细的面粉，或者在制作冰沙时先使用交叉切割刀片，然后使用平面刀片制作更细/不粘的效果。\</span><br><span class="line">制作冰沙时，特别提示：\</span><br><span class="line">将水果和蔬菜切碎并冷冻（如果使用菠菜，则轻轻煮软菠菜，然后冷冻直到使用；\</span><br><span class="line">如果制作果酱，则使用小到中号的食品处理器），这样可以避免在制作冰沙时添加太多冰块。\</span><br><span class="line">大约一年后，电机发出奇怪的噪音，我打电话给客服，但保修已经过期了，所以我不得不再买一个。\</span><br><span class="line">总的来说，这些产品的总体质量已经下降，因此它们依靠品牌认可和消费者忠诚度来维持销售。\</span><br><span class="line">货物在两天内到达。}}}</span><br><span class="line">评论情感：悲观</span><br></pre></td></tr></tbody></table></figure><h2 id="随机性调整（temperature）"><a href="#随机性调整（temperature）" class="headerlink" title="随机性调整（temperature）"></a>随机性调整（temperature）</h2><p>在使用 API 调用时，可以使用temperature参数来改变模型响应的多样性，可以将温度视为模型探索或随机性的程度。</p><p>一般来说，在构建需要可靠和可预测响应的应用程序时，建议使用温度为零。如果尝试以更具创意的方式使用模型，可能需要更广泛地输出不同的结果，那么可能需要使用更高的温度。</p><h1 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h1><p>只需要很少的工作量，就可以使用大型语言模型来构建一个定制的聊天机器人。接下来我们将探索如何利用聊天格式（接口）与个性化或专门针对特定任务或行为的聊天机器人进行延伸对话。</p><p>如果你曾经使用过 ChatGPT 网页界面，那么你的消息是用户消息，而 ChatGPT 的消息是助手消息。<br>在使用 API 时还可以使用一种系统消息，提供总体的指示，系统消息有助于设置助手的行为和角色，并作为对话的高级指示。可以想象它在助手的耳边低语，引导它的回应，而用户不会注意到系统消息。<br>系统消息的好处是为开发者提供了一种在不让请求本身成为对话的一部分的情况下，引导助手并指导其回应的方法。</p><p>每次与语言模型的交互都是一个独立的交互，这意味着必须提供所有相关的消息，以便模型在当前对话中进行引用。如果想让模型引用或 “记住”对话的早期部分，则必须在模型的输入中提供早期的交流，可以将其称为上下文。</p><p>例如可以发送一组消息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[  </span><br><span class="line">    {'role':'system', 'content':'你是个友好的聊天机器人。'},</span><br><span class="line">    {'role':'user', 'content':'Hi, 我是Isa'},</span><br><span class="line">    {'role':'assistant', 'content': "Hi Isa! 很高兴认识你。今天有什么可以帮到你的吗?"},</span><br><span class="line">    {'role':'user', 'content':'是的，你可以提醒我, 我的名字是什么?'}  </span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>现在我们给模型提供了上下文，也就是之前的对话中提到的我的名字，然后我们会问同样的问题，也就是我的名字是什么。因为模型有了需要的全部上下文，所以它能够正确做出回应。</p><ul><li><a href="https://github.com/datawhalechina/prompt-engineering-for-developers">吴恩达 x OpenAI 《ChatGPT Prompt Engineering for Developers》课程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写-Prompt-的原则&quot;&gt;&lt;a href=&quot;#编写-Prompt-的原则&quot; class=&quot;headerlink&quot; title=&quot;编写 Prompt 的原则&quot;&gt;&lt;/a&gt;编写 Prompt 的原则&lt;/h1&gt;&lt;h2 id=&quot;基本原则&quot;&gt;&lt;a href=&quot;#基本原则&quot;</summary>
      
    
    
    
    <category term="AGI" scheme="https://haifuns.com/categories/AGI/"/>
    
    
    <category term="AIGC" scheme="https://haifuns.com/tags/AIGC/"/>
    
    <category term="ChatGPT" scheme="https://haifuns.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>【ES】查询缓存</title>
    <link href="https://haifuns.com/2023/03/07/es-05/"/>
    <id>https://haifuns.com/2023/03/07/es-05/</id>
    <published>2023-03-07T13:45:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<p>ES 内部有多种缓存用来提高查询效率，缓存类型如下：</p><ol><li>Shard Request Cache</li><li>Node Query Cache (Filter Cache)</li><li>Field Data Cache</li></ol><h1 id="Shard-Request-Cache"><a href="#Shard-Request-Cache" class="headerlink" title="Shard Request Cache"></a>Shard Request Cache</h1><p>Shard Request Cache 简称 Request Cache，是分片级别的查询缓存。Request Cache 缓存的 key 是整个客户端请求，value 是单个分片的查询结果。</p><p>并非所有分片级别查询请求都会被缓存，Request Cache 的主要作用是对聚合的缓存，聚合过程是实时计算，通常会消耗很多资源，缓存对聚合来说意义重大。默认情况下，Request Cache 只对 <code>size = 0</code>的请求结果生效。</p><p>不被缓存的条件包括：</p><p>scroll、设置了 profile 属性，查询类型不是 QUERY_THEN_FETCH，以及设置了 requestCache = false 等请求类型。另外还包括一些存在不确定性的查询，例如：范围查询带有 now，由于它是毫秒级别的，缓存下来没有意义，类似的还有在脚本查询中使用了 Math.random()、new Date() 等函数的查询也不会进行缓存。</p><p>查询结果中被缓存的内容主要包括：</p><p>hits.total、aggregations（聚合结果）、以及 suggestions等。</p><p>Request Cache 缓存失效条件包括：</p><ol><li>当 segment 变更，分片被刷新时，缓存会失效。</li><li>当缓存已满，会使用最近最少使用 LRU 原则删除缓存。默认情况下 ES 会给每个节点分配最多堆内存的 1% 作为 Request Cache。</li></ol><h1 id="Node-Query-Cache-Filter-Cache"><a href="#Node-Query-Cache-Filter-Cache" class="headerlink" title="Node Query Cache (Filter Cache)"></a>Node Query Cache (Filter Cache)</h1><p>Node Query Cache 也称为 Filter Cache，用来缓存 filter 子查询语句在 segment 上的结果。缓存的 key 为 filter 子查询，value 为查询结果，其中查询结果是匹配到的 document numbers，保存在位图 BitSet 中。当整个查询有多个 filter 子查询时，交并集直接对位图做位运算即可。</p><p>并非所有的 filter 查询都会被缓存，策略如下：</p><ul><li>某些类型的查询永远不会被缓存，例如：TermQuery、MatchAllDocsQuery、MatchNoDocsQuery、以及子查询为空的BooleanQuery、DisjunctionMaxQuery。</li><li>某条 query 的访问频率大于等于特定阈值之后，该 query 结果才会被缓存。对于访问频率，主要分为 2 类，一类是访问 2 次就会被缓存，包括： MultiTermQuery、MultiTermQueryConstantScore、TermInSetQuery、PointQuery，其余类型的查询访问 5 次会被缓存。</li></ul><p>由于 Filter Cache 是为每个 segment 建立的，当 segment 合并的时候，被删除的 segment 其关联缓存会失效。其次，对于体积较小的 segment 不会建立缓存，因为他们很快会被合并。只要当 segment 的 doc 数量大于 10000，并且占整个分片的 3% 以上才会走缓存策略。</p><p>默认情况下，缓存最多可容纳 10000 个查询，最大占总堆空间的 10%。当缓存已满，同样会使用最近最少使用 LRU 原则删除缓存。</p><h1 id="Field-Data-Cache"><a href="#Field-Data-Cache" class="headerlink" title="Field Data Cache"></a>Field Data Cache</h1><p>fielddata 与 docValues 类似，都是用于支持排序、聚合以及脚本等需求，使用列式存储。不过 docValues 不支持 text 类型，而 fielddata 专用于 text 类型，默认被禁用。</p><p>Field Data Cache 包含字段数据和全局序号，用于支持 text 类型上的聚合。在首次将 text 类型字段用于聚合、排序或脚本场景时，ES 会按需构建 fielddata 数据结构。通过从磁盘读取每个 segment 的反向索引，反转术语 -&gt; 文档关系并将结果存储在 JVM 堆中。默认情况下，Field Data Cache 大小是无限的，内存会不断增长，直到达到断路器设定的限制。如果达到断路器限制，ES 将阻止进一步增加缓存大小的请求。在这种情况下，可以手动清除缓存。</p><p>如果设置了内存大小限制，将使用 LRU 清除最近最少更新的条目，此设置会自动避免断路器限制，但代价是会根据需要重建缓存。</p><h1 id="手动清理缓存"><a href="#手动清理缓存" class="headerlink" title="手动清理缓存"></a>手动清理缓存</h1><p>对于 ES 和 Lucene 层面的三种缓存，可以使用 REST API 手动清除。</p><p>清除指定索引或全部索引的缓存：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /&lt;index&gt;/_cache/clear    #清理指定索引的 cache，支持多个</span><br><span class="line">POST /_cache/clear            #清理整个集群的 cache</span><br></pre></td></tr></tbody></table></figure><p>只清理特定缓存：</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /&lt;index&gt;/_cache/clear?query=true     #只清理 query cache</span><br><span class="line">POST /&lt;index&gt;/_cache/clear?request=true   #只清理 request cache</span><br><span class="line">POST /&lt;index&gt;/_cache/clear?fielddata=true #只清理 fields cache</span><br></pre></td></tr></tbody></table></figure><p>通过 fields 参数指定清理部分字段的缓存：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /my-index/_cache/clear?fields=foo,bar </span><br></pre></td></tr></tbody></table></figure><p>不建议在生产环境中进行手动清除缓存，会对查询性能产生较大的影响，手动清除缓存一般只用于测试和验证场景。</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/shard-request-cache.html">Shard request cache settings</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/query-cache.html">Node query cache settings</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/modules-fielddata.html">Field data cache settings</a></li><li><a href="https://easyice.cn/archives/367">关于 Elasticsearch 的查询缓存，你想知道的都在这里</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES 内部有多种缓存用来提高查询效率，缓存类型如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shard Request Cache&lt;/li&gt;
&lt;li&gt;Node Query Cache (Filter Cache)&lt;/li&gt;
&lt;li&gt;Field Data Cache&lt;/li&gt;
&lt;/ol&gt;</summary>
      
    
    
    
    <category term="搜索引擎" scheme="https://haifuns.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://haifuns.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【ES】搜索原理</title>
    <link href="https://haifuns.com/2023/03/06/es-04/"/>
    <id>https://haifuns.com/2023/03/06/es-04/</id>
    <published>2023-03-06T02:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lucene-相关度评分"><a href="#Lucene-相关度评分" class="headerlink" title="Lucene 相关度评分"></a>Lucene 相关度评分</h1><p>ES 底层基于 Lucene 进行评分，公式如下：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.018ex" xmlns="http://www.w3.org/2000/svg" width="63.044ex" height="3.167ex" role="img" focusable="false" viewBox="0 -950 27865.4 1400"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(902,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1838,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(2304,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2693,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(3153,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3597.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(4117.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4784.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(5840.2,0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="mo" transform="translate(7284.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7673.2,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(8034.2,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(8584.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(8973.2,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mtext" transform="translate(9334.2,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(9584.2,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(9929.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mtext" transform="translate(10529.2,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(10779.2,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(11299.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(11910.4,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(12632.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(12977.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(13497.7,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mo" transform="translate(14047.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(14436.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="msup" transform="translate(14797.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mn" transform="translate(422,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(15845.4,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(16567.7,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(16928.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(17373.3,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(17850.3,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(18316.3,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(18677.3,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(19436.3,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(19921.3,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(20406.3,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(20875.3,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(21236.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(21625.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(22236.6,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(22958.8,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(23558.8,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(24043.8,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(24494.8,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(25372.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(25761.8,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(26122.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(26567.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(27087.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(27476.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>其中：</p><ul><li>q：查询</li><li>d：当前文档</li><li>t：q 中的词条</li><li>tf(t in d)：词条 t 在文档 d 中的词频</li><li>idf(t)：词条t在整个索引中的逆文档频率（逆文档频率：在同一个索引中存在该词条的文档数的倒数）</li></ul><p>词条在文档中出现的频率越高，得分越高。索引中存在该词条的文档越少，得分越高。</p><h1 id="ES-搜索评分过程"><a href="#ES-搜索评分过程" class="headerlink" title="ES 搜索评分过程"></a>ES 搜索评分过程</h1><p>ES 有两种搜索类型：<code>QUERY_THEN_FETCH</code> 和 <code>DFS_QUERY_THEN_FETCH</code>。下面分别对两种类型搜索过程进行详细介绍。</p><h2 id="QUERY-THEN-FETCH"><a href="#QUERY-THEN-FETCH" class="headerlink" title="QUERY_THEN_FETCH"></a>QUERY_THEN_FETCH</h2><p>ES 默认的搜索类型是<code>QUERY_THEN_FETCH</code>，搜索流程分为 Query 和 Fetch 两个阶段。</p><p>Query 阶段：</p><ol><li>ES 收到客户端搜索请求后，会由协调节点将请求分发给对应索引的每个 Shard 上。</li><li>每个 Shard 的 Lucene 实例基于本地 Shard 内的 TF/IDF 统计信息，独立完成 Shard 内的索引匹配和打分，并根据打分结果完成单个 Shard 内的排序、分页。</li><li>每个 Shard 将排序分页后的结果集元数据（文档id和分数）返回给协调节点。</li><li>协调节点完成整体的汇总、排序和分页，筛选出最终确认返回的搜索结果。</li></ol><p>Fetch 阶段：</p><ol><li>协调节点根据筛选结果去对应 Shard 拉取完整的文档数据。</li><li>整合最终的结果返回给客户端。</li></ol><p><code>QUERY_THEN_FETCH</code>查询可能存在的问题：在极端情况下，Shard 中的文档数差距较大，那么 IDF 在不同 Shard 中起到的作用会截然不同，从而影响单个 Shard 内打分汇总后的结果，导致全局打分汇总的结果与预期产生较大出入。</p><h2 id="DFS-QUERY-THEN-FETCH"><a href="#DFS-QUERY-THEN-FETCH" class="headerlink" title="DFS_QUERY_THEN_FETCH"></a>DFS_QUERY_THEN_FETCH</h2><p>ES 另一种搜索类型是<code>DFS_QUERY_THEN_FETCH</code>，DFS 在这里意思是分布式频率打分，其思想是提前向所有 Shard 进行全局的统计信息搜集，然后将这些统计信息随着查询分发到各个 Shard，让各个 Shard 在本地采用全局 TF/IDF 打分。</p><p>整个搜索流程分为预统计阶段、Query 阶段和 Fetch 阶段。</p><p>预统计阶段：</p><p>ES 在收到客户端搜索请求后，由协调阶段进行一次预统计工作，即向所有相关 Shard 搜集统计信息。</p><p>Query 阶段：</p><ol><li>由协调节点整合所有统计信息，将全局的统计信息连同请求一起分发到对应索引的每个 Shard 上。</li><li>每个 Shard 的 Lucene 实例基于 TF/IDF 统计信息独立完成 Shard 内的索引匹配和打分，并根据打分结果完成单个 Shard 内的排序和分页。</li><li>每个 Shard 将排序分页后的结果集的元数据返回给协调节点。</li><li>协调节点完成整体的汇总、排序和分页，筛选出最终确认返回的搜索结果。</li></ol><p>Fetch 阶段：</p><ol><li>协调节点根据筛选结果去对应 Shard 拉取完整的文档数据。</li><li>整合最终的结果返回给客户端。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lucene-相关度评分&quot;&gt;&lt;a href=&quot;#Lucene-相关度评分&quot; class=&quot;headerlink&quot; title=&quot;Lucene 相关度评分&quot;&gt;&lt;/a&gt;Lucene 相关度评分&lt;/h1&gt;&lt;p&gt;ES 底层基于 Lucene 进行评分，公式如下：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="搜索引擎" scheme="https://haifuns.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://haifuns.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【ES】写入原理</title>
    <link href="https://haifuns.com/2023/03/05/es-03/"/>
    <id>https://haifuns.com/2023/03/05/es-03/</id>
    <published>2023-03-05T06:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写索引流程"><a href="#写索引流程" class="headerlink" title="写索引流程"></a>写索引流程</h1><p>写索引只能先写主分片然后同步到副本，当一个写请求被发送到某个节点后，这个节点会充当协调节点，根据路由策略找到目标主分片，然后协调节点从自身存储的分片信息中找到目标主分片所在节点，如果目标分片在其他节点上，就转发请求到该节点上。</p><p>分片路由策略如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></tbody></table></figure><p>routing 通过 Hash 函数生成一个数字，然后除以主分片数量后余数为目标分片，范围是 <code>0 ~ 主分片数 - 1</code>。</p><p>routing 默认是文档的 <code>_id</code>，可以设置成一个自定义的值。</p><blockquote><p>通过了解路由策略也就可以理解为什么在创建索引时就要确定好分片数量并且不可变更，因为如果数量变化，那么所有之前路由的值都会失效，数据也就找不到了。</p></blockquote><p>当写请求被路由到所在主分片对应的节点上后，该数据节点会接受请求并写入到磁盘，然后并发将数据复制到所有副本分片（乐观锁），一旦所有副本都响应成功，主分片所在节点会向协调节点返回成功，协调节点向客户端返回成功。</p><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>ES 内部是通过 Lucene 完成索引的创建写入和搜索，当新增一个文档时，Lucene 首先会进行分词等预处理，然后将文档索引写入到内存缓冲区中，并将本次操作写入事务日志（translog，类似mysql的binlog）用于宕机后内存数据的恢复。translog 写入时会先被写到 os cache，默认情况下每隔 5s 会被 flush 到磁盘中，因此宕机最多会丢失 5s 数据。</p><p>默认情况下，Lucene 每隔 1s （<code>refresh_interval</code>）将内存缓冲区中的数据刷到文件系统缓存中，称为一个段（segment），一旦刷入文件系统缓存，segment才可以被用于索引。</p><blockquote><p><code>refresh_interval</code>决定了 ES 数据的实时性，因此 ES 是一个准实时系统。</p></blockquote><p>segment 在磁盘中是不可修改的，因此避免了磁盘的随机写，所有随机写都在内存中进行。随着时间推移，segment 越来越多，默认情况下 Lucene 每隔 30min 或 segment 空间大于 512M，将缓存中的 segment 持久化到磁盘，称为一个 commit point，此时会删除对应的 translog。 </p><p>segement 存储文件不可修改，新增、更新和删除处理过程如下：</p><ul><li>新增：数据是新的，只需要对当前文档新增一个 segment</li><li>删除：不会移除旧 segemnt 中的文档，而是新增一个 <code>.del</code> 文件标记删除，被标记删除的文档仍可以被查询到，但在最终结果返回前会被移除</li><li>更新：相当于删除+新增两个动作，旧版本文档会被在 <code>.del</code> 文件中标记删除，同时新版本文档会被索引到新 segment。两个版本的文档都会被查询匹配到，但旧版本文档会在结果集返回前被移除。</li></ul><p>segment 不可修改优缺点：</p><ul><li>优点<ul><li>不需要锁，因为没有并发修改数据的问题。</li><li>性能提升，由于其不变性，一旦索引被读入内核的文件系统缓存，便会驻留。只要文件系统缓存还有足够空间，大部分读请求会直接读缓存，而不会读磁盘。</li><li>其他缓存（如 Filter 缓存）在索引声明周期内始终有效，不需要再每次数据变化时重建，因为数据不会变化。</li><li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引使用量。</li></ul></li><li>缺点<ul><li>空间浪费，更新和删除时，旧文档数据不会立即被删除而是被标记删除占用磁盘空间。</li><li>资源消耗大，每次新增数据都需要新增一个 segment，当 segment 过多时，对服务器资源如文件句柄消耗很大。</li><li>增加了查询负担，查询结果需要排除标记删除的文档。</li></ul></li></ul><h1 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h1><p>由于每刷新一次就会新建一个 segment，导致短时间内 segment 数量暴增，而且 segment 数量太多会带来很多麻烦。大量 segment 会影响读性能，每个 segment 都会消耗文件句柄、内存和 CPU 运行周期，更重要的是，每个搜索请求都会轮流检查每个 segment 然后合并查询结果，segment 越多，搜索越慢。</p><p>因此 Lucene 会按照一定策略将 segment 合并，合并时会清理被标记删除的文档，合并后数据被拷贝到一个新的大 segment 中。合并过程中不会中断索引和搜索。合并结束后，老的 segment 会被删除，新的 segment 被刷新到磁盘，同时写入一个包含新 segment、排除旧的和较小 segment 的新提交点，新的 segment 被打开用于搜索。</p><p>段合并计算量庞大，并且需要进行大量磁盘 I/O，因而会影响写入速率，ES 在默认情况下会对合并流程进行资源限制，以保证搜索性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写索引流程&quot;&gt;&lt;a href=&quot;#写索引流程&quot; class=&quot;headerlink&quot; title=&quot;写索引流程&quot;&gt;&lt;/a&gt;写索引流程&lt;/h1&gt;&lt;p&gt;写索引只能先写主分片然后同步到副本，当一个写请求被发送到某个节点后，这个节点会充当协调节点，根据路由策略找到目标主分</summary>
      
    
    
    
    <category term="搜索引擎" scheme="https://haifuns.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://haifuns.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【ES】存储原理</title>
    <link href="https://haifuns.com/2023/03/03/es-02/"/>
    <id>https://haifuns.com/2023/03/03/es-02/</id>
    <published>2023-03-03T11:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分片和副本"><a href="#分片和副本" class="headerlink" title="分片和副本"></a>分片和副本</h1><p>ES 中的索引由多个主分片组成，不同的主分片分布在不同的节点上。每个主分片都有一个或多个副本分片，即主分片的复制。主分片和对应的副本分片不会落在同一个节点上，避免数据丢失，副本分片数的最大值为节点数 - 1。副本的数量可以在索引创建后动态调整，而分片的数量只能在索引创建时指定。</p><p>文档的新增、修改等写请求必须在主分片完成，并且被复制到副本，当所有副本分片都写成功才会向协调节点报告成功，协调节点向客户端返回成功。ES 为了解决并发写操作过程中的数据冲突问题，通过乐观锁的方式控制，每个文档都有一个 _version 号，当文档被修改时版本号递增。副本分片可以处理读请求（如搜索或获取文档），从而减轻主分片的压力，提高系统的吞吐量。</p><h1 id="Lucene-索引"><a href="#Lucene-索引" class="headerlink" title="Lucene 索引"></a>Lucene 索引</h1><p>ES 底层基于 Lucene，实际上每个索引分片都对应着一个 Lucene 索引。一个 Lucene 索引 可能由多个子索引/segment 组成，每个 segment 都是一个完全独立的索引，可以单独搜索。segment 文件本身不可变，只能通过以下两种方式变更：</p><ol><li>新增文档时创建新 segment</li><li>合并 segment</li></ol><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>每个 segment 维护以下内容：</p><ul><li>Segment Info：段元数据，例如文档数量、使用的文件</li><li>Field names：索引中使用的字段名称集合</li><li>Stored Field values：每个文档，每个属性值对列表</li><li>Term dictionary：所有文档所有属性值字典</li><li>Term Frequency data：包含词的文档编号，以及词出现频率</li><li>Term Proximity data：词在文档中出现的位置</li><li>Per-document values：文档每个属性值，列式存储</li><li>…</li></ul><h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>Lucene 索引文件大致可以分为以下四个部分：</p><ol><li>词典<ul><li>.tip：词典索引（前缀和后缀指针，需内存加载）</li><li>.tim：后缀词块、倒排表指针</li></ul></li><li>倒排表<ul><li>.doc：倒排表、词频</li></ul></li><li>正向文件（行式存储）<ul><li>.fnm：文件field元信息</li><li>.fdx：文档位置索引（需内存加载）</li><li>.fdt：文档值</li></ul></li><li>DocValues（列式存储）<ul><li>.dvm：DocValues元信息</li><li>.dvd：DocValues值</li></ul></li></ol><h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><p>全文检索技术绝大多数都是基于倒排索引，Lucene 也是如此。倒排索引由词典和倒排表两部分组成，其中词典结构尤为重要，其效率好坏直接影响查询效率。一个合格的词典结构需要具备以下特点：</p><ol><li>查询速度快</li><li>内存占用小</li><li>内存和磁盘相结合</li></ol><p>常见词典优缺点：</p><table><thead><tr><th>数据结构</th><th>优缺点</th></tr></thead><tbody><tr><td>排序列表</td><td>实现简单，但性能差</td></tr><tr><td>哈希表</td><td>性能好，但内存占用大</td></tr><tr><td>跳跃表</td><td>占用内存小且可调，但对模糊查询支持不好</td></tr><tr><td>B树</td><td>磁盘索引，更新方便，但检索速度慢，多用于数据库应用</td></tr><tr><td>字典树</td><td>查询效率只与字符串长度有关，但只适合英文词典</td></tr><tr><td>双数组字典树</td><td>可做中文词典，内存占用小，多用于分词</td></tr><tr><td>Finite State Transducers(FST，有限状态转移机)</td><td>共享前缀，内存占用小，但要求输入有序，更新不易</td></tr></tbody></table><p>在 Lucene3.0 之前，Lucene 词典结构使用的是跳跃表结构，3.0 之后使用 FST 结构，但跳跃表在其他地方还有应用，如倒排表合并和文档号索引。</p><p>回到 Lucene 词典，tip 文件部分，文档每列对应一个 FST 索引，每个 FST 存放前缀和后缀指针。tim 文件中存放的是后缀块和词的其他信息如倒排表指针、TF（词频）、IDF（逆文档频率） 等。所以词典部分的检索过程如下：</p><ol><li>内存加载 tip 文件，通过 FST 匹配前缀找到后缀词块位置。</li><li>读取磁盘 tim 文件中的后缀块，并找到后缀和倒排表位置信息。</li><li>到 doc 文件中加载倒排表。</li></ol><h3 id="倒排表"><a href="#倒排表" class="headerlink" title="倒排表"></a>倒排表</h3><p>倒排表就是文档号集合，Lucene 中使用的倒排表结构为 Frame of reference，其特点有二：</p><ol><li>数据压缩，通过增量编码方式压缩有序的文档号集合。</li><li>跳跃表加速合并，在布尔查询时，and/or 操作都需要合并倒排表，利用跳跃表可以快速定位到相同文档号。</li></ol><h3 id="正向文件"><a href="#正向文件" class="headerlink" title="正向文件"></a>正向文件</h3><p>正向文件就是原始文档，其存储特点是分块 + 压缩。</p><ul><li>fdt 文件存放原始文档，占索引库 90% 的磁盘空间，文档以 chunk 块存放，chunk 中包含起始文档、文档数、压缩后的文档内容信息，chunk 中起始文档值使用了平均值压缩算法。</li><li>fdx 为文档号索引，使用跳跃表结构。每 1024 个 chunk 位置归为一个 block，block 中记录起始文档值，相当于一级调表。</li></ul><p>查找原始文档过程如下：</p><ol><li>二分查找 block，定位到文档所在 block</li><li>继续查找定位到 chunk 位置</li><li>加载 fdt 文件指定 chunk，找到文档</li></ol><h3 id="DocValues"><a href="#DocValues" class="headerlink" title="DocValues"></a>DocValues</h3><p>在需要对检索结果进行分类、排序、数学计算等聚合操作时，需要文档编号到值的快速映射，这时无论是倒排所以还是行式存储都无法满足需要。Lucene 使用列式存储 DocValues 来解决这一问题。</p><p>Lucene 有五种类型的 DocValues：<code>NUMERIC</code>、<code>BINARY</code>、<code>SORTED</code>、<code>SORTED_SET</code>、<code>SORTED_NUMERIC</code>，针对每种类型都有特定的压缩方法。 </p><ul><li><a href="https://lucene.apache.org/core/7_2_1/core/org/apache/lucene/codecs/lucene70/package-summary.html">Lucene 7.0 包文件说明</a></li><li><a href="https://blog.csdn.net/sanmi8276/article/details/112978473">Lucene—底层实现原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分片和副本&quot;&gt;&lt;a href=&quot;#分片和副本&quot; class=&quot;headerlink&quot; title=&quot;分片和副本&quot;&gt;&lt;/a&gt;分片和副本&lt;/h1&gt;&lt;p&gt;ES 中的索引由多个主分片组成，不同的主分片分布在不同的节点上。每个主分片都有一个或多个副本分片，即主分片的复制。主</summary>
      
    
    
    
    <category term="搜索引擎" scheme="https://haifuns.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://haifuns.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【ES】集群架构</title>
    <link href="https://haifuns.com/2023/03/02/es-01/"/>
    <id>https://haifuns.com/2023/03/02/es-01/</id>
    <published>2023-03-02T10:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h1><p>ES 集群中可以有多种节点，节点类型可以配置：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node.master:</span> <span class="string">trur/false</span> <span class="comment"># 是否是候选主节点</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span><span class="string">/false</span> <span class="comment"># 是否是数据节点</span></span><br></pre></td></tr></tbody></table></figure><ul><li>候选主节点：参与选主投票</li><li>主节点：需是候选主节点，负责索引添加和删除，维护元数据信息（集群节点、索引、索引映射和配置、索引分片和节点对应关系、分片 in-sync 副本集合）</li><li>数据节点：负责对数据增、删、改、查、聚合等操作，以及数据存储</li><li>协调节点：任意节点都可作为协调节点接受客户端请求，负责分发请求、收集结果等操作</li></ul><h1 id="选举master"><a href="#选举master" class="headerlink" title="选举master"></a>选举master</h1><p>在 ES 节点启动时，会通过 ping 其他节点得到活跃 master 列表以及候选主节点列表，进而决定是接受已有活跃 master，还是发起 master 选举。</p><p>ES 通过指定 <code>discovery.zen.minimum_master_nodes</code> 设置 quorum 数量，一般设置为候选主节点数的一半 + 1，使用多数派原则保证只有一个 master。</p><p>选主的发起由候选主节点发起，如果当前候选主节点发现自己不是 master 节点，并且通过 ping 其他节点发现无法联系到主节点，并且包括自己在内已经有超过 quorum 个节点无法联系到主节点，那么这个时候则发起选主。</p><p>选主时按照集群节点的参数 <code>&lt;stateVersion, id&gt;</code> 排序。stateVersion 从大到小排序，id 从小到大排序，选出版本最新、id 最小的候选主节点作为 master（Bully算法）。</p><h1 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h1><p>在 master-slave 架构中，不可避免的会提到脑裂问题，即集群中选举出多个 master 的情况。</p><p>ES 中可能造成脑裂问题原因如下：</p><ul><li>网络问题：集群间网络出现延迟或者形成网络分区</li><li>节点假死：主节点既是 mater 又是 data，搜索负载过大/长时间GC 导致失去响应</li></ul><p>针对脑裂问题可作出优化措施如下：</p><ol><li>适当调大响应超时时间，减少误判。</li><li>设置选举时需要参与选举的候选主节点的节点数（<code>discovery.zen.munimum_master_nodes</code> 默认1），官方建议值：候选主节点个数/2+1，这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性。</li><li>角色分离，将候选主节点与数据节点进行角色分离，减轻主节点负担。</li></ol><h1 id="元数据同步"><a href="#元数据同步" class="headerlink" title="元数据同步"></a>元数据同步</h1><p>当选举出 master 后，接着会同步集群的元数据（node、索引、shard等信息），从而保证数据是最新的。</p><p>所有 node 会把自己的集群元数据发送给 master，当 quorum 以上数量的 node 上报集群元数据后，master 会选择一个最新的版本，然后下发给所有 node。当 quorum 以上数量的 node 完成集群元数据同步后，即认为集群元数据整体同步操作成功。</p><h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>master 基于集群元数据会给每个索引分配主副 shard 以及所在的 node，然后下发到 node。</p><p>主 shard 所在 node 读取 lucene 磁盘文件以及 translog 文件恢复出索引 shard 数据，然后生成快照同步到副 shard。</p><h1 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h1><ul><li>yellow，如果一个索引主分片分配和恢复完成，索引就是 yellow 状态，所有索引都是 yellow 状态，集群就是 yellow 状态。</li><li>green，如果一个索引所有分片都分配和恢复完成，索引就是 green 状态，所有索引都是 green 状态，集群就是 green 状态。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;节点类型&quot;&gt;&lt;a href=&quot;#节点类型&quot; class=&quot;headerlink&quot; title=&quot;节点类型&quot;&gt;&lt;/a&gt;节点类型&lt;/h1&gt;&lt;p&gt;ES 集群中可以有多种节点，节点类型可以配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="搜索引擎" scheme="https://haifuns.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://haifuns.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>【Go入门】函数&amp;方法&amp;接口</title>
    <link href="https://haifuns.com/2023/02/02/go-fmi/"/>
    <id>https://haifuns.com/2023/02/02/go-fmi/</id>
    <published>2023-02-02T04:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数声明包含函数名、形式参数列表、返回值列表（可省略）以及函数体。定义方式如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> {</span><br><span class="line">    body</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>方法名首字母大写才能被其他文件使用</li><li>函数中基本数据类型和数组默认都是值传递，修改不会影响原始值</li><li>不支持传统函数重载</li><li>函数的类型称为函数的签名，如果两个函数形式参数列表和返回值列表中的变量一一对应，则两个函数有相同的签名。</li><li>函数类型的零值是nil，函数值可以与nil比较，函数值之间不可比较</li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>拥有函数名的函数只能在包级语法块中被声明，函数字面量不受限制。<br>函数字面量是一种表达式即：func关键字后没有函数名，它的值称为匿名函数。</p><h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><p>defer，延迟函数调用，不限制使用次数，执行时按调用defer语句顺序的倒序进行。</p><h2 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h2><p>当运行时发生panic异常时，程序会中断运行，并立即执行在改goroutine中被延迟的函数（defer机制）。<br>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常，panci函数接受任何值作为参数，当某些不应该发生的场景发生时，就可以调用panic中断运行。</p><h2 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h2><p>当在deferred函数中调用内置函数recover，当程序发生panic异常时，revocer会使程序从panic中恢复，并返回panic value，未发生panic异常时，recover会返回nil。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicRecover</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>, err error)</span></span> {</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="comment">// recover, 捕获异常</span></span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p {</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">-1</span></span><br><span class="line">            err = fmt.Errorf(<span class="string">"internal error: %v"</span>, p)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"manual throw error"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在函数声明时，在名字前放一个变量，即是一个方法。其中附加的参数会将这个函数附加到这个类型上，即相当于为这个类型定义了一个独占的方法。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> {</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Distance 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> {</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Distance Point独占方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> {</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上两个Distance并不会发生冲突，一个是包级别的函数，另一个是类下声明的方法。代码中参数p称为方法的接收器。 </p><p>当调用一个函数时会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数太大需要避免这种默认拷贝时，这时就需要用到指针。对应接收器为指针而不是对象的方法。</p><p>在现实程序中，一般会约定如果某个类中有一个指针作为接收器的方法，那么这个类中的所有方法都必须有一个指针接收器。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型即是这个接口类型的实例。</p><p>接口值由两部分组成，一个具体的类型和那个类型的值，称为接口的动态类型和动态值。接口的零值就是它的类型和值部分都是nil。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言是一种使用在接口值上的操作，语法为<code>x.(T)</code>，其中x表示一个接口类型，T表示一个类型。类型断言用来检查操作对象的动态类型与断言的类型是否匹配。</p><ol><li>如果断言的类型T是一个具体类型，检查x的动态类型与T是否相同<ul><li>如果成功，结果为x的动态值，类型是T</li><li>如果失败，抛出panic</li></ul></li><li>如果T是一个接口类型，检查x的动态类型是否满足T<ul><li>如果成功，结果类型为T，动态类型和值部分与x相同，也就是可以获取的方法集合改变了（通常更大）</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;函数声明包含函数名、形式参数列表、返回值列表（可省略）以及函数体。定义方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="Go" scheme="https://haifuns.com/categories/Go/"/>
    
    
    <category term="Go入门" scheme="https://haifuns.com/tags/Go%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>【Go入门】数据类型</title>
    <link href="https://haifuns.com/2022/11/12/go-datatype/"/>
    <id>https://haifuns.com/2022/11/12/go-datatype/</id>
    <published>2022-11-12T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><ul><li>整数<ul><li>有符号：int 32/64bit、int8 8bit、int16 16bit、int32 32bit、int64 64bit</li><li>无符号：uint 32/64bit、uint8 8bit、uint16 16bit、uint32 32bit、uint64 64bit、uintptr 没有指定具体的bit大小但是足以容纳指针<ul><li>byte（uint8 的别名）</li><li>rune（int32 的别名, 通常用来表示一个 Unicode 码点）</li></ul></li></ul></li><li>浮点数：float32 float64</li><li>字符串：string</li><li>布尔型：bool</li><li>复数：complex64 complex128</li><li>常量<ul><li>iota 常量生成器，用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</li><li>无类型常量，编译器为没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度。</li></ul></li></ul><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包：</p><ul><li>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</li><li>bytes包提供了很多类似strings包功能的函数，但是针对和字符串有着相同结构的[]byte类型。</li><li>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</li><li>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，用于给字符分类。</li></ul><p>特别注意：</p><ul><li>go中默认字符编码格式为UTF-8，由于UTF-8编码对字节长度占用的不确定性，go中的字符串会根据需要占用1-4个字节。英文字符占用1个字节，中文占3个字节。</li><li>算术运算中，%取模符号与被取模数符号一致，-5%3和-5%-3结果都是-2。/除法运算依赖于操作数是否全为整数，5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</li><li>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度。<strong>通常应该优先使用float64类型</strong>，因为float32的有效bit位只有23个，其它的bit位用于指数和符号，当整数大于23bit能表达的范围时，float32的表示将出现误差。</li></ul><h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，因为长度固定在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活。</p><p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值。</p><p>数组定义时长度可以使用“…”省略号，表示数组的长度是根据初始化值的个数来计算。<br>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。<br>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型。slice的语法和数组很像，只是没有固定长度而已。</p><p>slice的底层引用一个数组对象，提供了访问数组子序列（或者全部）元素的功能。</p><p>slice由三个部分构成：指针、长度和容量。指针指向第一个silce元素对应的底层数据元素的地址，但slice的第一个元素不一定就是数组的第一个元素。容量一般是从开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p><p>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。<br>如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。</p><p>e.g.: months[1:13]切片操作将引用全部有效的月份，和months[1:]操作等价；months[:]切片操作则是引用整个数组。</p><p>和数组不同的是，slice之间不能比较，不能使用==操作符来判断两个slice是否含有全部相等元素。唯一的例外是和nil进行比较。</p><p>可以使用内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></tbody></table></figure><p>在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。</p><p>内置的append函数用于向slice追加元素。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map是哈希表的引用，写为map[K]V，其中K和V分别对应key和value。其中K对应的key必须是支持==比较运算符的数据类型。</p><p>使用内置的make函数可以创建一个map：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></tbody></table></figure><p>也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>{</span><br><span class="line">    <span class="string">"alice"</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相当于</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages := make(map[string]int)</span><br><span class="line">ages["alice"] = 31</span><br><span class="line">ages["charlie"] = 34</span><br></pre></td></tr></tbody></table></figure><p>另一种创建空的map的表达式是<code>map[string]int{}</code>。</p><p>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">"bob"</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></tbody></table></figure><p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p><p>和slice一样，map之间也不能进行相等比较，唯一的例外是和nil进行比较。</p><p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。</p><p>有时候需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过可以通过两个步骤绕过这个限制。</p><ul><li>第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。</li><li>第二步，创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。</li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p><p>声明实例：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">    hostname <span class="keyword">string</span></span><br><span class="line">    port     <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr Address</span><br></pre></td></tr></tbody></table></figure><p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</p><p>如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息。</p><h3 id="结构体字面值"><a href="#结构体字面值" class="headerlink" title="结构体字面值"></a>结构体字面值</h3><p>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>{ X, Y <span class="keyword">int</span> }</span><br><span class="line">p := Point{<span class="number">1</span>, <span class="number">2</span>}</span><br></pre></td></tr></tbody></table></figure><p>也可以以成员名字和相应的值来初始化，可以包含部分或全部的成员，e.g.：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := Point{X:<span class="number">1</span>, Y:<span class="number">2</span>}</span><br></pre></td></tr></tbody></table></figure><p>在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。</p><p>两种不同形式的写法不能混合使用。而且，不能企图在外部包中初始化结构体中未导出的成员。</p><p>结构体可以作为函数的参数和返回值，如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。</p><p>如果要在函数内部修改结构体成员的话，用指针传入是必须的，因为<strong>在Go语言中，所有的函数参数都是值拷贝传入</strong>的，函数参数将不再是函数调用时的原始变量。</p><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。相等比较运算符==将比较两个结构体的每个成员。</p><h3 id="结构体嵌入和匿名成员"><a href="#结构体嵌入和匿名成员" class="headerlink" title="结构体嵌入和匿名成员"></a>结构体嵌入和匿名成员</h3><p>Go语言提供结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p><p>匿名成员：只声明一个成员对应的数据类型而不指名成员的名字。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础数据类型&quot;&gt;&lt;a href=&quot;#基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;基础数据类型&quot;&gt;&lt;/a&gt;基础数据类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;整数&lt;ul&gt;
&lt;li&gt;有符号：int 32/64bit、int8 8bit、int16 16bi</summary>
      
    
    
    
    <category term="Go" scheme="https://haifuns.com/categories/Go/"/>
    
    
    <category term="Go入门" scheme="https://haifuns.com/tags/Go%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>【排查经验】线上cpu过高排查</title>
    <link href="https://haifuns.com/2022/09/27/high-cpu/"/>
    <id>https://haifuns.com/2022/09/27/high-cpu/</id>
    <published>2022-09-27T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>top -c</code> 查看所有的进程</li><li>在1的基础上键入<code>P</code>让cpu从高到底排序</li><li>选择2中cpu占比最高的pid进程</li><li><code>top -Hp pid</code> 查看pid对应的线程对cpu的占比</li><li>在4的页面键入<code>P</code>让当前pid的线程cpu占比从高到低排序</li><li>获取第5步骤中的线程占比最高的线程id</li><li>使用<code>printf "%x\n" tid</code>转为16进制（jstack中线程id是16进制）</li><li>打印指定pid下指定tid的jstack日志，<code>jstack pid | grep tid -C 10 --color</code>（打印指定线程位置前后10行）</li><li>根据堆栈信息找到代码块</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;code&gt;top -c&lt;/code&gt; 查看所有的进程&lt;/li&gt;
&lt;li&gt;在1的基础上键入&lt;code&gt;P&lt;/code&gt;让cpu从高到底排序&lt;/li&gt;
&lt;li&gt;选择2中cpu占比最高的pid进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top -Hp pid&lt;/code&gt; </summary>
      
    
    
    
    <category term="排查经验" scheme="https://haifuns.com/categories/%E6%8E%92%E6%9F%A5%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="排查经验" scheme="https://haifuns.com/tags/%E6%8E%92%E6%9F%A5%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（小结）</title>
    <link href="https://haifuns.com/2022/09/11/algorithm-dp/"/>
    <id>https://haifuns.com/2022/09/11/algorithm-dp/</id>
    <published>2022-09-11T08:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么样的暴力递归可以继续优化"><a href="#什么样的暴力递归可以继续优化" class="headerlink" title="什么样的暴力递归可以继续优化"></a>什么样的暴力递归可以继续优化</h1><ol><li>有重复调用一个子问题的解，这类递归可以优化</li><li>如果每一个子问题都是不同解，无法优化也不用优化</li></ol><h1 id="暴力递归和动态规划的关系"><a href="#暴力递归和动态规划的关系" class="headerlink" title="暴力递归和动态规划的关系"></a>暴力递归和动态规划的关系</h1><ol><li>某一个暴力递归有解的重复调用，即可以把这个暴力递归优化为动态规划</li><li>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归</li><li>不是所有的暴力递归都一定对应着动态规划</li></ol><h1 id="暴力递归过程的设计原则（面试）"><a href="#暴力递归过程的设计原则（面试）" class="headerlink" title="暴力递归过程的设计原则（面试）"></a>暴力递归过程的设计原则（面试）</h1><ol><li>每一个可变参数的类型不要比 int 类型更加复杂</li><li>原则1 可以违反，可以让类型突破到一维线性结构，但必须是单一可变参数</li><li>如果原则1 被违反，但是不违反原则2，只需要做到记忆化搜索即可</li><li>可变参数的个数应能少则少</li></ol><h1 id="常见的4种尝试模型"><a href="#常见的4种尝试模型" class="headerlink" title="常见的4种尝试模型"></a>常见的4种尝试模型</h1><ol><li>从左往右的尝试模型</li><li>范围上的尝试模型</li><li>多样本位置全对应的尝试模型</li><li>寻找业务限制的尝试模型</li></ol><h1 id="如何找到某个问题的动态规划方式"><a href="#如何找到某个问题的动态规划方式" class="headerlink" title="如何找到某个问题的动态规划方式"></a>如何找到某个问题的动态规划方式</h1><ol><li><strong>设计暴力递归：重要原则+4种常见尝试模型（重要）</strong></li><li>分析有没有重复解：套路解决</li><li>用记忆化搜索：用严格表结构实现动态规划，套路解决</li><li>看看能够继续优化：套路解决</li></ol><h1 id="暴力递归到动态规划的套路"><a href="#暴力递归到动态规划的套路" class="headerlink" title="暴力递归到动态规划的套路"></a>暴力递归到动态规划的套路</h1><ol><li>已经有个了一个不违反原则的暴力递归，并且存在解的重复调用</li><li>找到哪些参数的变化会影响返回值，对每一个列出变化范围</li><li>参数间的所有组合数量意味着表的大小</li><li>总能改出记忆化搜索的方法，也就是傻缓存，非常容易得到</li><li>规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解</li><li>对于有枚举行为的决策过程，进一步优化</li></ol><h1 id="动态规划的进一步优化"><a href="#动态规划的进一步优化" class="headerlink" title="动态规划的进一步优化"></a>动态规划的进一步优化</h1><ol><li>空间压缩</li><li>状态化简</li><li>四边形不等式</li><li>其他优化技巧</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么样的暴力递归可以继续优化&quot;&gt;&lt;a href=&quot;#什么样的暴力递归可以继续优化&quot; class=&quot;headerlink&quot; title=&quot;什么样的暴力递归可以继续优化&quot;&gt;&lt;/a&gt;什么样的暴力递归可以继续优化&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;有重复调用一个子问题的解，这类递</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（六）</title>
    <link href="https://haifuns.com/2022/09/11/algorithm-dp6/"/>
    <id>https://haifuns.com/2022/09/11/algorithm-dp6/</id>
    <published>2022-09-11T08:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-拆分数组"><a href="#1-拆分数组" class="headerlink" title="1.拆分数组"></a>1.拆分数组</h1><p>给定一个正整数组 arr，将 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近。<br>返回最近情况下，较小集合的累计和。</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) {</span><br><span class="line">        sum += num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, sum / <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从arr[i..]自由选择，累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 还有数，arr[i]这个数</span></span><br><span class="line">        <span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line">        <span class="keyword">int</span> p1 = process(arr, index + <span class="number">1</span>, rest);</span><br><span class="line">        <span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt;= rest) {</span><br><span class="line">            p2 = arr[index] + process(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) {</span><br><span class="line">        sum += num;</span><br><span class="line">    }</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][sum + <span class="number">1</span>]; <span class="comment">// N * (sum/2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) { <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= sum; rest++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line">            <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= rest) {</span><br><span class="line">                p2 = arr[i] + dp[i + <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">            }</span><br><span class="line">            dp[i][rest] = Math.max(p1, p2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][sum];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-拆分数组2"><a href="#2-拆分数组2" class="headerlink" title="2.拆分数组2"></a>2.拆分数组2</h1><p>给定一个正数数组 arr，把 arr 中的所有数分为两个集合。</p><p>要求：</p><ul><li>如果 arr 长度为偶数，两个集合包含的个数要一样多</li><li>如果 arr 长度为奇数，两个集合包含的个数必须要差一个</li><li>两个集合的累计和尽可能接近</li></ul><p>返回最接近情况下，较小集合的累加和。</p><h2 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) {</span><br><span class="line">        sum += num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.max(process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>), process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span> + <span class="number">1</span>, sum / <span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从arr[i..]自由选择，挑选picks个数，累加和&lt;=rest, 返回离rest最近的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> picks, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length) {</span><br><span class="line">        <span class="keyword">return</span> picks == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>; <span class="comment">// -1标记无效</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 不使用arr[i]这个数</span></span><br><span class="line">        <span class="keyword">int</span> p1 = process(arr, i + <span class="number">1</span>, picks, rest);</span><br><span class="line">        <span class="comment">// 要使用arr[i]这个数</span></span><br><span class="line">        <span class="keyword">int</span> p2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= rest) {</span><br><span class="line">            next = process(arr, i + <span class="number">1</span>, picks - <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (next != -<span class="number">1</span>) {</span><br><span class="line">            p2 = arr[i] + next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) {</span><br><span class="line">        sum += num;</span><br><span class="line">    }</span><br><span class="line">    sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> M = (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][M + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= sum; k++) {</span><br><span class="line">                dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= sum; rest++) {</span><br><span class="line">        dp[N][<span class="number">0</span>][rest] = <span class="number">0</span>; <span class="comment">// i=N picks=0，有效</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> picks = <span class="number">0</span>; picks &lt;= M; picks++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= sum; rest++) {</span><br><span class="line">                <span class="comment">// 不要arr[i]这个数</span></span><br><span class="line">                <span class="keyword">int</span> p1 = dp[i + <span class="number">1</span>][picks][rest];</span><br><span class="line">                <span class="comment">// 要使用arr[i]这个数</span></span><br><span class="line">                <span class="keyword">int</span> p2 = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> next = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (picks - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt;= rest) {</span><br><span class="line">                    next = dp[i + <span class="number">1</span>][picks - <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (next != -<span class="number">1</span>) {</span><br><span class="line">                    p2 = arr[i] + next;</span><br><span class="line">                }</span><br><span class="line">                dp[i][picks][rest] = Math.max(p1, p2);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr.length % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum], dp[<span class="number">0</span>][(arr.length / <span class="number">2</span>) + <span class="number">1</span>][sum]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-N皇后问题（无法改动态规划）"><a href="#3-N皇后问题（无法改动态规划）" class="headerlink" title="3.N皇后问题（无法改动态规划）"></a>3.N皇后问题（无法改动态规划）</h1><p>N皇后问题：在 N * N 的棋盘上要摆 N 个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。</p><p>给定一个整数 N，返回 N 皇后问题有多少种摆法。</p><p>N=1，返回1<br>N=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0<br>N=8，返回92</p><h2 id="暴力递归-2"><a href="#暴力递归-2" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">return</span> process(<span class="number">0</span>, record, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前来到i行，一共是0~N-1行</span></span><br><span class="line"><span class="comment">// 在i行上放皇后，所有列都尝试</span></span><br><span class="line"><span class="comment">// 必须要保证跟之前所有的皇后不打架</span></span><br><span class="line"><span class="comment">// record[x] = y 表示第x行的皇后，放在了y列上</span></span><br><span class="line"><span class="comment">// 返回：不关心i以上发生了什么，i.. 后续有多少合法的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == n) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// i行的皇后，放哪一列呢？j列，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">        <span class="keyword">if</span> (isValid(record, i, j)) {</span><br><span class="line">            record[i] = j;</span><br><span class="line">            res += process(i + <span class="number">1</span>, record, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="comment">// 0..i-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) {</span><br><span class="line">        <span class="comment">// 共列或者共斜线</span></span><br><span class="line">        <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力递归（位运算，常数时间优化）"><a href="#暴力递归（位运算，常数时间优化）" class="headerlink" title="暴力递归（位运算，常数时间优化）"></a>暴力递归（位运算，常数时间优化）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要超过32皇后问题，越界</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果你是13皇后问题，limit 最右13个1，其他都是0</span></span><br><span class="line">    <span class="keyword">int</span> limit = n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> process(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit : 二进制右侧N个1</span></span><br><span class="line"><span class="comment">// 之前皇后的列影响：colLim</span></span><br><span class="line"><span class="comment">// 之前皇后的左下对角线影响：leftDiaLim</span></span><br><span class="line"><span class="comment">// 之前皇后的右下对角线影响：rightDiaLim</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">int</span> colLim, <span class="keyword">int</span> leftDiaLim, <span class="keyword">int</span> rightDiaLim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (colLim == limit) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// pos中所有是1的位置，是可以去尝试皇后的位置</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// pos中最右侧的1</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        res += process(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-拆分数组&quot;&gt;&lt;a href=&quot;#1-拆分数组&quot; class=&quot;headerlink&quot; title=&quot;1.拆分数组&quot;&gt;&lt;/a&gt;1.拆分数组&lt;/h1&gt;&lt;p&gt;给定一个正整数组 arr，将 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近。&lt;br&gt;返回最近情</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（五）</title>
    <link href="https://haifuns.com/2022/09/07/algorithm-dp5/"/>
    <id>https://haifuns.com/2022/09/07/algorithm-dp5/</id>
    <published>2022-09-07T15:59:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-打死怪兽的概率"><a href="#1-打死怪兽的概率" class="headerlink" title="1.打死怪兽的概率"></a>1.打死怪兽的概率</h1><p>给定 3 个参数，N，M，K，表示怪兽有 N 滴血，英雄每攻击一次，怪兽会在 0~M 范围等概率流失血量。<br>在 K 次打击后，英雄把怪兽砍死的概率是多少？</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> all = (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, K); <span class="comment">// 总的可能性，(M+1)^K</span></span><br><span class="line">    <span class="keyword">long</span> kill = process(K, M, N);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) kill / (<span class="keyword">double</span>) all);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怪兽还剩hp点血，每次的伤害在[0~M]范围上，还有times次可以砍，返回砍死的情况数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> times, <span class="keyword">int</span> M, <span class="keyword">int</span> hp)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (times == <span class="number">0</span>) { <span class="comment">// 没有次数了</span></span><br><span class="line">        <span class="keyword">return</span> hp &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 血量小于0成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>) { <span class="comment">// 没血了</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, times); <span class="comment">// 剩下的所有情况都能成功，(M+1)^times</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++) { <span class="comment">// 尝试掉 0 ~ M 滴血，每种情况概率</span></span><br><span class="line">        ways += process(times - <span class="number">1</span>, M, hp - i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> all = (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[K + <span class="number">1</span>][N + <span class="number">1</span>]; <span class="comment">// 剩余步数 * 剩余血量</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> times = <span class="number">1</span>; times &lt;= K; times++) { <span class="comment">// 从上往下</span></span><br><span class="line">        dp[times][<span class="number">0</span>] = (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, times); <span class="comment">// 已经没血了，剩下的所有步数都能成功</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hp = <span class="number">1</span>; hp &lt;= N; hp++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="keyword">long</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++) { <span class="comment">// 枚举掉血数</span></span><br><span class="line">                <span class="keyword">if</span> (hp - i &gt;= <span class="number">0</span>) { <span class="comment">// 还有血量</span></span><br><span class="line">                    ways += dp[times - <span class="number">1</span>][hp - i]; <span class="comment">// 位置转移，上一行</span></span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 没血了</span></span><br><span class="line">                    ways += (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, times - <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dp[times][hp] = ways;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> kill = dp[K][N];</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) kill / (<span class="keyword">double</span>) all);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（斜率优化）"><a href="#动态规划（斜率优化）" class="headerlink" title="动态规划（斜率优化）"></a>动态规划（斜率优化）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> all = (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> times = <span class="number">1</span>; times &lt;= K; times++) {</span><br><span class="line">        dp[times][<span class="number">0</span>] = (<span class="keyword">long</span>) Math.pow(M + <span class="number">1</span>, times);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hp = <span class="number">1</span>; hp &lt;= N; hp++) {</span><br><span class="line">            <span class="comment">// 画图观察，当前位置值 = dp[times-1][hp-m..hp]</span></span><br><span class="line">            <span class="comment">// = dp[times-1][hp-1-m..hp] - dp[times-1][hp-1-m] + dp[times-1][hp]</span></span><br><span class="line">            <span class="comment">// = dp[times][hp-1] + dp[times-1][hp] - dp[times-1][hp-1-m]</span></span><br><span class="line">            <span class="comment">// = 左边 + 上边 - dp[times-1][hp-1-m]</span></span><br><span class="line">            dp[times][hp] = dp[times][hp - <span class="number">1</span>] + dp[times - <span class="number">1</span>][hp];</span><br><span class="line">            <span class="keyword">if</span> (hp - <span class="number">1</span> - M &gt;= <span class="number">0</span>) { <span class="comment">// 不越界</span></span><br><span class="line">                <span class="comment">// 减去多的格子</span></span><br><span class="line">                dp[times][hp] -= dp[times - <span class="number">1</span>][hp - <span class="number">1</span> - M];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 越界了，要减去的格子概率等于上一行0位置</span></span><br><span class="line">                dp[times][hp] -= Math.pow(M + <span class="number">1</span>, times - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> kill = dp[K][N];</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) kill / (<span class="keyword">double</span>) all);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-零钱兑换问题4-面值无限张-最少货币张数"><a href="#2-零钱兑换问题4-面值无限张-最少货币张数" class="headerlink" title="2.零钱兑换问题4-面值无限张-最少货币张数"></a>2.零钱兑换问题4-面值无限张-最少货币张数</h1><p>面值数组 arr，其中都是正数且没有重复，每个值都认为是一种面值且张数是无限的。<br>给定一个正数 aim，返回能组成 aim 的最少货币张数。</p><h2 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCoins</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) { <span class="comment">// 没钱了</span></span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE; <span class="comment">// 0张</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) { <span class="comment">// 尝试使用 0 ~ 钱数/面值 张</span></span><br><span class="line">            <span class="keyword">int</span> next = process(arr, index + <span class="number">1</span>, rest - zhang * arr[index]);</span><br><span class="line">            <span class="keyword">if</span> (next != Integer.MAX_VALUE) {</span><br><span class="line">                ans = Math.min(ans, zhang + next); <span class="comment">// 尝试成功了</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (aim == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>]; <span class="comment">// 面值 * 剩余钱数</span></span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) {</span><br><span class="line">        dp[N][j] = Integer.MAX_VALUE; <span class="comment">// 越界</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) { <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) {</span><br><span class="line">                <span class="keyword">int</span> next = dp[index + <span class="number">1</span>][rest - zhang * arr[index]];</span><br><span class="line">                <span class="keyword">if</span> (next != Integer.MAX_VALUE) {</span><br><span class="line">                    ans = Math.min(ans, zhang + next);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dp[index][rest] = ans;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（斜率优化）-1"><a href="#动态规划（斜率优化）-1" class="headerlink" title="动态规划（斜率优化）"></a>动态规划（斜率优化）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (aim == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) {</span><br><span class="line">        dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) {</span><br><span class="line">            <span class="comment">// 当前值 = min(dp[index][rest - arr[index]]+1, 下边值)</span></span><br><span class="line">            <span class="comment">// dp[index][rest - arr[index]]+1，用了1张当前面值</span></span><br><span class="line">            <span class="comment">// 下面值，用了0张当前面值</span></span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> &amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) {</span><br><span class="line">                dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-拆分整数"><a href="#3-拆分整数" class="headerlink" title="3.拆分整数"></a>3.拆分整数</h1><p>给定一个正整数 n，将其拆分为 1 个或多个正整数的和，要求拆开的数后面的不能比前面的数小。返回最多有多少种拆分方式。</p><h2 id="暴力递归-2"><a href="#暴力递归-2" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个拆出来的数是pre，还剩rest需要去拆，返回拆解的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pre &gt; rest) { <span class="comment">// 上一个拆出来的数不能比剩下的大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> first = pre; first &lt;= rest; first++) { <span class="comment">// 不能比pre小，pre..rest</span></span><br><span class="line">        ways += process(first, rest - first);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt;= n; pre++) { <span class="comment">// base case</span></span><br><span class="line">        dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) { <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = pre + <span class="number">1</span>; rest &lt;= n; rest++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> first = pre; first &lt;= rest; first++) { <span class="comment">// pre..rest</span></span><br><span class="line">                ways += dp[first][rest - first];</span><br><span class="line">            }</span><br><span class="line">            dp[pre][rest] = ways;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（斜率优化）-2"><a href="#动态规划（斜率优化）-2" class="headerlink" title="动态规划（斜率优化）"></a>动态规划（斜率优化）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt;= n; pre++) {</span><br><span class="line">            dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pre = n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> rest = pre + <span class="number">1</span>; rest &lt;= n; rest++) {</span><br><span class="line">                <span class="comment">// 画图观察，当前位置 = dp[pre + 1][rest] 下边 +  dp[pre][rest - pre]</span></span><br><span class="line">                dp[pre][rest] = dp[pre + <span class="number">1</span>][rest];</span><br><span class="line">                dp[pre][rest] += dp[pre][rest - pre];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-打死怪兽的概率&quot;&gt;&lt;a href=&quot;#1-打死怪兽的概率&quot; class=&quot;headerlink&quot; title=&quot;1.打死怪兽的概率&quot;&gt;&lt;/a&gt;1.打死怪兽的概率&lt;/h1&gt;&lt;p&gt;给定 3 个参数，N，M，K，表示怪兽有 N 滴血，英雄每攻击一次，怪兽会在 0~M</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（四）</title>
    <link href="https://haifuns.com/2022/09/06/algorithm-dp4/"/>
    <id>https://haifuns.com/2022/09/06/algorithm-dp4/</id>
    <published>2022-09-06T15:59:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-最小距离累加和问题"><a href="#1-最小距离累加和问题" class="headerlink" title="1.最小距离累加和问题"></a>1.最小距离累加和问题</h1><p>给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下角。<br>中途只能向下或者向右走，沿途的数字都累加就是距离累加和。返回最小距离累加和。</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">return</span> process(m, row - <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt; m.length || col &lt; <span class="number">0</span> || col &gt; m[<span class="number">0</span>].length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row != <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> process(m, row - <span class="number">1</span>, col) + m[row][col];  <span class="comment">// 第0列，上边值 + 当前值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> process(m, row, col - <span class="number">1</span>) + m[row][col];  <span class="comment">// 第0行，左边值 + 当前值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = process(m, row, col - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> up = process(m, row - <span class="number">1</span>, col);</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, up) + m[row][col];  <span class="comment">// min(上边值, 左边值) + 当前值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>]; <span class="comment">// 第0列，上边值 + 当其值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j]; <span class="comment">// 第0行，左边值 + 当其值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) { <span class="comment">// 从上往下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) { <span class="comment">// 从左到右</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j]; <span class="comment">// min(上边值, 左边值) + 当其值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>]; <span class="comment">// 右下角</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（空间压缩优化）"><a href="#动态规划（空间压缩优化）" class="headerlink" title="动态规划（空间压缩优化）"></a>动态规划（空间压缩优化）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[col]; <span class="comment">// 列，也可以用行计算，推算过程同理，行列谁短用谁</span></span><br><span class="line">    dp[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) {</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + m[<span class="number">0</span>][j]; <span class="comment">// 初始第0列，左边值 + 当前值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) { <span class="comment">// 从上往下</span></span><br><span class="line">        dp[<span class="number">0</span>] += m[i][<span class="number">0</span>]; <span class="comment">// 当前行第一个值，上边 + 当前值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="comment">// dp[j - 1] -&gt; 当前位置左边值，更新过了</span></span><br><span class="line">            <span class="comment">// dp[j] -&gt; 当前位置上边值，没更新还是上一行的值</span></span><br><span class="line">            dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + m[i][j]; <span class="comment">// min(上边值, 左边值) + 当其值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[col - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-零钱兑换问题"><a href="#2-零钱兑换问题" class="headerlink" title="2.零钱兑换问题"></a>2.零钱兑换问题</h1><p>货币数组 arr，其中都是正数，每个值都认为是一张不同的货币，即使值相同也认为是不同的。<br>给定一个正数 aim，返回能组成 aim 的方法数。</p><p>例如：arr = {1,1,1}，aim = 2<br>第 0 个和第 1 个、第 1 个和第 2 个、第 0 个和第 2 个都能组成 2，返回 3。</p><h2 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinWays</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) { <span class="comment">// 没钱了</span></span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> process(arr, index + <span class="number">1</span>, rest) + process(arr, index + <span class="number">1</span>, rest - arr[index]); <span class="comment">// 用当前位置钱，剩余钱减少 + 不用当前位置钱</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归改动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (aim == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>]; <span class="comment">// index 0~N，aim 0~aim</span></span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) { <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) { <span class="comment">// 从左往右</span></span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest] + (rest - arr[index] &gt;= <span class="number">0</span> ? dp[index + <span class="number">1</span>][rest - arr[index]] : <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-零钱兑换问题2-面值无限张"><a href="#3-零钱兑换问题2-面值无限张" class="headerlink" title="3.零钱兑换问题2-面值无限张"></a>3.零钱兑换问题2-面值无限张</h1><p>面值数组 arr，其中都是正数且没有重复，每个值都认为是一种面值且张数是无限的。<br>给定一个正数 aim，返回能组成 aim 的方法数。</p><p>例如：arr = {1,2}，aim = 4<br>1+1+1+1、1+1+2、2+2，返回 3。</p><h2 id="暴力递归-2"><a href="#暴力递归-2" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinsWay</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) { <span class="comment">// 没钱了</span></span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) { <span class="comment">// 使用 0 ~ 钱数/面值 张</span></span><br><span class="line">        ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) { <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) { <span class="comment">// 从左往右</span></span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) {</span><br><span class="line">                ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])]; <span class="comment">// 枚举每张面值</span></span><br><span class="line">            }</span><br><span class="line">            dp[index][rest] = ways;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（优化枚举）"><a href="#动态规划（优化枚举）" class="headerlink" title="动态规划（优化枚举）"></a>动态规划（优化枚举）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) {</span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 画出二维表观察，优化遍历枚举，当前位置遍历枚举 = 左边位置 + 下边位置</span></span><br><span class="line">                dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-零钱兑换问题3-面值有限张"><a href="#4-零钱兑换问题3-面值有限张" class="headerlink" title="4.零钱兑换问题3-面值有限张"></a>4.零钱兑换问题3-面值有限张</h1><p>货币数组 arr，其中都是正数，每个值都认为是一种面值。值相同的货币没有任何不同。<br>给定一个正数 aim，返回能组成 aim 的方法数。</p><p>例如：arr = {1,2,1,1,2,1,2}，aim = 4<br>1+1+1+1、1+1+2、2+2，返回 3。</p><h2 id="暴力递归-3"><a href="#暴力递归-3" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] coins; <span class="comment">// 面值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] zhangs; <span class="comment">// 张数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span>[] z)</span> </span>{</span><br><span class="line">        coins = c;</span><br><span class="line">        zhangs = z;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">getInfo</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) {</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(value)) {</span><br><span class="line">            counts.put(value, <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            counts.put(value, counts.get(value) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = counts.size();</span><br><span class="line">    <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] zhangs = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) {</span><br><span class="line">        coins[index] = entry.getKey();</span><br><span class="line">        zhangs[index++] = entry.getValue();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(coins, zhangs);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinsWay</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Info info = getInfo(arr);</span><br><span class="line">    <span class="keyword">return</span> process(info.coins, info.zhangs, <span class="number">0</span>, aim);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span>[] zhangs, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == coins.length) {</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) {     <span class="comment">// 限制张数+余额，可以使用多少张</span></span><br><span class="line">        ways += process(coins, zhangs, index + <span class="number">1</span>, rest - (zhang * coins[index]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Info info = getInfo(arr);</span><br><span class="line">    <span class="keyword">int</span>[] coins = info.coins;</span><br><span class="line">    <span class="keyword">int</span>[] zhangs = info.zhangs;</span><br><span class="line">    <span class="keyword">int</span> N = coins.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) {</span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) {</span><br><span class="line">                ways += dp[index + <span class="number">1</span>][rest - (zhang * coins[index])];</span><br><span class="line">            }</span><br><span class="line">            dp[index][rest] = ways;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划（优化枚举）-1"><a href="#动态规划（优化枚举）-1" class="headerlink" title="动态规划（优化枚举）"></a>动态规划（优化枚举）</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Info info = getInfo(arr);</span><br><span class="line">    <span class="keyword">int</span>[] coins = info.coins;</span><br><span class="line">    <span class="keyword">int</span>[] zhangs = info.zhangs;</span><br><span class="line">    <span class="keyword">int</span> N = coins.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) {</span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 画出二维表观察，优化枚举，面值无限张时 当前位置枚举 = 左边位置 + 下边位置</span></span><br><span class="line">                dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 用超了张数</span></span><br><span class="line">            <span class="keyword">if</span> (rest - coins[index] * (zhangs[index] + <span class="number">1</span>) &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 减去多用的张数位置，下一行，列 = 余额 - 面值 * (实际张数 + 1)</span></span><br><span class="line">                dp[index][rest] -= dp[index + <span class="number">1</span>][rest - coins[index] * (zhangs[index] + <span class="number">1</span>)];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-区域内随机移动概率问题"><a href="#5-区域内随机移动概率问题" class="headerlink" title="5.区域内随机移动概率问题"></a>5.区域内随机移动概率问题</h1><p>给定 5 个参数，N，M，row，col，k。<br>表示在 N*M 区域上，醉汉 Bob 初始会在 (row,col) 位置上，一共会迈出 k 步，每一步等概率向上下左右四个方向走一个单位。<br>任何时候 Bob 只要离开 N*M 的区域就会直接死亡。<br>返回 k 步后，Bob 还在 N*M 区域的概率。</p><h2 id="暴力递归-4"><a href="#暴力递归-4" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">livePosibility</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) process(row, col, k, N, M) / Math.pow(<span class="number">4</span>, k); <span class="comment">// 4^k</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前在row，col位置，还有rest步要走，走完了如果还在棋盘中就获得1个生存点，返回总的生存点数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> rest, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == N || col &lt; <span class="number">0</span> || col == M) { <span class="comment">// 越界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 还在棋盘中，没有剩余步数</span></span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 还在棋盘中，往上下左右走</span></span><br><span class="line">    <span class="keyword">long</span> up = process(row - <span class="number">1</span>, col, rest - <span class="number">1</span>, N, M);</span><br><span class="line">    <span class="keyword">long</span> down = process(row + <span class="number">1</span>, col, rest - <span class="number">1</span>, N, M);</span><br><span class="line">    <span class="keyword">long</span> left = process(row, col - <span class="number">1</span>, rest - <span class="number">1</span>, N, M);</span><br><span class="line">    <span class="keyword">long</span> right = process(row, col + <span class="number">1</span>, rest - <span class="number">1</span>, N, M);</span><br><span class="line">    <span class="keyword">return</span> up + down + left + right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">livePosibility</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> k, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[N][M][k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) {</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 三维，第0层，没有步数了</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= k; rest++) { <span class="comment">// 层数，从上往下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; r++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; M; c++) {</span><br><span class="line">                dp[r][c][rest] = pick(dp, N, M, r - <span class="number">1</span>, c, rest - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][rest] += pick(dp, N, M, r + <span class="number">1</span>, c, rest - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][rest] += pick(dp, N, M, r, c - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][rest] += pick(dp, N, M, r, c + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) dp[row][col][k] / Math.pow(<span class="number">4</span>, k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pick</span><span class="params">(<span class="keyword">long</span>[][][] dp, <span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r == N || c &lt; <span class="number">0</span> || c == M) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[r][c][rest];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-最小距离累加和问题&quot;&gt;&lt;a href=&quot;#1-最小距离累加和问题&quot; class=&quot;headerlink&quot; title=&quot;1.最小距离累加和问题&quot;&gt;&lt;/a&gt;1.最小距离累加和问题&lt;/h1&gt;&lt;p&gt;给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（三）</title>
    <link href="https://haifuns.com/2022/09/05/algorithm-dp3/"/>
    <id>https://haifuns.com/2022/09/05/algorithm-dp3/</id>
    <published>2022-09-05T15:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-最长回文子序列（LeetCode-516-）"><a href="#1-最长回文子序列（LeetCode-516-）" class="headerlink" title="1.最长回文子序列（LeetCode 516.）"></a>1.最长回文子序列（LeetCode 516.）</h1><p>给定一个字符串 str，返回这个字符串的最长回文子序列长度。</p><p>例如：str = “a12b3c43defghi1kpm”，最长回文子序列是 “1234321” 或 “123c321”，返回长度7。</p><blockquote><p>一般来说，字符串的子序列不需要字符连续，子串需要字符连续。</p></blockquote><p>此题可以利用上一篇的最长公共子序列，str 和 str 逆序的最长公共子序列就是 str 的最长回文子序列。可看上一篇回忆，这里不做实现了。</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lpsl</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">return</span> f(str, <span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[L..R]最长回文子序列长度返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L == R) { <span class="comment">// 剩一个字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (L == R - <span class="number">1</span>) { <span class="comment">// 剩两个字符</span></span><br><span class="line">        <span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 可能1、不以L开头也不以R结尾</span></span><br><span class="line">    <span class="keyword">int</span> p1 = f(str, L + <span class="number">1</span>, R - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可能2、以L开头不以R结尾</span></span><br><span class="line">    <span class="keyword">int</span> p2 = f(str, L, R - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可能3、不以L开头以R结尾</span></span><br><span class="line">    <span class="keyword">int</span> p3 = f(str, L + <span class="number">1</span>, R);</span><br><span class="line">    <span class="comment">// 可能4、以L开头以R结尾</span></span><br><span class="line">    <span class="keyword">int</span> p4 = str[L] != str[R] ? <span class="number">0</span> : (<span class="number">2</span> + f(str, L + <span class="number">1</span>, R - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lpsl</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="comment">// L 0..N-1</span></span><br><span class="line">    <span class="comment">// R 0..N-1</span></span><br><span class="line">    <span class="comment">// L &gt; R 无效，只有表格右上部分有效</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) { <span class="comment">// base case</span></span><br><span class="line">        dp[i][i] = <span class="number">1</span>; <span class="comment">// 最长对角线</span></span><br><span class="line">        dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>; <span class="comment">// 最长-1对角线</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个格子计算依赖左、下、左下三个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L = N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) { <span class="comment">// 列，从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> R = L + <span class="number">2</span>; R &lt; N; R++) { <span class="comment">// 行，从左往右</span></span><br><span class="line">            dp[L][R] = Math.max(dp[L][R - <span class="number">1</span>], dp[L + <span class="number">1</span>][R]); <span class="comment">// 可能2、可能3</span></span><br><span class="line">            <span class="keyword">if</span> (str[L] == str[R]) {</span><br><span class="line">                dp[L][R] = Math.max(dp[L][R], <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>]); <span class="comment">// 可能4</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-象棋固定步数移动到终点"><a href="#2-象棋固定步数移动到终点" class="headerlink" title="2.象棋固定步数移动到终点"></a>2.象棋固定步数移动到终点</h1><p>想像一个象棋的棋盘，将整个棋盘放入第一象限，棋盘的左下角是(0,0)位置，那么整个棋盘就是横坐标上 9 条线、纵坐标上 10 条线的区域。<br>给定三个参数 x、y、k，返回“马”从(0,0)位置出发，必须走 k 步，最后落在(x,y)上的方法数有多少种。</p><h2 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10 * 9</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(<span class="number">0</span>, <span class="number">0</span>, k, a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前来到的位置是（x,y）</span></span><br><span class="line"><span class="comment">// 还剩下rest步需要跳</span></span><br><span class="line"><span class="comment">// 跳完rest步，正好跳到a，b的方法数是多少？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> rest, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) { <span class="comment">// 越界检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> (x == a &amp;&amp; y == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 每个点都有8种移动方式</span></span><br><span class="line">    <span class="keyword">int</span> ways = process(x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    ways += process(x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">9</span>][k + <span class="number">1</span>];</span><br><span class="line">    dp[a][b][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化第0层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= k; rest++) { <span class="comment">// 按层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">9</span>; y++) {</span><br><span class="line">                <span class="keyword">int</span> ways = pick(dp, x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">                ways += pick(dp, x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">                dp[x][y][rest] = ways;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span>[][][] dp, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[x][y][rest];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-洗咖啡杯问题（京东）"><a href="#3-洗咖啡杯问题（京东）" class="headerlink" title="3.洗咖啡杯问题（京东）"></a>3.洗咖啡杯问题（京东）</h1><p>数组 arr 代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。<br>现在有 n 个人需要喝咖啡，认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。<br>每个人喝完之后咖啡杯可以选择洗或者自然挥发干净。只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。<br>洗杯子的机器洗完一个杯子时间为 a，任何一个杯子自然挥发干净的时间为 b。<br>假设时间点从 0 开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。</p><h2 id="暴力递归-2"><a href="#暴力递归-2" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span>[] drink = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">return</span> forceMake(arr, times, <span class="number">0</span>, drink, n, a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个人暴力尝试用每一个咖啡机给自己做咖啡</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forceMake</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] times, <span class="keyword">int</span> kth, <span class="keyword">int</span>[] drink, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (kth == n) { <span class="comment">// 所有咖啡制作完成，判断清洗杯子时间</span></span><br><span class="line">        <span class="keyword">int</span>[] drinkSorted = Arrays.copyOf(drink, kth); <span class="comment">// 每杯咖啡制作完成时间</span></span><br><span class="line">        Arrays.sort(drinkSorted);</span><br><span class="line">        <span class="keyword">return</span> forceWash(drinkSorted, a, b, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> time = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) { <span class="comment">// 每个咖啡机</span></span><br><span class="line">        <span class="keyword">int</span> work = arr[i]; <span class="comment">// 咖啡机需要的时间</span></span><br><span class="line">        <span class="keyword">int</span> pre = times[i]; <span class="comment">// 上一杯咖啡结束时间</span></span><br><span class="line">        drink[kth] = pre + work; <span class="comment">// 当前杯咖啡制作完成时间</span></span><br><span class="line">        times[i] = pre + work; <span class="comment">// 咖啡机排队时间</span></span><br><span class="line">        time = Math.min(time, forceMake(arr, times, kth + <span class="number">1</span>, drink, n, a, b)); <span class="comment">// 下一杯咖啡所有可能..</span></span><br><span class="line">        drink[kth] = <span class="number">0</span>;</span><br><span class="line">        times[i] = pre;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forceWash</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> index, <span class="keyword">int</span> washLine, <span class="keyword">int</span> time)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == drinks.length) {</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 选择一：当前index号咖啡杯，选择用洗咖啡机刷干净</span></span><br><span class="line">    <span class="keyword">int</span> wash = Math.max(drinks[index], washLine) + a;</span><br><span class="line">    <span class="keyword">int</span> ans1 = forceWash(drinks, a, b, index + <span class="number">1</span>, wash, Math.max(wash, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择二：当前index号咖啡杯，选择自然挥发</span></span><br><span class="line">    <span class="keyword">int</span> dry = drinks[index] + b;</span><br><span class="line">    <span class="keyword">int</span> ans2 = forceWash(drinks, a, b, index + <span class="number">1</span>, washLine, Math.max(dry, time));</span><br><span class="line">    <span class="keyword">return</span> Math.min(ans1, ans2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="贪心-优良尝试优化"><a href="#贪心-优良尝试优化" class="headerlink" title="贪心+优良尝试优化"></a>贪心+优良尝试优化</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> timePoint; <span class="comment">// 时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> workTime; <span class="comment">// 制作咖啡需要的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">        timePoint = t;</span><br><span class="line">        workTime = w;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MachineComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Machine</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Machine o1, Machine o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优良一点的暴力尝试的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    PriorityQueue&lt;Machine&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Machine&gt;(<span class="keyword">new</span> MachineComparator());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        heap.add(<span class="keyword">new</span> Machine(<span class="number">0</span>, arr[i]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] drinks = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 每个人喝完咖啡时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        Machine cur = heap.poll();</span><br><span class="line">        cur.timePoint += cur.workTime;</span><br><span class="line">        drinks[i] = cur.timePoint;</span><br><span class="line">        heap.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bestTime(drinks, a, b, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// drinks 所有杯子可以开始洗的时间</span></span><br><span class="line"><span class="comment">// wash 单杯洗干净的时间（串行）</span></span><br><span class="line"><span class="comment">// air 挥发干净的时间(并行)</span></span><br><span class="line"><span class="comment">// free 洗的机器什么时候可用</span></span><br><span class="line"><span class="comment">// drinks[index..] 都变干净，最早的结束时间（返回）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestTime</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> wash, <span class="keyword">int</span> air, <span class="keyword">int</span> index, <span class="keyword">int</span> free)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == drinks.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// index号杯子 决定洗</span></span><br><span class="line">    <span class="keyword">int</span> selfClean1 = Math.max(drinks[index], free) + wash;</span><br><span class="line">    <span class="comment">// 剩余杯子干净时间</span></span><br><span class="line">    <span class="keyword">int</span> restClean1 = bestTime(drinks, wash, air, index + <span class="number">1</span>, selfClean1);</span><br><span class="line">    <span class="keyword">int</span> p1 = Math.max(selfClean1, restClean1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index号杯子 决定挥发</span></span><br><span class="line">    <span class="keyword">int</span> selfClean2 = drinks[index] + air;</span><br><span class="line">    <span class="comment">// 剩余杯子干净时间</span></span><br><span class="line">    <span class="keyword">int</span> restClean2 = bestTime(drinks, wash, air, index + <span class="number">1</span>, free);</span><br><span class="line">    <span class="keyword">int</span> p2 = Math.max(selfClean2, restClean2);</span><br><span class="line">    <span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> timePoint; <span class="comment">// 时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> workTime; <span class="comment">// 制作咖啡需要的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Machine</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">        timePoint = t;</span><br><span class="line">        workTime = w;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MachineComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Machine</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Machine o1, Machine o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪心+优良尝试改动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    PriorityQueue&lt;Machine&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Machine&gt;(<span class="keyword">new</span> MachineComparator());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        heap.add(<span class="keyword">new</span> Machine(<span class="number">0</span>, arr[i]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] drinks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        Machine cur = heap.poll();</span><br><span class="line">        cur.timePoint += cur.workTime;</span><br><span class="line">        drinks[i] = cur.timePoint;</span><br><span class="line">        heap.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bestTimeDp(drinks, a, b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestTimeDp</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> wash, <span class="keyword">int</span> air)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = drinks.length;</span><br><span class="line">    <span class="keyword">int</span> maxFree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; drinks.length; i++) {</span><br><span class="line">        maxFree = Math.max(maxFree, drinks[i]) + wash;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][maxFree + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 最下层都是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) { <span class="comment">// 从下往上填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> free = <span class="number">0</span>; free &lt;= maxFree; free++) { <span class="comment">// 从左往右填</span></span><br><span class="line">            <span class="keyword">int</span> selfClean1 = Math.max(drinks[index], free) + wash;</span><br><span class="line">            <span class="keyword">if</span> (selfClean1 &gt; maxFree) {</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 因为后面的也都不用填了</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// index号杯子 决定洗</span></span><br><span class="line">            <span class="keyword">int</span> restClean1 = dp[index + <span class="number">1</span>][selfClean1];</span><br><span class="line">            <span class="keyword">int</span> p1 = Math.max(selfClean1, restClean1);</span><br><span class="line">            <span class="comment">// index号杯子 决定挥发</span></span><br><span class="line">            <span class="keyword">int</span> selfClean2 = drinks[index] + air;</span><br><span class="line">            <span class="keyword">int</span> restClean2 = dp[index + <span class="number">1</span>][free];</span><br><span class="line">            <span class="keyword">int</span> p2 = Math.max(selfClean2, restClean2);</span><br><span class="line">            dp[index][free] = Math.min(p1, p2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-最长回文子序列（LeetCode-516-）&quot;&gt;&lt;a href=&quot;#1-最长回文子序列（LeetCode-516-）&quot; class=&quot;headerlink&quot; title=&quot;1.最长回文子序列（LeetCode 516.）&quot;&gt;&lt;/a&gt;1.最长回文子序列（Leet</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（二）</title>
    <link href="https://haifuns.com/2022/09/04/algorithm-dp2/"/>
    <id>https://haifuns.com/2022/09/04/algorithm-dp2/</id>
    <published>2022-09-04T14:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背包的最大价值"><a href="#1-背包的最大价值" class="headerlink" title="1.背包的最大价值"></a>1.背包的最大价值</h1><p>有一批货物，每个货物的质量和价值已知，用一个称重确定的背包能装入的货物最大价值是多少？</p><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回不超重情况下，背包货物的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 暴力递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w   所有货物质量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v   所有货物价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bag 背包容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> bag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || v == <span class="keyword">null</span> || w.length != v.length || w.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从index开始选择包里还能装的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w     所有货物质量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v     所有货物价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 当前货物位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rest  剩余容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index == w.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p1 = process(w, v, index + <span class="number">1</span>, rest); <span class="comment">// 不要当前货</span></span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next = process(w, v, index + <span class="number">1</span>, rest - w[index]); <span class="comment">// 要当前货</span></span><br><span class="line">    <span class="keyword">if</span> (next != -<span class="number">1</span>) {</span><br><span class="line">        p2 = v[index] + next; <span class="comment">// 不要index了，减掉index价值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> bag)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || v == <span class="keyword">null</span> || w.length != v.length || w.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = w.length;</span><br><span class="line">    <span class="comment">// index 0 ~ N</span></span><br><span class="line">    <span class="comment">// rest 0 ~ bag</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[N][..] = 0，从倒数第二行往上填</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++) {</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[index + <span class="number">1</span>][rest]; <span class="comment">// 不要货物，下一行、容量不变位置</span></span><br><span class="line">            <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 要货物，如果容量够，下一行、容量减当前货质量位置</span></span><br><span class="line">            <span class="keyword">int</span> next = rest - w[index] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[index + <span class="number">1</span>][rest - w[index]];</span><br><span class="line">            <span class="keyword">if</span> (next != -<span class="number">1</span>) {</span><br><span class="line">                p2 = v[index] + next;</span><br><span class="line">            }</span><br><span class="line">            dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-数字转化字母"><a href="#2-数字转化字母" class="headerlink" title="2.数字转化字母"></a>2.数字转化字母</h1><p>规定1和A对应、2和B对应、3和C对应、…、26和Z对应。<br>那么一个数字字符串比如“111”就可以转化为“AAA”、“KA”、“AK”。<br>给定一个只有数字字符组成的字符串str，返回最多有多少种转化结果。</p><h2 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">(String str)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化str[i..]，返回有多少种转化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == str.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i没到最后，说明有字符</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">'0'</span>) { <span class="comment">// 之前的决定有问题，不会单独出现0开头的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// str[i] != '0'</span></span><br><span class="line">    <span class="comment">// i单转</span></span><br><span class="line">    <span class="keyword">int</span> ways = process(str, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// i和后面数字合并转，合并不能超过27</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">'0'</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">'0'</span> &lt; <span class="number">27</span>) {</span><br><span class="line">        ways += process(str, i + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从右往左的动态规划，dp[i]表示str[i.]有多少种转化方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[N] = <span class="number">1</span>; <span class="comment">// 最右只有一种</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">'0'</span>) {</span><br><span class="line">            <span class="keyword">int</span> ways = dp[i + <span class="number">1</span>]; <span class="comment">// 当前字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">'0'</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">'0'</span> &lt; <span class="number">27</span>) {</span><br><span class="line">                ways += dp[i + <span class="number">2</span>]; <span class="comment">// 当前字符 + 下一个字符</span></span><br><span class="line">            }</span><br><span class="line">            dp[i] = ways;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-贴纸拼词（LeetCode-691-）"><a href="#3-贴纸拼词（LeetCode-691-）" class="headerlink" title="3.贴纸拼词（LeetCode 691.）"></a>3.贴纸拼词（LeetCode 691.）</h1><p>给定一个字符串 str 和一个字符串类型的数组 arr，其中都是小写英文字母。<br>arr 中每一个字符串代表一张贴纸，你可以把单个字符剪开使用，目的是拼出 str。<br>每个贴纸的数量是无限的，返回至少需要多少张贴纸可以完成这个任务。</p><p>例如：str = “babac”，arr = [“ba”, “c”, “abcd”]，至少需要两张贴纸 “ba” 和 “abcd” 或 “abcd” 和 “abcd”。</p><h2 id="暴力递归-2"><a href="#暴力递归-2" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minStickers1</span><span class="params">(String[] stickers, String target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans = process1(stickers, target);</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有贴纸stickers，每一种贴纸都有无穷张</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(String[] stickers, String target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String first : stickers) { <span class="comment">// 每张贴纸做为第一张</span></span><br><span class="line">        String rest = minus(target, first); <span class="comment">// 使用贴纸后剩余的字符</span></span><br><span class="line">        <span class="keyword">if</span> (rest.length() != target.length()) {</span><br><span class="line">            min = Math.min(min, process1(stickers, rest));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// s1是目标字符，s2是贴纸，返回目标-贴纸后的字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minus</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> cha : str1) {</span><br><span class="line">        count[cha - <span class="string">'a'</span>]++; <span class="comment">// 累计目标每个字母个数</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> cha : str2) {</span><br><span class="line">        count[cha - <span class="string">'a'</span>]--; <span class="comment">// 减去贴纸中每个字母数</span></span><br><span class="line">    }</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count[i]; j++) {</span><br><span class="line">                builder.append((<span class="keyword">char</span>) (i + <span class="string">'a'</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> builder.toString(); <span class="comment">// 剩余的字母合并</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力递归词频和剪枝优化"><a href="#暴力递归词频和剪枝优化" class="headerlink" title="暴力递归词频和剪枝优化"></a>暴力递归词频和剪枝优化</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归词频和剪枝优化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minStickers2</span><span class="params">(String[] stickers, String target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = stickers.length;</span><br><span class="line">    <span class="comment">// 关键优化(用词频表替代贴纸数组)</span></span><br><span class="line">    <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> cha : str) {</span><br><span class="line">            counts[i][cha - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = process2(counts, target);</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickers[i] 为i号贴纸的字符统计</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[][] stickers, String t)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (t.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] target = t.toCharArray();</span><br><span class="line">    <span class="comment">// 目标词频统计</span></span><br><span class="line">    <span class="keyword">int</span>[] tcounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> cha : target) {</span><br><span class="line">        tcounts[cha - <span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = stickers.length;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="comment">// 第一张贴纸</span></span><br><span class="line">        <span class="keyword">int</span>[] sticker = stickers[i];</span><br><span class="line">        <span class="comment">// 最关键的优化(重要的剪枝!这一步也是贪心!)</span></span><br><span class="line">        <span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">'a'</span>] &gt; <span class="number">0</span>) {</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">int</span> nums = tcounts[j] - sticker[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums; k++) {</span><br><span class="line">                        builder.append((<span class="keyword">char</span>) (j + <span class="string">'a'</span>));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            String rest = builder.toString();</span><br><span class="line">            min = Math.min(min, process2(stickers, rest));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力递归缓存优化"><a href="#暴力递归缓存优化" class="headerlink" title="暴力递归缓存优化"></a>暴力递归缓存优化</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索，暴力递归缓存优化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minStickers3</span><span class="params">(String[] stickers, String target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = stickers.length;</span><br><span class="line">    <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> cha : str) {</span><br><span class="line">            counts[i][cha - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dp.put(<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = process3(counts, target, dp);</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process3</span><span class="params">(<span class="keyword">int</span>[][] stickers, String t, HashMap&lt;String, Integer&gt; dp)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (dp.containsKey(t)) {</span><br><span class="line">        <span class="keyword">return</span> dp.get(t);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] target = t.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] tcounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> cha : target) {</span><br><span class="line">        tcounts[cha - <span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = stickers.length;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">int</span>[] sticker = stickers[i];</span><br><span class="line">        <span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">'a'</span>] &gt; <span class="number">0</span>) {</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">int</span> nums = tcounts[j] - sticker[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums; k++) {</span><br><span class="line">                        builder.append((<span class="keyword">char</span>) (j + <span class="string">'a'</span>));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            String rest = builder.toString();</span><br><span class="line">            min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    dp.put(t, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-最长公共子序列（LeetCode-1143-）"><a href="#4-最长公共子序列（LeetCode-1143-）" class="headerlink" title="4.最长公共子序列（LeetCode 1143.）"></a>4.最长公共子序列（LeetCode 1143.）</h1><p>给定两个字符串 str1 和 str2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p>题目本质就是问str1[0..i]和str2[0..j]，这个范围上最长公共子序列长度是多少？</p><p>可能性分类以及递归过程:</p><ol><li>最长公共子序列，一定不以str1[i]字符结尾、也一定不以str2[j]字符结尾<ul><li>最长公共子序列 = str1[0..i-1] 与 str2[0..j-1] 的最长公共子序列长度(后续递归)</li></ul></li><li>最长公共子序列，可能以str1[i]字符结尾、但是一定不以str2[j]字符结尾<ul><li>最长公共子序列 = str1[0..i] 与 str2[0..j-1] 的最长公共子序列长度(后续递归)</li></ul></li><li>最长公共子序列，一定不以str1[i]字符结尾、但是可能以str2[j]字符结尾<ul><li>最长公共子序列 = str1[0..i-1] 与 str2[0..j] 的最长公共子序列长度(后续递归)</li></ul></li><li>最长公共子序列，必须以str1[i]字符结尾、也必须以str2[j]字符结尾<ul><li>最长公共子序列总长度 = str1[0..i-1] 与 str2[0..j-1] 的最长公共子序列长度(后续递归) + 1(共同的结尾)</li></ul></li></ol><p>注意：1、2、3、4并不是完全互斥的，可能会有重叠的情况。</p><p>以上四种情况已经穷尽了所有可能性。四种情况中取最大即可：</p><p>其中2、3一定参与最大值的比较：</p><ul><li>当str1[i] == str2[j]时，1 一定比 4 小，所以 4 参与</li><li>当str1[i] != str2[j]时，4 压根不存在，所以 1 参与</li></ul><p>因为 1 中始终有一个样本的范围比 2 和 3 小，所以：</p><ul><li>当 str1[i] == str2[j] 时，需要从 2、3、4 中选出最大值。</li><li>当 str1[i] != str2[j] 时，需要从 2、3 中选出最大值。</li></ul><h2 id="暴力递归-3"><a href="#暴力递归-3" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence1</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="comment">// 尝试</span></span><br><span class="line">    <span class="keyword">return</span> process1(str1, str2, str1.length - <span class="number">1</span>, str2.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// str1[0..i]和str2[0..j] 范围上最长公共子序列长度是多少？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">char</span>[] str1, <span class="keyword">char</span>[] str2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// str1[0..0]和str2[0..0]，都只剩一个字符了</span></span><br><span class="line">        <span class="comment">// 那如果字符相等，公共子序列长度就是1，不相等就是0</span></span><br><span class="line">        <span class="keyword">return</span> str1[i] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// str1[0..0]和str2[0..j]，str1只剩1个字符，但是str2不只一个字符</span></span><br><span class="line">        <span class="comment">// 因为str1只剩一个字符了，所以str1[0..0]和str2[0..j]公共子序列最多长度为1</span></span><br><span class="line">        <span class="comment">// 如果str1[0] == str2[j]，那么此时相等已经找到了！公共子序列长度就是1，也不可能更大了</span></span><br><span class="line">        <span class="comment">// 如果str1[0] != str2[j]，只是此时不相等而已，</span></span><br><span class="line">        <span class="comment">// 那么str2[0..j-1]上有没有字符等于str1[0]呢？不知道，所以递归继续找</span></span><br><span class="line">        <span class="keyword">if</span> (str1[i] == str2[j]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 和上面的else if同理</span></span><br><span class="line">        <span class="comment">// str1[0..i]和str2[0..0]，str2只剩1个字符了，但是str1不只一个字符</span></span><br><span class="line">        <span class="comment">// 因为str2只剩一个字符了，所以str1[0..i]和str2[0..0]公共子序列最多长度为1</span></span><br><span class="line">        <span class="comment">// 如果str1[i] == str2[0]，那么此时相等已经找到了！公共子序列长度就是1，也不可能更大了</span></span><br><span class="line">        <span class="comment">// 如果str1[i] != str2[0]，只是此时不相等而已，</span></span><br><span class="line">        <span class="comment">// 那么str1[0..i-1]上有没有字符等于str2[0]呢？不知道，所以递归继续找</span></span><br><span class="line">        <span class="keyword">if</span> (str1[i] == str2[j]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// i != 0 &amp;&amp; j != 0</span></span><br><span class="line">        <span class="comment">// 这里的情况为：</span></span><br><span class="line">        <span class="comment">// str1[0..i]和str2[0..i]，str1和str2都不只一个字符</span></span><br><span class="line">        <span class="comment">// p1对应分析可能性3</span></span><br><span class="line">        <span class="keyword">int</span> p1 = process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// p2对应分析可能性2</span></span><br><span class="line">        <span class="keyword">int</span> p2 = process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// p3对应分析可能性4，如果可能性4存在，即str1[i] == str2[j]，那么p3就求出来，参与pk</span></span><br><span class="line">        <span class="comment">// 如果可能性4不存在，即str1[i] != str2[j]，那么让p3等于0，然后去参与pk，反正不影响</span></span><br><span class="line">        <span class="keyword">int</span> p3 = str1[i] == str2[j] ? (<span class="number">1</span> + process1(str1, str2, i - <span class="number">1</span>, j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence2</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str1.length;</span><br><span class="line">    <span class="keyword">int</span> M = str2.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][M];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) {</span><br><span class="line">        dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) {</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">int</span> p2 = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> p3 = str1[i] == str2[j] ? (<span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">            dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-背包的最大价值&quot;&gt;&lt;a href=&quot;#1-背包的最大价值&quot; class=&quot;headerlink&quot; title=&quot;1.背包的最大价值&quot;&gt;&lt;/a&gt;1.背包的最大价值&lt;/h1&gt;&lt;p&gt;有一批货物，每个货物的质量和价值已知，用一个称重确定的背包能装入的货物最大价值是多少</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】暴力递归到动态规划（一）</title>
    <link href="https://haifuns.com/2022/09/03/algorithm-dp1/"/>
    <id>https://haifuns.com/2022/09/03/algorithm-dp1/</id>
    <published>2022-09-03T15:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-固定步数移动到终点"><a href="#1-固定步数移动到终点" class="headerlink" title="1.固定步数移动到终点"></a>1.固定步数移动到终点</h1><p>假设有排成一行的 N 个位置，记为 1~N，N 一定大于等于 2。开始时机器人在其中的 M 位置上，当机器人走到边界时必须往回走（1-&gt;2,N-&gt;N-1）,当走到中间位置时可以往左走或者往右走。规定机器人必须走 K 步，最终停在P位置，问有多少种走法？</p><h2 id="暴力递归实现"><a href="#暴力递归实现" class="headerlink" title="暴力递归实现"></a>暴力递归实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定步数移动到终点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现方式1，暴力递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> N     路线长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> aim   目标位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> K     移动次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最多移动方案数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> start, <span class="keyword">int</span> aim, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process1(start, K, aim, N);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从cur出发，走过rest步之后，最终停在aim的方案数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cur  当前位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rest 剩余步数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> aim  目标位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> N    路线长度，位置1..n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方案数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> aim, <span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) { <span class="comment">// 没有剩余步数，走完了！</span></span><br><span class="line">        <span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 当前位置是不是目标位置</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) { <span class="comment">// 走到左边界只能往右走，1 -&gt; 2，步数-1</span></span><br><span class="line">        <span class="keyword">return</span> process1(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur == N) { <span class="comment">// 走到右边界只能往左走，N-1 &lt;- N，步数-1</span></span><br><span class="line">        <span class="keyword">return</span> process1(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中间位置可以往左走也可以往右走，步数-1</span></span><br><span class="line">    <span class="keyword">return</span> process1(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + process1(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力递归缓存优化"><a href="#暴力递归缓存优化" class="headerlink" title="暴力递归缓存优化"></a>暴力递归缓存优化</h2><p>此实现也可以称为是从顶向下的动态规划/记忆化搜索。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方式1优化，利用缓存优化暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways2</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> start, <span class="keyword">int</span> aim, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp就是缓存表，大小 N+1 * K+1</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) {</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>; <span class="comment">// 初始化值为-1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[cur][rest] == -1 -&gt; process2(cur, rest)之前没算过！</span></span><br><span class="line">    <span class="comment">// dp[cur][rest] != -1 -&gt; process2(cur, rest)之前算过！返回值，dp[cur][rest]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> process2(start, K, aim, N, dp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前位置cur范围： 1 ~ N</span></span><br><span class="line"><span class="comment">// 剩余步数rest范围：0 ~ K</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> aim, <span class="keyword">int</span> N, <span class="keyword">int</span>[][] dp)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (dp[cur][rest] != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> dp[cur][rest]; <span class="comment">// 之前算过返回缓存值</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 之前没算过</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) { <span class="comment">// 没有剩余步数</span></span><br><span class="line">        ans = cur == aim ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 当前位置是不是目标位置</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) { <span class="comment">// 走到左边界</span></span><br><span class="line">        ans = process2(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N, dp); <span class="comment">// 往右走，步数-1</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) { <span class="comment">// 走到右边界</span></span><br><span class="line">        ans = process2(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp); <span class="comment">// 往左走，步数-1</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 可以往左右也可以往右走，方案求和，步数-1</span></span><br><span class="line">        ans = process2(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp) + process2(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">    }</span><br><span class="line">    dp[cur][rest] = ans; <span class="comment">// 记录缓存</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h2><p>动态规划实现思路：直接算出1..n每个点走K步到达目标位置的方案数。</p><p>实现方式：</p><ol><li>先初始化第一列，即剩余步数为0时，只有目标位置方案数为1</li><li>依次初始化每一列，<ul><li>当前位置在第一行时，只能往右走，也即方案数=数组左下</li><li>当前位置在最后一行时，只能往左走，也即方案数=数组左上</li><li>当前位置在中间，可以往左或右走，也即方案数=数组左上+左下</li></ul></li></ol><p>e.g. N=5，目标是4</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 0 1 2 3 4 5 6 剩余步数</span><br><span class="line">--------------------</span><br><span class="line">0| x x x x x x x</span><br><span class="line">1| 0 0 0 1 0 4 0</span><br><span class="line">2| 0 0 1 0 4 0 13</span><br><span class="line">3| 0 1 0 3 0 9 0</span><br><span class="line">4| 1 0 2 0 5 0 14</span><br><span class="line">5| 0 1 0 2 0 5 0</span><br><span class="line">当前位置</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> start, <span class="keyword">int</span> aim, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">    dp[aim][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 设置目标位置为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">1</span>; rest &lt;= K; rest++) {</span><br><span class="line">        dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>]; <span class="comment">// 第一行，左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur = <span class="number">2</span>; cur &lt; N; cur++) {</span><br><span class="line">            dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>]; <span class="comment">// 第n行，右边界</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[start][K];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-预测赢家"><a href="#2-预测赢家" class="headerlink" title="2.预测赢家"></a>2.预测赢家</h1><p>给定一个整形数组arr，代表数值不同的纸牌排成一条线（明牌）。玩家A和玩家B依次拿走每张牌，规定玩家A先手，每次取牌时只能拿走最左或最右的牌。玩家A和玩家B都绝顶聪明，每次取牌都会使自己的分数最大化，请返回最后获胜者的分数。</p><h2 id="暴力递归实现-1"><a href="#暴力递归实现-1" class="headerlink" title="暴力递归实现"></a>暴力递归实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则，返回获胜者的分数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> first = f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 先手最大分数</span></span><br><span class="line">    <span class="keyword">int</span> second = g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后手最大分数</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L == R) { <span class="comment">// 只剩一张牌时先手获得</span></span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p1 = arr[L] + g1(arr, L + <span class="number">1</span>, R); <span class="comment">// 拿L，下一手后手</span></span><br><span class="line">    <span class="keyword">int</span> p2 = arr[R] + g1(arr, L, R - <span class="number">1</span>); <span class="comment">// 拿R，下一手后手</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(p1, p2); <span class="comment">// 先手拿大</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L == R) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p1 = f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数，后手变 L+1..R 先手</span></span><br><span class="line">    <span class="keyword">int</span> p2 = f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数，后手变 L..R-1 先手</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(p1, p2); <span class="comment">// 对手先拿，后手一定拿的小的</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力递归缓存优化-1"><a href="#暴力递归缓存优化-1" class="headerlink" title="暴力递归缓存优化"></a>暴力递归缓存优化</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] fmap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N]; <span class="comment">// 先手缓存</span></span><br><span class="line">    <span class="keyword">int</span>[][] gmap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N]; <span class="comment">// 后手缓存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) {</span><br><span class="line">            fmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">            gmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> first = f2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">    <span class="keyword">int</span> second = g2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">    <span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>[][] fmap, <span class="keyword">int</span>[][] gmap)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (fmap[L][R] != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> fmap[L][R];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L == R) {</span><br><span class="line">        ans = arr[L];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> p1 = arr[L] + g2(arr, L + <span class="number">1</span>, R, fmap, gmap);</span><br><span class="line">        <span class="keyword">int</span> p2 = arr[R] + g2(arr, L, R - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">        ans = Math.max(p1, p2);</span><br><span class="line">    }</span><br><span class="line">    fmap[L][R] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span>[][] fmap, <span class="keyword">int</span>[][] gmap)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (gmap[L][R] != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> gmap[L][R];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L != R) {</span><br><span class="line">        <span class="keyword">int</span> p1 = f2(arr, L + <span class="number">1</span>, R, fmap, gmap); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line">        <span class="keyword">int</span> p2 = f2(arr, L, R - <span class="number">1</span>, fmap, gmap); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line">        ans = Math.min(p1, p2);</span><br><span class="line">    }</span><br><span class="line">    gmap[L][R] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划实现-1"><a href="#动态规划实现-1" class="headerlink" title="动态规划实现"></a>动态规划实现</h2><p>直接推算出数组：</p><ul><li>fmap：每一步先手可以获得最大值</li><li>gmap：每一步后手可以获得最大值</li></ul><p>观察暴力递归过程，fmap[L][R]需要借助gmap[L+1][R]和gmap[L][R-1]，而gmap[L][R]需要借助<br>fmap[L+1][R]和fmap[L][R-1]。也就是需要借助对方数组对应位置的左一格和下一格计算。</p><p>数组中左下部分是无效的（L&gt;R），L=R对角线已知fmap等于arr[L]、gmap等于0。</p><p>接下来只需要对剩下逐级对角线进行计算，即可完成两个数组的推算。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] fmap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">int</span>[][] gmap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        fmap[i][i] = arr[i]; <span class="comment">// 初始化L=R 位置，先手arr[i]，后手0</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> startCol = <span class="number">1</span>; startCol &lt; N; startCol++) { <span class="comment">// 列，1..n</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = startCol;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; N) { <span class="comment">// 沿着对角线推算，每次处理前一个位置右下位置，表格左下部分L&gt;R无用</span></span><br><span class="line">            fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]); <span class="comment">// gmap 对应 fmap 位置，左一格、下一格</span></span><br><span class="line">            gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]); <span class="comment">// fmap 对应 gmap 位置，左一格、下一格</span></span><br><span class="line">            L++;</span><br><span class="line">            R++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-固定步数移动到终点&quot;&gt;&lt;a href=&quot;#1-固定步数移动到终点&quot; class=&quot;headerlink&quot; title=&quot;1.固定步数移动到终点&quot;&gt;&lt;/a&gt;1.固定步数移动到终点&lt;/h1&gt;&lt;p&gt;假设有排成一行的 N 个位置，记为 1~N，N 一定大于等于 2。开</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://haifuns.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】经典递归过程</title>
    <link href="https://haifuns.com/2022/09/01/algorithm-recursion-procedure/"/>
    <id>https://haifuns.com/2022/09/01/algorithm-recursion-procedure/</id>
    <published>2022-09-01T15:35:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>暴力递归，暴力递归就是尝试：</p><ol><li>把问题转换为规模缩小了的同类问题的子问题</li><li>有明确的不需要继续进行递归的条件（base case）</li><li>有当得到了子问题的结果之后的决策过程</li><li>不记录每一个子问题的解</li></ol><h1 id="1-汉诺（Hanoi）塔问题"><a href="#1-汉诺（Hanoi）塔问题" class="headerlink" title="1.汉诺（Hanoi）塔问题"></a>1.汉诺（Hanoi）塔问题</h1><p>假设有三个命名为 A B C 的塔座，在塔座A上插有n个直径大小不相同，由小到大编号为1，2，3，···，n的圆盘，要求将A座上的圆盘移至塔座C并按同样的顺序叠排。</p><p>圆盘移动必须遵守下列规则：</p><ol><li>每次只能移动一个圆盘 。</li><li>圆盘可以插在任意一个塔座上 。</li><li>任何时刻都不能将一个较大的圆盘放在一个较小的圆盘上。</li></ol><p>问把所有的圆盘从 A 柱移动到 C 柱总计最少需要多少次移动？</p><p>思路：</p><p>想要把1..n圆盘从左移动到右分为三步：</p><ol><li>将1..n-1从左移动到中</li><li>将n从左移动到右</li><li>将1..n-1从中移动到右（进入递归，操作略有不同）</li></ol><p>最优解步数：O(2<sup>n</sup> - 1)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现，需要左到右、左到中、中到左、中到右、右到左、右到中6种操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    leftToRight(n); <span class="comment">// 1..n从左到右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从左 -&gt; 右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftToRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from left to right"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    leftToMid(n - <span class="number">1</span>); <span class="comment">// 1..n-1从左到中</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from left to right"</span>); <span class="comment">// n从左到右</span></span><br><span class="line">    midToRight(n - <span class="number">1</span>); <span class="comment">// 1..n-1从中到右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从左 -&gt; 中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftToMid</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from left to mid"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    leftToRight(n - <span class="number">1</span>); <span class="comment">// 1..n-1从左到右</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from left to mid"</span>); <span class="comment">// n从左到中</span></span><br><span class="line">    rightToMid(n - <span class="number">1</span>); <span class="comment">// 1..n-1从右到中</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从右 -&gt; 中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightToMid</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from right to mid"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    rightToLeft(n - <span class="number">1</span>); <span class="comment">// 1..n-1从右到左</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from right to mid"</span>); <span class="comment">// n从右到中</span></span><br><span class="line">    leftToMid(n - <span class="number">1</span>); <span class="comment">// 1..n-1从中到右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从中 -&gt; 右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midToRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from mid to right"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    midToLeft(n - <span class="number">1</span>); <span class="comment">// 1..n-1从中到左</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from mid to right"</span>); <span class="comment">// n从中到右</span></span><br><span class="line">    leftToRight(n - <span class="number">1</span>); <span class="comment">// 1..n-1从左到右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从中 -&gt; 左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midToLeft</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from mid to left"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    midToRight(n - <span class="number">1</span>); <span class="comment">// 1..n-1从中到右</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from mid to left"</span>); <span class="comment">// n从中到左</span></span><br><span class="line">    rightToLeft(n - <span class="number">1</span>); <span class="comment">// 1..n-1从右到左</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~N层圆盘 从右 -&gt; 左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightToLeft</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from right to left"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    rightToMid(n - <span class="number">1</span>); <span class="comment">// 1..n-1从右到中</span></span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from right to left"</span>); <span class="comment">// n从右到左</span></span><br><span class="line">    midToLeft(n - <span class="number">1</span>); <span class="comment">// 1..n-1从中到左</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进一步观察，简化操作，1..n从from移动到to，第三根柱子为other，可以得到通用的移动步骤：</p><ol><li>将1..n-1从from移动到other</li><li>将n从from移动到to</li><li>将1..n-1从other移动到to（进入递归，操作完全相同）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归简化实现，6种移动动作合一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">        func(n, <span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>); <span class="comment">// 1..n 从左到右，剩余中间的柱子</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1..n从from移动到to，other为剩余的柱子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> N, String from, String to, String other)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) { <span class="comment">// base case，只有一个盘，直接移</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        func(N - <span class="number">1</span>, from, other, to); <span class="comment">// 1..n-1从from移动到other，剩余to</span></span><br><span class="line">        System.out.println(<span class="string">"Move "</span> + N + <span class="string">" from "</span> + from + <span class="string">" to "</span> + to); <span class="comment">// n从from移动到to</span></span><br><span class="line">        func(N - <span class="number">1</span>, other, to, from); <span class="comment">// 1..n-1从other移动到to，剩余from</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-打印一个字符串的全部子序列"><a href="#2-打印一个字符串的全部子序列" class="headerlink" title="2.打印一个字符串的全部子序列"></a>2.打印一个字符串的全部子序列</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">subs</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    String path = <span class="string">""</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    process(str, <span class="number">0</span>, ans, path);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..index-1]已经决定过了，决定结果是path，str[index..]需要决定</span></span><br><span class="line"><span class="comment">// 把所有生成的子序列，放入到ans里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, List&lt;String&gt; ans, String path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) { <span class="comment">// 所有字符都决定过了</span></span><br><span class="line">        ans.add(path); <span class="comment">// 结束返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 没有选择index位置的字符</span></span><br><span class="line">    process(str, index + <span class="number">1</span>, ans, path);</span><br><span class="line">    <span class="comment">// 选择index位置的字符</span></span><br><span class="line">    process(str, index + <span class="number">1</span>, ans, path + String.valueOf(str[index]));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-打印一个字符串的全部子序列，要求不要出现重复字面值的子序列"><a href="#3-打印一个字符串的全部子序列，要求不要出现重复字面值的子序列" class="headerlink" title="3.打印一个字符串的全部子序列，要求不要出现重复字面值的子序列"></a>3.打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">subsNoRepeat</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    String path = <span class="string">""</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    process(str, <span class="number">0</span>, set, path);</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String cur : set) {</span><br><span class="line">        ans.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, HashSet&lt;String&gt; set, String path)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) {</span><br><span class="line">        set.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    process2(str, index + <span class="number">1</span>, set, path);</span><br><span class="line">    process2(str, index + <span class="number">1</span>, set, path + String.valueOf(str[index]));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-打印一个字符串的全部排列"><a href="#4-打印一个字符串的全部排列" class="headerlink" title="4.打印一个字符串的全部排列"></a>4.打印一个字符串的全部排列</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">permutation1</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    ArrayList&lt;Character&gt; rest = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> cha : str) {</span><br><span class="line">        rest.add(cha);</span><br><span class="line">    }</span><br><span class="line">    String path = <span class="string">""</span>;</span><br><span class="line">    f(rest, path, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ArrayList&lt;Character&gt; rest, String path, List&lt;String&gt; ans)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (rest.isEmpty()) {</span><br><span class="line">        ans.add(path);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> N = rest.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            <span class="keyword">char</span> cur = rest.get(i); <span class="comment">// 顺序选择rest中剩余的字符</span></span><br><span class="line">            rest.remove(i); <span class="comment">// 使用完移除</span></span><br><span class="line">            f(rest, path + cur, ans); <span class="comment">// 选择当前字符后，继续从剩余的字符中选择下一个字符</span></span><br><span class="line">            rest.add(i, cur); <span class="comment">// 恢复现场</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版递归实现（优）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">permutation2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    g(str, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..index-1]为已决定位置固定，str[index..]需要决定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, List&lt;String&gt; ans)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) {</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; str.length; i++) {</span><br><span class="line">            swap(str, index, i); <span class="comment">// 选择i，放到index位置</span></span><br><span class="line">            g(str, index + <span class="number">1</span>, ans); <span class="comment">// 继续决定index+1位置</span></span><br><span class="line">            swap(str, index, i); <span class="comment">// 恢复现场</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> tmp = chs[i];</span><br><span class="line">    chs[i] = chs[j];</span><br><span class="line">    chs[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-打印一个字符串的全部排列，要求不要出现重复的排列"><a href="#5-打印一个字符串的全部排列，要求不要出现重复的排列" class="headerlink" title="5.打印一个字符串的全部排列，要求不要出现重复的排列"></a>5.打印一个字符串的全部排列，要求不要出现重复的排列</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">permutation</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    g(str, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, List&lt;String&gt; ans)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) {</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>]; <span class="comment">// 记录字符是否已经被使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; str.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!visited[str[i]]) {</span><br><span class="line">                visited[str[i]] = <span class="keyword">true</span>;</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">                g(str, index + <span class="number">1</span>, ans);</span><br><span class="line">                swap(str, index, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> tmp = chs[i];</span><br><span class="line">    chs[i] = chs[j];</span><br><span class="line">    chs[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="6-实现栈逆序"><a href="#6-实现栈逆序" class="headerlink" title="6.实现栈逆序"></a>6.实现栈逆序</h1><p>逆序给定栈，要求不能申请额外数据结构，只能用递归函数实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆序栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) { <span class="comment">// base case，栈空返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i = f(stack); <span class="comment">// 移除并返回栈底元素</span></span><br><span class="line">    reverse(stack); <span class="comment">// 逆序栈中剩下的元素</span></span><br><span class="line">    stack.push(i); <span class="comment">// 重新压入到栈顶</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除并返回栈底元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) { <span class="comment">// base case，栈中只剩最后一个元素返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> last = f(stack);</span><br><span class="line">        stack.push(result);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;暴力递归，暴力递归就是尝试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把问题转换为规模缩小了的同类问题的子问题&lt;/li&gt;
&lt;li&gt;有明确的不需要继续进行递归的条件（base case）&lt;/li&gt;
&lt;li&gt;有当得到了子问题的结果之后的决策过程&lt;/li&gt;
&lt;li&gt;不记录每一个子问题的解&lt;/l</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归" scheme="https://haifuns.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】图</title>
    <link href="https://haifuns.com/2022/08/31/algorithm-graph/"/>
    <id>https://haifuns.com/2022/08/31/algorithm-graph/</id>
    <published>2022-08-31T15:55:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>图结构（Graph）中节点可以具有零个或多个相邻元素，两个节点之间的连接称为边（Edge）。节点也可以称为顶点（Vertex）。</p><p>图的类型：</p><ul><li>无向图，边没有方向</li><li>有向图，边有方向</li><li>带权图，边带权值</li></ul><p>图的表示方式：</p><ul><li>邻接矩阵：图形中顶点之间相邻关系的矩阵。</li><li>邻接表：只关心存在的边，不关心不存在的边，没有空间浪费。</li><li>除以上两种方式外还有其他众多的方式。</li></ul><p>在有向图中，箭头是具有方向的，从一个顶点指向另一个顶点，每个顶点被指向的箭头个数，就是它的入度。从这个顶点指出去的箭头个数，就是它的出度。</p><p>图的算法都不算难，只是coding的代价比较高。图学习方法：</p><ol><li>先用自己最熟练的方式，实现图结构的表达。</li><li>在自己熟悉的结构上，实现所有常用的图算法作为模板。</li><li>把面试题提供的图结构转换为自己熟悉的图结构，再调用模板或改写即可。</li></ol><h1 id="图结构实现"><a href="#图结构实现" class="headerlink" title="图结构实现"></a>图结构实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 边结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>{</span><br><span class="line">    <span class="comment">// 权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="comment">// 出发点</span></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="comment">// 到达点</span></span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">// 点值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 入度，顶点被指向的箭头个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> in;</span><br><span class="line">    <span class="comment">// 出度，顶点指出去的箭头个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> out;</span><br><span class="line">    <span class="comment">// 后继点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">    <span class="comment">// 指出去的边</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>{</span><br><span class="line">    <span class="comment">// 包含的点，值 -&gt; 点</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="comment">// 包含的边</span></span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>{</span><br><span class="line">        nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="图的宽度优先遍历（BFS）"><a href="#图的宽度优先遍历（BFS）" class="headerlink" title="图的宽度优先遍历（BFS）"></a>图的宽度优先遍历（BFS）</h1><p>宽度优先遍历（Breadth First Search）：</p><ol><li>利用队列实现</li><li>从源节点开始依次按照宽度进队列，然后弹出</li><li>每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</li><li>直到队列变为空结束</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node start)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录已经进入过队列的节点，防止出现回路重复遍历</span></span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    set.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) {</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) {</span><br><span class="line">                set.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="图的深度优先遍历（DFS）"><a href="#图的深度优先遍历（DFS）" class="headerlink" title="图的深度优先遍历（DFS）"></a>图的深度优先遍历（DFS）</h1><p>深度优先遍历（Depth First Search）：</p><ol><li>利用栈实现</li><li>从源节点开始把节点按照深度放入栈，然后弹出</li><li>每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</li><li>直到栈变为空结束</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) {</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) {</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h1><p>拓扑排序：</p><ol><li>在图中找到所有入度为0的点输出</li><li>把所有入度为0的点在图中删除，继续找到入度为0的点输出，周而复始</li><li>图的所有点都被删除后，依次输出的顺序就是拓扑排序</li></ol><p>要求：有向图且其中没有环<br>应用：事件安排、编译顺序</p><p>拓扑排序可以有多种顺序，并不是只有唯一的顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向图且无环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span> </span>{</span><br><span class="line">    <span class="comment">// 节点 -&gt; 剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 剩余入度为0的点</span></span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) {</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>) {</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty()) {</span><br><span class="line">        Node cur = zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) {</span><br><span class="line">            inMap.put(next, inMap.get(next) - <span class="number">1</span>); <span class="comment">// 所有的邻接点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) {</span><br><span class="line">                zeroInQueue.add(next); <span class="comment">// 如果邻接点入度为0，记录</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-拓扑排序（LintCode-127-）"><a href="#1-拓扑排序（LintCode-127-）" class="headerlink" title="1.拓扑排序（LintCode 127.）"></a>1.拓扑排序（LintCode 127.）</h1><p>给定一个有向图，图节点的拓扑排序定义如下:</p><ul><li>对于图中的每一条有向边 A -&gt; B , 在拓扑排序中A一定在B之前。</li><li>拓扑排序中的第一个节点可以是图中的任何一个没有其他节点指向它的节点。</li></ul><p>针对给定的有向图找到任意一种拓扑排序的顺序。</p><p>点结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedGraphNode</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> label;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; neighbors; <span class="comment">// 邻接点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedGraphNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        label = x;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="解法1：bfs统计入度"><a href="#解法1：bfs统计入度" class="headerlink" title="解法1：bfs统计入度"></a>解法1：bfs统计入度</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此题特殊之处在于只给定了图中所有的点</span></span><br><span class="line"><span class="comment">// bfs实现，统计入度数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>{</span><br><span class="line">    HashMap&lt;DirectedGraphNode, Integer&gt; indegreeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化每个点入度数为0</span></span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode cur : graph) {</span><br><span class="line">        indegreeMap.put(cur, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历统计每个点入度数</span></span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode cur : graph) {</span><br><span class="line">        <span class="keyword">for</span> (DirectedGraphNode next : cur.neighbors) {</span><br><span class="line">            indegreeMap.put(next, indegreeMap.get(next) + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑队列</span></span><br><span class="line">    Queue&lt;DirectedGraphNode&gt; zeroQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 取出第一层依次压入队列</span></span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode cur : indegreeMap.keySet()) {</span><br><span class="line">        <span class="keyword">if</span> (indegreeMap.get(cur) == <span class="number">0</span>) {</span><br><span class="line">            zeroQueue.add(cur);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑序结果</span></span><br><span class="line">    ArrayList&lt;DirectedGraphNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroQueue.isEmpty()) {</span><br><span class="line">        DirectedGraphNode cur = zeroQueue.poll(); <span class="comment">// 弹出一个入度为0的点</span></span><br><span class="line">        ans.add(cur); <span class="comment">// 记到结果里</span></span><br><span class="line">        <span class="keyword">for</span> (DirectedGraphNode next : cur.neighbors) { <span class="comment">// 当前点所有临接点入度-1</span></span><br><span class="line">            indegreeMap.put(next, indegreeMap.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (indegreeMap.get(next) == <span class="number">0</span>) {</span><br><span class="line">                zeroQueue.offer(next); <span class="comment">// 如果邻接点入度为0压入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="解法2：dfs统计点次"><a href="#解法2：dfs统计点次" class="headerlink" title="解法2：dfs统计点次"></a>解法2：dfs统计点次</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> DirectedGraphNode node; <span class="comment">// 点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> nodes; <span class="comment">// 点次，当前点子图所有的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(DirectedGraphNode n, <span class="keyword">long</span> o)</span> </span>{</span><br><span class="line">        node = n;</span><br><span class="line">        nodes = o;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Record</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Record o1, Record o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.nodes == o2.nodes ? <span class="number">0</span> : (o1.nodes &gt; o2.nodes ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs思路：统计每个点的点次，点次排序高到低对应拓扑排序。点次：当前点子图所有的节点数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>{</span><br><span class="line">    HashMap&lt;DirectedGraphNode, Record&gt; order = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode cur : graph) {</span><br><span class="line">        f(cur, order); <span class="comment">// 计算每个点的点次</span></span><br><span class="line">    }</span><br><span class="line">    ArrayList&lt;Record&gt; recordArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Record r : order.values()) {</span><br><span class="line">        recordArr.add(r);</span><br><span class="line">    }</span><br><span class="line">    recordArr.sort(<span class="keyword">new</span> MyComparator()); <span class="comment">// 排序，点次高在前</span></span><br><span class="line">    ArrayList&lt;DirectedGraphNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Record r : recordArr) {</span><br><span class="line">        ans.add(r.node); <span class="comment">// 点次排序对应拓扑排序</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前来到cur点，返回cur点所到之处，所有的点次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cur   当前点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> order 缓存，点 -&gt; 点次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> （cur，点次）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Record <span class="title">f</span><span class="params">(DirectedGraphNode cur, HashMap&lt;DirectedGraphNode, Record&gt; order)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (order.containsKey(cur)) {</span><br><span class="line">        <span class="keyword">return</span> order.get(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// cur的点次之前没算过！</span></span><br><span class="line">    <span class="keyword">long</span> nodes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode next : cur.neighbors) {</span><br><span class="line">        nodes += f(next, order).nodes;</span><br><span class="line">    }</span><br><span class="line">    Record ans = <span class="keyword">new</span> Record(cur, nodes + <span class="number">1</span>);</span><br><span class="line">    order.put(cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="解法3：dfs统计深度"><a href="#解法3：dfs统计深度" class="headerlink" title="解法3：dfs统计深度"></a>解法3：dfs统计深度</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> DirectedGraphNode node;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> deep;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(DirectedGraphNode n, <span class="keyword">int</span> o)</span> </span>{</span><br><span class="line">        node = n;</span><br><span class="line">        deep = o;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Record</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Record o1, Record o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o2.deep - o1.deep;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>{</span><br><span class="line">    HashMap&lt;DirectedGraphNode, Record&gt; order = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode cur : graph) {</span><br><span class="line">        f(cur, order);</span><br><span class="line">    }</span><br><span class="line">    ArrayList&lt;Record&gt; recordArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Record r : order.values()) {</span><br><span class="line">        recordArr.add(r);</span><br><span class="line">    }</span><br><span class="line">    recordArr.sort(<span class="keyword">new</span> MyComparator());</span><br><span class="line">    ArrayList&lt;DirectedGraphNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Record r : recordArr) {</span><br><span class="line">        ans.add(r.node);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Record <span class="title">f</span><span class="params">(DirectedGraphNode cur, HashMap&lt;DirectedGraphNode, Record&gt; order)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (order.containsKey(cur)) {</span><br><span class="line">        <span class="keyword">return</span> order.get(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> follow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (DirectedGraphNode next : cur.neighbors) {</span><br><span class="line">        follow = Math.max(follow, f(next, order).deep);</span><br><span class="line">    }</span><br><span class="line">    Record ans = <span class="keyword">new</span> Record(cur, follow + <span class="number">1</span>);</span><br><span class="line">    order.put(cur, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="最小生成树之Kruskal算法"><a href="#最小生成树之Kruskal算法" class="headerlink" title="最小生成树之Kruskal算法"></a>最小生成树之Kruskal算法</h1><p>最小生成树定义：对于无向带权图，在不影响所有点连通的情况下，保持图连通的最少的边。</p><p>Kruskal算法（克鲁斯卡尔算法，利用并查集实现）：</p><ol><li>总是从权值最小的边开始考虑，依次考察权值依次变大的边</li><li>当前的边要么进入最小生成树的集合，要么丢弃</li><li>如果当前的边进入最小生成树的集合中不会形成环，就要当前边</li><li>如果当前的边进入最小生成树的集合会形成环，就不要当前边</li><li>考察完所有的边之后，得到最小生成树集合</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>{</span><br><span class="line">    <span class="comment">// 某一个节点 -&gt; 节点往上的节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">    <span class="comment">// 某一个集合的代表节点 -&gt; 代表节点所在集合的节点个数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>{</span><br><span class="line">        fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>{</span><br><span class="line">        fatherMap.clear();</span><br><span class="line">        sizeMap.clear();</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) {</span><br><span class="line">            fatherMap.put(node, node); <span class="comment">// 初始化集合，每个点都是集合</span></span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>); <span class="comment">// 初始化集合代表节点，是自己</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findFather</span><span class="params">(Node n)</span> </span>{</span><br><span class="line">        Stack&lt;Node&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != fatherMap.get(n)) {</span><br><span class="line">            path.add(n);</span><br><span class="line">            n = fatherMap.get(n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!path.isEmpty()) {</span><br><span class="line">            fatherMap.put(path.pop(), n); <span class="comment">// 路径压缩优化</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Node aDai = findFather(a); <span class="comment">// 找到代表节点</span></span><br><span class="line">        Node bDai = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (aDai != bDai) { <span class="comment">// 不是同一个集合</span></span><br><span class="line">            <span class="keyword">int</span> aSetSize = sizeMap.get(aDai); <span class="comment">// 集合大小</span></span><br><span class="line">            <span class="keyword">int</span> bSetSize = sizeMap.get(bDai);</span><br><span class="line">            <span class="keyword">if</span> (aSetSize &lt;= bSetSize) { <span class="comment">// 小集合挂到大集合上</span></span><br><span class="line">                fatherMap.put(aDai, bDai);</span><br><span class="line">                sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">                sizeMap.remove(aDai);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                fatherMap.put(bDai, aDai);</span><br><span class="line">                sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">                sizeMap.remove(bDai);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>{</span><br><span class="line">    UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">    unionFind.makeSets(graph.nodes.values());</span><br><span class="line">    <span class="comment">// 从小的边到大的边，依次弹出，小根堆！</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : graph.edges) { <span class="comment">// M 条边</span></span><br><span class="line">        priorityQueue.add(edge); <span class="comment">// O(logM)</span></span><br><span class="line">    }</span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) { <span class="comment">// M 条边</span></span><br><span class="line">        Edge edge = priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line">        <span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) { <span class="comment">// 边的两边节点不在一个集合 O(1)</span></span><br><span class="line">            result.add(edge); <span class="comment">// 保留边</span></span><br><span class="line">            unionFind.union(edge.from, edge.to); <span class="comment">// 合并集合</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="最小生成树之Prim算法"><a href="#最小生成树之Prim算法" class="headerlink" title="最小生成树之Prim算法"></a>最小生成树之Prim算法</h1><p>Prim算法（普里姆算法）：</p><ol><li>可以从任意节点触发来寻找最小生成树</li><li>某个点加入到被选取的点中后，解锁这个点出发的所有新的边</li><li>在所有解锁的边（所有被选取点累计解锁的边）中选择最小的边，然后看这个边会不会形成环</li><li>如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3</li><li>如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2</li><li>当所有点都被选取之后，得到最小生成树集合</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>{</span><br><span class="line">    <span class="comment">// 解锁的边进入小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哪些点被解锁出来了</span></span><br><span class="line">    HashSet&lt;Node&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 依次挑选的的边在result里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) { <span class="comment">// 随便挑一个点，循环的目的是防止森林</span></span><br><span class="line">        <span class="comment">// node 是开始点</span></span><br><span class="line">        <span class="keyword">if</span> (!nodeSet.contains(node)) {</span><br><span class="line">            nodeSet.add(node); <span class="comment">// 接入到解锁点集合</span></span><br><span class="line">            <span class="keyword">for</span> (Edge edge : node.edges) { <span class="comment">// 由一个点，解锁所有相连的边</span></span><br><span class="line">                priorityQueue.add(edge);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) {</span><br><span class="line">                Edge edge = priorityQueue.poll(); <span class="comment">// 弹出解锁的边中，最小的边</span></span><br><span class="line">                Node toNode = edge.to; <span class="comment">// 可能的一个新的点</span></span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(toNode)) { <span class="comment">// 不含有的时候，就是新的点</span></span><br><span class="line">                    nodeSet.add(toNode); <span class="comment">// 解锁点</span></span><br><span class="line">                    result.add(edge); <span class="comment">// 记录有效边</span></span><br><span class="line">                    <span class="keyword">for</span> (Edge nextEdge : toNode.edges) { <span class="comment">// 解锁&lt;解锁点&gt;的所有边</span></span><br><span class="line">                        priorityQueue.add(nextEdge);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// break; // 确定图只有一条线时可以直接跳过</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="顶点到其余各顶点的最短路径（Dijkstra算法）"><a href="#顶点到其余各顶点的最短路径（Dijkstra算法）" class="headerlink" title="顶点到其余各顶点的最短路径（Dijkstra算法）"></a>顶点到其余各顶点的最短路径（Dijkstra算法）</h1><p>Dijkstra算法（迪杰斯特拉算法）是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。</p><p>图要求：有向无负权值，可以有环。</p><p>算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</p><p>Dijkstra算法，找指定节点x到其他点的最短距离：</p><ol><li>记录x到每个邻接点的权值到表里，k -&gt; v：点 -&gt; 权值，自己到自己距离为0</li><li>从表中找到与x距离最小且没有被锁定的点m</li><li>遍历m所有邻接点，重新计算每个点经过m与x的距离，如果表里不存在就新增，距离更小就更新</li><li>结束后锁定m，重复2</li><li>当表里所有元素都被锁定结束</li></ol><h2 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node from)</span> </span>{</span><br><span class="line">    <span class="comment">// 距离表，记录点与原始点距离，点 -&gt; 距离</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distanceMap.put(from, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 锁定的点</span></span><br><span class="line">    HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 没有被锁定，与原始点距离最小的点</span></span><br><span class="line">    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 原始点 -&gt; minNode（跳转点），最小距离distance</span></span><br><span class="line">        <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) {</span><br><span class="line">            Node toNode = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) {</span><br><span class="line">                distanceMap.put(toNode, distance + edge.weight); <span class="comment">// 表里不存在新增</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight)); <span class="comment">// 取原始距离和经过跳转点的最小距离</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        selectedNodes.add(minNode); <span class="comment">// 锁定跳转点</span></span><br><span class="line">        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); <span class="comment">// 更换跳转点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从距离表中找到没有被锁定、最小距离的点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> distanceMap 距离表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> touchedNodes 被锁定的点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>{</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) {</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) {</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="加强堆优化"><a href="#加强堆优化" class="headerlink" title="加强堆优化"></a>加强堆优化</h2><p>Dijkstra算法过程中的2、3步骤需要不断的循环遍历查找、更新，效率较低，可以使用加强堆优化。</p><p>把距离表替换为加强堆（小根堆），需要最小距离时直接从小根堆弹出一个值，新增或更新时利用加强堆更新节点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Node node; <span class="comment">// 点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> distance; <span class="comment">// 距离</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeHeap</span> </span>{</span><br><span class="line">    <span class="comment">// 实际的堆结构</span></span><br><span class="line">    <span class="keyword">private</span> Node[] nodes;</span><br><span class="line">    <span class="comment">// 节点 -&gt; 堆中的位置</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;</span><br><span class="line">    <span class="comment">// 节点 -&gt; 从源节点出发到该节点的目前最小距离</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;</span><br><span class="line">    <span class="comment">// 堆上有多少个点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeHeap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        nodes = <span class="keyword">new</span> Node[size];</span><br><span class="line">        heapIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从源节点出发到达node的距离为distance</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (inHeap(node)) { <span class="comment">// 在堆上，update</span></span><br><span class="line">            distanceMap.put(node, Math.min(distanceMap.get(node), distance)); <span class="comment">// 更新最小距离</span></span><br><span class="line">            insertHeapify(heapIndexMap.get(node)); <span class="comment">// 值变小了，上移</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!isEntered(node)) { <span class="comment">// 没进过堆，add</span></span><br><span class="line">            nodes[size] = node;</span><br><span class="line">            heapIndexMap.put(node, size);</span><br><span class="line">            distanceMap.put(node, distance);</span><br><span class="line">            insertHeapify(size++); <span class="comment">// 新增上移</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出最小记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NodeRecord <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        NodeRecord nodeRecord = <span class="keyword">new</span> NodeRecord(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>); <span class="comment">// 把最后一个节点换到0位置</span></span><br><span class="line">        heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>); <span class="comment">// index改成-1</span></span><br><span class="line">        distanceMap.remove(nodes[size - <span class="number">1</span>]); <span class="comment">// 删除距离</span></span><br><span class="line">        nodes[size - <span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 从堆中删除</span></span><br><span class="line">        heapify(<span class="number">0</span>, --size); <span class="comment">// 下移0位置</span></span><br><span class="line">        <span class="keyword">return</span> nodeRecord;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上移</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeapify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) { <span class="comment">// 小于父节点</span></span><br><span class="line">            swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 交换，上移</span></span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下移</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) {</span><br><span class="line">            <span class="keyword">int</span> smallest = left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">                           ? left + <span class="number">1</span></span><br><span class="line">                           : left; <span class="comment">// index最小子节点</span></span><br><span class="line">            smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">            <span class="keyword">if</span> (smallest == index) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            swap(smallest, index); <span class="comment">// 子节点小于index，交换位置</span></span><br><span class="line">            index = smallest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进没进过堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEntered</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不在堆上</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inHeap</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>{</span><br><span class="line">        heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">        heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">        Node tmp = nodes[index1];</span><br><span class="line">        nodes[index1] = nodes[index2];</span><br><span class="line">        nodes[index2] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加强堆改进后的dijkstra算法</span></span><br><span class="line"><span class="comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra2</span><span class="params">(Node head, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    NodeHeap nodeHeap = <span class="keyword">new</span> NodeHeap(size);</span><br><span class="line">    nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);</span><br><span class="line">    HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!nodeHeap.isEmpty()) {</span><br><span class="line">        NodeRecord record = nodeHeap.pop();</span><br><span class="line">        Node cur = record.node;</span><br><span class="line">        <span class="keyword">int</span> distance = record.distance;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : cur.edges) {</span><br><span class="line">            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">        }</span><br><span class="line">        result.put(cur, distance);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;图结构（Graph）中节点可以具有零个或多个相邻元素，两个节点之间的连接称为边（Edge）。节点也可以称为顶点（Vertex）。&lt;/p&gt;
&lt;p&gt;图的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无向图，边没有方向&lt;/li&gt;
&lt;li&gt;有向图，边有方向&lt;/li&gt;
&lt;li&gt;带权图，边带权值&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://haifuns.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】并查集</title>
    <link href="https://haifuns.com/2022/08/30/algorithm-unionfind/"/>
    <id>https://haifuns.com/2022/08/30/algorithm-unionfind/</id>
    <published>2022-08-30T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p><p>并查集主要操作：</p><ul><li>初始化：把每个点所在集合初始化为其自身。</li><li>查找：查找元素所在的集合，即根节点。</li><li>合并：将两个元素所在的集合合并为一个集合。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>hash表实现并查集，便于理解。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 样本 -&gt; 封装对象</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;</span><br><span class="line">    <span class="comment">// 封装对象 -&gt; 封装对象，表实现父指针</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;</span><br><span class="line">    <span class="comment">// 集合代表节点 -&gt; 集合大小</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(List&lt;V&gt; values)</span> </span>{</span><br><span class="line">        nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        parents = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (V cur : values) {</span><br><span class="line">            Node&lt;V&gt; node = <span class="keyword">new</span> Node&lt;&gt;(cur);</span><br><span class="line">            nodes.put(cur, node);</span><br><span class="line">            parents.put(node, node); <span class="comment">// 初始化时每一个节点指向自己</span></span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>); <span class="comment">// 初始化时每一个节点都是自己所在集合的代表节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到给定节点的代表节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;V&gt; <span class="title">findFather</span><span class="params">(Node&lt;V&gt; cur)</span> </span>{</span><br><span class="line">        Stack&lt;Node&lt;V&gt;&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != parents.get(cur)) {</span><br><span class="line">            path.push(cur);</span><br><span class="line">            cur = parents.get(cur);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时cur为代表节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!path.isEmpty()) {</span><br><span class="line">            <span class="comment">// 优化点，减少链长度</span></span><br><span class="line">            <span class="comment">// 经过的所有节点都直接指向代表节点</span></span><br><span class="line">            parents.put(path.pop(), cur);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a b样本是否在一个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(V a, V b)</span> </span>{</span><br><span class="line">        <span class="comment">// 找a b的代表节点，比较是否是一个</span></span><br><span class="line">        <span class="keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(V a, V b)</span> </span>{</span><br><span class="line">        <span class="comment">// a代表节点</span></span><br><span class="line">        Node&lt;V&gt; aHead = findFather(nodes.get(a));</span><br><span class="line">        <span class="comment">// b代表节点</span></span><br><span class="line">        Node&lt;V&gt; bHead = findFather(nodes.get(b));</span><br><span class="line">        <span class="keyword">if</span> (aHead != bHead) {</span><br><span class="line">            <span class="comment">// a所在集合大小</span></span><br><span class="line">            <span class="keyword">int</span> aSetSize = sizeMap.get(aHead);</span><br><span class="line">            <span class="comment">// b所在集合大小</span></span><br><span class="line">            <span class="keyword">int</span> bSetSize = sizeMap.get(bHead);</span><br><span class="line">            <span class="comment">// 大集合代表节点</span></span><br><span class="line">            Node&lt;V&gt; big = aSetSize &gt;= bSetSize ? aHead : bHead;</span><br><span class="line">            <span class="comment">// 小集合代表节点</span></span><br><span class="line">            Node&lt;V&gt; small = big == aHead ? bHead : aHead;</span><br><span class="line">            <span class="comment">// 优化点，小挂到大上，减少链长度</span></span><br><span class="line">            <span class="comment">// 小集合代表节点指向大集合代表节点</span></span><br><span class="line">            parents.put(small, big);</span><br><span class="line">            <span class="comment">// 更新大集合代表节点对应的集合大小</span></span><br><span class="line">            sizeMap.put(big, aSetSize + bSetSize);</span><br><span class="line">            <span class="comment">// 删除小集合</span></span><br><span class="line">            sizeMap.remove(small);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sets</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sizeMap.size();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>hash表常数时间慢，数组实现方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>{</span><br><span class="line">    <span class="comment">// parent[i]=k -&gt; i的父亲是k</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// size[i]=k -&gt; i所在的集合大小是k，如果i是代表节点，size[i]才有意义，否则无意义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="comment">// 辅助结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] help;</span><br><span class="line">    <span class="comment">// 一共有多少个集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        help = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        sets = N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">            parent[i] = i; <span class="comment">// 初始代表节点都是自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>; <span class="comment">// 每个集合大小是1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从i开始一直往上，往上到不能再往上，代表节点，返回</span></span><br><span class="line">    <span class="comment">// 过程中做路径压缩优化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != parent[i]) { <span class="comment">// parent是自己为代表节点</span></span><br><span class="line">            help[hi++] = i; <span class="comment">// help中存放的是链上经过的节点</span></span><br><span class="line">            i = parent[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (hi--; hi &gt;= <span class="number">0</span>; hi--) {</span><br><span class="line">            parent[help[hi]] = i; <span class="comment">// 路径压缩，链上经过的所有节点都指向代表节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> f1 = find(i); <span class="comment">// i所在集合代表节点</span></span><br><span class="line">        <span class="keyword">int</span> f2 = find(j); <span class="comment">// j所在集合代表节点</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2) { <span class="comment">// 不在同一个集合</span></span><br><span class="line">            <span class="keyword">if</span> (size[f1] &gt;= size[f2]) { <span class="comment">// 小集合挂到大集合上</span></span><br><span class="line">                size[f1] += size[f2];</span><br><span class="line">                parent[f2] = f1;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                size[f2] += size[f1];</span><br><span class="line">                parent[f1] = f2;</span><br><span class="line">            }</span><br><span class="line">            sets--; <span class="comment">// 集合总数量-1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sets</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-省份数量（LeetCode-547-）"><a href="#1-省份数量（LeetCode-547-）" class="headerlink" title="1.省份数量（LeetCode 547.）"></a>1.省份数量（LeetCode 547.）</h1><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p><p>返回矩阵中省份的数量。</p><p>提示：</p><ul><li>isConnected[i][j] 为 1 或 0</li><li>isConnected[i][i] == 1</li><li>isConnected[i][j] == isConnected[j][i]</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = M.length;</span><br><span class="line">    <span class="comment">// 0..N-1，初始集合数=城市数</span></span><br><span class="line">    UnionFind unionFind = <span class="keyword">new</span> UnionFind(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) { <span class="comment">// 只遍历矩阵右上部分</span></span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) { <span class="comment">// i和j互相认识</span></span><br><span class="line">                unionFind.union(i, j); <span class="comment">// 合并集合</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> unionFind.sets();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-岛屿数量（LeetCode-200-）"><a href="#2-岛屿数量（LeetCode-200-）" class="headerlink" title="2.岛屿数量（LeetCode 200.）"></a>2.岛屿数量（LeetCode 200.）</h1><p>给你一个由’1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：<br>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p><p>示例 2：<br>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现，感染算法，复杂度O(m*n)，最优解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numIslands1</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> islands = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'1'</span>) { <span class="comment">// 每遇到一个'1'都是新岛屿</span></span><br><span class="line">                islands++;</span><br><span class="line">                infect(board, i, j); <span class="comment">// 感染所有相邻'1'，变为0</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> islands;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从(i,j)这个位置出发，把所有练成一片的'1'字符，变成0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || board[i][j] != <span class="string">'1'</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    board[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 感染上下左右相邻'1'</span></span><br><span class="line">    infect(board, i - <span class="number">1</span>, j);</span><br><span class="line">    infect(board, i + <span class="number">1</span>, j);</span><br><span class="line">    infect(board, i, j - <span class="number">1</span>);</span><br><span class="line">    infect(board, i, j + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numIslands2</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(board);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) {</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j - <span class="number">1</span>] == <span class="string">'1'</span> &amp;&amp; board[<span class="number">0</span>][j] == <span class="string">'1'</span>) { <span class="comment">// 左和自己都是'1'</span></span><br><span class="line">            uf.union(<span class="number">0</span>, j - <span class="number">1</span>, <span class="number">0</span>, j); <span class="comment">// 合并</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第0列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) {</span><br><span class="line">        <span class="keyword">if</span> (board[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="string">'1'</span> &amp;&amp; board[i][<span class="number">0</span>] == <span class="string">'1'</span>) { <span class="comment">// 上和自己都是'1'</span></span><br><span class="line">            uf.union(i - <span class="number">1</span>, <span class="number">0</span>, i, <span class="number">0</span>); <span class="comment">// 合并</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'1'</span>) { <span class="comment">// 自己是'1'</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j - <span class="number">1</span>] == <span class="string">'1'</span>) { <span class="comment">// 左是'1'</span></span><br><span class="line">                    uf.union(i, j - <span class="number">1</span>, i, j); <span class="comment">// 合并</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (board[i - <span class="number">1</span>][j] == <span class="string">'1'</span>) { <span class="comment">// 上是'1'</span></span><br><span class="line">                    uf.union(i - <span class="number">1</span>, j, i, j); <span class="comment">// 合并</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> uf.sets();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] help;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维转一维</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">        col = board[<span class="number">0</span>].length; <span class="comment">// 列</span></span><br><span class="line">        sets = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length; <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> len = row * col; <span class="comment">// 总个数，行*列</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        help = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; row; r++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; col; c++) {</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">'1'</span>) {</span><br><span class="line">                    <span class="keyword">int</span> i = index(r, c);</span><br><span class="line">                    parent[i] = i;</span><br><span class="line">                    size[i] = <span class="number">1</span>;</span><br><span class="line">                    sets++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (r,c) -&gt; i</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> r * col + c; <span class="comment">// 下标，所在行*总列数+所在列数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始位置 -&gt; 下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != parent[i]) {</span><br><span class="line">            help[hi++] = i;</span><br><span class="line">            i = parent[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (hi--; hi &gt;= <span class="number">0</span>; hi--) {</span><br><span class="line">            parent[help[hi]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i1 = index(r1, c1);</span><br><span class="line">        <span class="keyword">int</span> i2 = index(r2, c2);</span><br><span class="line">        <span class="keyword">int</span> f1 = find(i1);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(i2);</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2) {</span><br><span class="line">            <span class="keyword">if</span> (size[f1] &gt;= size[f2]) {</span><br><span class="line">                size[f1] += size[f2];</span><br><span class="line">                parent[f2] = f1;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                size[f2] += size[f1];</span><br><span class="line">                parent[f1] = f2;</span><br><span class="line">            }</span><br><span class="line">            sets--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sets</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-岛屿数量II（LeetCode-305-）"><a href="#3-岛屿数量II（LeetCode-305-）" class="headerlink" title="3.岛屿数量II（LeetCode 305.）"></a>3.岛屿数量II（LeetCode 305.）</h1><p>假设你要设计一个游戏，用一个 m 行 n 列的 2d 网格来存储游戏地图。</p><p>起始的时候，每个格子的地形都被默认标记为「水」。我们可以通过使用 addLand 进行操作，将位置 (row, col) 的「水」变成「陆地」。</p><p>你将会被给定一个列表，来记录所有需要被操作的位置，然后你需要返回计算出来 每次 addLand 操作后岛屿的数量。</p><p>注意：一个岛的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以假设地图网格的四边均被无边无际的「水」所包围。</p><p>示例:</p><p>输入: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]]<br>输出: [1,1,2,3]<br>解析:</p><p>起初，二维网格 grid 被全部注入「水」。（0 代表「水」，1 代表「陆地」）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></tbody></table></figure><p>操作 #1：addLand(0, 0) 将 grid[0][0] 的水变为陆地。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 0</span><br><span class="line">0 0 0 岛屿的数量为 1</span><br><span class="line">0 0 0</span><br></pre></td></tr></tbody></table></figure><p>操作 #2：addLand(0, 1) 将 grid[0][1] 的水变为陆地。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">0 0 0 岛屿的数量为 1</span><br><span class="line">0 0 0</span><br></pre></td></tr></tbody></table></figure><p>操作 #3：addLand(1, 2) 将 grid[1][2] 的水变为陆地。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">0 0 1 岛屿的数量为 2</span><br><span class="line">0 0 0</span><br></pre></td></tr></tbody></table></figure><p>操作 #4：addLand(2, 1) 将 grid[2][1] 的水变为陆地。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">0 0 1 岛屿的数量为 3</span><br><span class="line">0 1 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现，O(m*n) + O(k)，网格很大时初始化过重</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">numIslands2v1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span> </span>{</span><br><span class="line">    UnionFind1 uf = <span class="keyword">new</span> UnionFind1(m, n);</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] position : positions) {</span><br><span class="line">        ans.add(uf.connect(position[<span class="number">0</span>], position[<span class="number">1</span>]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] help;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        row = m;</span><br><span class="line">        col = n;</span><br><span class="line">        sets = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = row * col;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        help = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">index</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> r * col + c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != parent[i]) {</span><br><span class="line">            help[hi++] = i;</span><br><span class="line">            i = parent[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (hi--; hi &gt;= <span class="number">0</span>; hi--) {</span><br><span class="line">            parent[help[hi]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (r1 &lt; <span class="number">0</span> || r1 == row || r2 &lt; <span class="number">0</span> || r2 == row || c1 &lt; <span class="number">0</span> || c1 == col || c2 &lt; <span class="number">0</span> || c2 == col) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> i1 = index(r1, c1);</span><br><span class="line">        <span class="keyword">int</span> i2 = index(r2, c2);</span><br><span class="line">        <span class="keyword">if</span> (size[i1] == <span class="number">0</span> || size[i2] == <span class="number">0</span>) { <span class="comment">// 如果有任何一个没有初始化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> f1 = find(i1);</span><br><span class="line">        <span class="keyword">int</span> f2 = find(i2);</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2) { <span class="comment">// 合并集合</span></span><br><span class="line">            <span class="keyword">if</span> (size[f1] &gt;= size[f2]) {</span><br><span class="line">                size[f1] += size[f2];</span><br><span class="line">                parent[f2] = f1;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                size[f2] += size[f1];</span><br><span class="line">                parent[f1] = f2;</span><br><span class="line">            }</span><br><span class="line">            sets--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> index = index(r, c); <span class="comment">// r行c列下标</span></span><br><span class="line">        <span class="keyword">if</span> (size[index] == <span class="number">0</span>) { <span class="comment">// 如果没有初始化，动态初始化</span></span><br><span class="line">            parent[index] = index; <span class="comment">// 初始化集合，代表节点是自己</span></span><br><span class="line">            size[index] = <span class="number">1</span>; <span class="comment">// 初始化集合</span></span><br><span class="line">            sets++; <span class="comment">// 集合数量+1</span></span><br><span class="line">            <span class="comment">// 跟上下左右集合合并</span></span><br><span class="line">            union(r - <span class="number">1</span>, c, r, c);</span><br><span class="line">            union(r + <span class="number">1</span>, c, r, c);</span><br><span class="line">            union(r, c - <span class="number">1</span>, r, c);</span><br><span class="line">            union(r, c + <span class="number">1</span>, r, c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现，如果m*n比较大，会经历很重的初始化，而k比较小，优化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">numIslands2v2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span> </span>{</span><br><span class="line">    UnionFind2 uf = <span class="keyword">new</span> UnionFind2();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] position : positions) {</span><br><span class="line">        ans.add(uf.connect(position[<span class="number">0</span>], position[<span class="number">1</span>]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; size;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; help;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind2</span><span class="params">()</span> </span>{</span><br><span class="line">        parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sets = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(String cur)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (!cur.equals(parent.get(cur))) {</span><br><span class="line">            help.add(cur);</span><br><span class="line">            cur = parent.get(cur);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (String str : help) {</span><br><span class="line">            parent.put(str, cur);</span><br><span class="line">        }</span><br><span class="line">        help.clear();</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (parent.containsKey(s1) &amp;&amp; parent.containsKey(s2)) { <span class="comment">// 两个集合都初始化过了</span></span><br><span class="line">            String f1 = find(s1);</span><br><span class="line">            String f2 = find(s2);</span><br><span class="line">            <span class="keyword">if</span> (!f1.equals(f2)) { <span class="comment">// 集合合并</span></span><br><span class="line">                <span class="keyword">int</span> size1 = size.get(f1);</span><br><span class="line">                <span class="keyword">int</span> size2 = size.get(f2);</span><br><span class="line">                String big = size1 &gt;= size2 ? f1 : f2;</span><br><span class="line">                String small = big == f1 ? f2 : f1;</span><br><span class="line">                parent.put(small, big);</span><br><span class="line">                size.put(big, size1 + size2);</span><br><span class="line">                sets--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        String key = String.valueOf(r) + <span class="string">"_"</span> + String.valueOf(c);</span><br><span class="line">        <span class="keyword">if</span> (!parent.containsKey(key)) { <span class="comment">// 已经初始化了</span></span><br><span class="line">            parent.put(key, key); <span class="comment">// 初始化集合，代表节点是自己</span></span><br><span class="line">            size.put(key, <span class="number">1</span>); <span class="comment">// 初始化集合</span></span><br><span class="line">            sets++; <span class="comment">// 集合数量+1</span></span><br><span class="line">            <span class="comment">// 上下左右key</span></span><br><span class="line">            String up = String.valueOf(r - <span class="number">1</span>) + <span class="string">"_"</span> + String.valueOf(c);</span><br><span class="line">            String down = String.valueOf(r + <span class="number">1</span>) + <span class="string">"_"</span> + String.valueOf(c);</span><br><span class="line">            String left = String.valueOf(r) + <span class="string">"_"</span> + String.valueOf(c - <span class="number">1</span>);</span><br><span class="line">            String right = String.valueOf(r) + <span class="string">"_"</span> + String.valueOf(c + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 和上下左右集合合并</span></span><br><span class="line">            union(up, key);</span><br><span class="line">            union(down, key);</span><br><span class="line">            union(left, key);</span><br><span class="line">            union(right, key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。&lt;/p&gt;
&lt;p&gt;并查集主要操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化：把每个点所在集合初始化为其自身。&lt;/li&gt;
&lt;li&gt;查找：查找元素所在的集合，即根节点。&lt;/li&gt;
&lt;li&gt;合并：将两个元素所在的集合合并</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://haifuns.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【Go入门】程序结构</title>
    <link href="https://haifuns.com/2022/08/29/go-structure/"/>
    <id>https://haifuns.com/2022/08/29/go-structure/</id>
    <published>2022-08-29T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：必须以一个字母（Unicode字母）或下划线开头。</p><p>关键字：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="function"><span class="keyword">func</span>     <span class="title">interface</span>   <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></tbody></table></figure><p>预定义名:</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内建常量: <span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">内建类型: <span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line">          <span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line">          <span class="keyword">float32</span> <span class="keyword">float64</span> <span class="keyword">complex128</span> <span class="keyword">complex64</span></span><br><span class="line">          <span class="keyword">bool</span> <span class="keyword">byte</span> <span class="keyword">rune</span> <span class="keyword">string</span> error</span><br><span class="line"></span><br><span class="line">内建函数: <span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line">          <span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line">          <span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></tbody></table></figure><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span> <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> { <span class="comment">// 函数</span></span><br><span class="line">    <span class="keyword">var</span> f = boilingF <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">    fmt.Printf(<span class="string">"boiling point = %g°F or %g°C\n"</span>, f, c)</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// boiling point = 212°F or 100°C</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量声明语法：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式 <span class="comment">// 一般语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> <span class="comment">// 零值初始化机制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时声明一组</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span>                 <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">"four"</span> <span class="comment">// bool, float64, string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短声明，:= 格式，自动类型推导</span></span><br><span class="line">i := <span class="number">100</span> <span class="comment">// int</span></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span> <span class="comment">// 按组简短声明</span></span><br><span class="line"></span><br><span class="line">i, j = j, i <span class="comment">// 交换 i 和 j 的值</span></span><br></pre></td></tr></tbody></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>如果用“var x int”声明语句声明一个 x 变量，那么 <code>&amp;x</code> 表达式（取 x 变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是 <code>*int</code>，指针被称之为“指向 int 类型的指针”。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, *int类型，指向x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 等同于 x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// "2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>) <span class="comment">// "true false false"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">int</span></span> {</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">}</span><br><span class="line">fmt.Println(f() == f()) <span class="comment">// "false"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h2><p>表达式 new(T) 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 *T。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "0"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "2"</span></span><br></pre></td></tr></tbody></table></figure><p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>类型声明方式：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></tbody></table></figure><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><p>对于每一个类型 T，都有一个对应的类型转换操作 T(x)，用于将 x 转为 T 类型（译注：如果 T 是指针类型，可能会需要用小括弧包装 T，比如 (*int)(0)）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。</p><h1 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h1><p>一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。</p><p>每个包都有一个全局唯一的导入路径。除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同。</p><p>如果一个名字是大写字母开头的，那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p><h2 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h2><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> { <span class="comment">/* ... */</span> }</span><br></pre></td></tr></tbody></table></figure><p>init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p><p>包的初始化顺序：全局变量 -&gt; init函数 -&gt; main函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h1&gt;&lt;p&gt;Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：必须以一个字母（Unicode字母）或下划</summary>
      
    
    
    
    <category term="Go" scheme="https://haifuns.com/categories/Go/"/>
    
    
    <category term="Go入门" scheme="https://haifuns.com/tags/Go%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】贪心算法</title>
    <link href="https://haifuns.com/2022/08/28/algorithm-greddy/"/>
    <id>https://haifuns.com/2022/08/28/algorithm-greddy/</id>
    <published>2022-08-28T12:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法的特点：</p><ol><li>最自然智慧的算法</li><li>用一种局部最功利的标准，总是做出在当前看来是最好的选择。</li><li>难点在于证明局部最功利的标准可以得到全局最优解，实际解题过程中不要纠结贪心策略的证明，用对数器去验证贪心策略的正确性</li><li>对于贪心算法的学习主要以增加阅历和经验为主</li></ol><p>堆和排序是贪心算法最常用的两个技巧。</p><h1 id="最小字典序"><a href="#最小字典序" class="headerlink" title="最小字典序"></a>最小字典序</h1><p>给定一个由字符串组成的数组strs，把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (a + b).compareTo(b + a); <span class="comment">// 不能直接a.comareTo(b)，e.g. a=b，b=ba，得到bba，正确结果bab</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> MyComparator());</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) {</span><br><span class="line">        res += strs[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="会议室最多宣讲场次"><a href="#会议室最多宣讲场次" class="headerlink" title="会议室最多宣讲场次"></a>会议室最多宣讲场次</h1><p>一些项目想要占用一个会议室宣讲，会议室同一时间只能容纳一个宣讲，给定每个项目宣讲的开始时间和结束时间，要求合理安排宣讲日程使得会议室进行的宣讲场次最多，返回最多的宣讲场次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议的开始时间和结束时间，都是数值，不会 &lt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange</span><span class="params">(Program[] programs)</span> </span>{</span><br><span class="line">    Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line">    <span class="keyword">int</span> timeLine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次遍历每一个会议，结束时间早的会议先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (timeLine &lt;= programs[i].start) {</span><br><span class="line">            result++;</span><br><span class="line">            timeLine = programs[i].end;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="最小代价分金（哈夫曼编码问题）"><a href="#最小代价分金（哈夫曼编码问题）" class="headerlink" title="最小代价分金（哈夫曼编码问题）"></a>最小代价分金（哈夫曼编码问题）</h1><p>一块金条切成两半，需要花费和长度相同的铜板。如果长度为20的金条不管怎么切都要花费20个铜板。</p><p>例如：给定数组{10,20,30}，表示一共三个人，整块金条长度为60，金条想要分成10，20，30三个部分。</p><p>如果先把长度60的金条分成10和50，花费60；再把50分为20和30花费50，总花费110。<br>如果先把长度60的金条分为30和30，花费60；再把30分为10和20花费30，总花费90。</p><p>一群人想要整分整块金条，怎么分割代价最小？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessMoney</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        pQ.add(arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) {</span><br><span class="line">        cur = pQ.poll() + pQ.poll(); <span class="comment">// 每次取出最小的两个数</span></span><br><span class="line">        sum += cur;</span><br><span class="line">        pQ.add(cur); <span class="comment">// 加起来后放回小根堆</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 直到堆里只剩两个数，返回和</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="项目安排最大利润"><a href="#项目安排最大利润" class="headerlink" title="项目安排最大利润"></a>项目安排最大利润</h1><p>输入：正数数组costs、正数数组profits、正数K、正数M</p><ul><li>costs[i] 表示 i 号项目的花费</li><li>profits[i] 表示 i 号项目在扣除花费之后的利润</li><li>K 表示最多能串行的做 K 个项目</li><li>W 表示初始资金</li></ul><p>说明：每做完一个项目，马上就能获得收益，可以支持去做下一个项目。不能并行做项目。</p><p>要求：输出可以获得的最大钱数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> W, <span class="keyword">int</span>[] Profits, <span class="keyword">int</span>[] Capital)</span> </span>{</span><br><span class="line">    <span class="comment">// 小根堆，按花费排序</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; minCostQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">    <span class="comment">// 大根堆，按利润排序</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; maxProfitQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Profits.length; i++) {</span><br><span class="line">        minCostQ.add(<span class="keyword">new</span> Program(Profits[i], Capital[i]));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) {</span><br><span class="line">        <span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) {</span><br><span class="line">            maxProfitQ.add(minCostQ.poll()); <span class="comment">// 当前资金所有可以做的项目，加入利润大根堆</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (maxProfitQ.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> W;</span><br><span class="line">        }</span><br><span class="line">        W += maxProfitQ.poll().p; <span class="comment">// 选择利润最大的项目，剩余资金=初始+利润</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p; <span class="comment">// 利润</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> c; <span class="comment">// 花费</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.c - o2.c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o2.p - o1.p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="点灯问题"><a href="#点灯问题" class="headerlink" title="点灯问题"></a>点灯问题</h1><p>给定一个字符串str，只由 ‘X’ 和 ‘.’ 两种字符构成。</p><ul><li>‘X’ 表示墙，不能放灯也不需要点亮</li><li>‘.’ 表示民居，可以放灯，需要点亮</li></ul><p>如果灯放在 i 位置，可以让 i-1，i 和 i+1 三个位置被点亮。</p><p>要求返回如果点亮str中所有需要点亮的位置，至少需要几盏灯？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minLight</span><span class="params">(String road)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] str = road.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> light = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.length) {</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'X'</span>) {</span><br><span class="line">            i++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            light++;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == str.length) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// i+1位置 X .</span></span><br><span class="line">                <span class="keyword">if</span> (str[i + <span class="number">1</span>] == <span class="string">'X'</span>) {</span><br><span class="line">                    i = i + <span class="number">2</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    i = i + <span class="number">3</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> light;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;贪心算法的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最自然智慧的算法&lt;/li&gt;
&lt;li&gt;用一种局部最功利的标准，总是做出在当前看来是最好的选择。&lt;/li&gt;
&lt;li&gt;难点在于证明局部最功利的标准可以得到全局最优解，实际解题过程中不要纠结贪心策略的证明，用对数器去验证贪心策略的正确性&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心算法" scheme="https://haifuns.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】二叉树专练（二）</title>
    <link href="https://haifuns.com/2022/08/16/algorithm-binarytree-problem2/"/>
    <id>https://haifuns.com/2022/08/16/algorithm-binarytree-problem2/</id>
    <published>2022-08-16T15:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的递归套路（重要）"><a href="#二叉树的递归套路（重要）" class="headerlink" title="二叉树的递归套路（重要）"></a>二叉树的递归套路（重要）</h1><ol><li>假设以X节点为头，可以向X左树和X右树要任何信息</li><li>在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（最重要）</li><li>列出所有可能性后，确定到底需要向左树和右树要什么信息</li><li>把左树信息和右树信息求全集，就是任何一棵子树都要返回的信息S</li><li>递归函数对于每棵子树都要返回S</li><li>在代码中考虑如何利用左树信息和右树信息整合出整棵树的信息</li></ol><h1 id="1-判断二叉树是否是平衡二叉树"><a href="#1-判断二叉树是否是平衡二叉树" class="headerlink" title="1.判断二叉树是否是平衡二叉树"></a>1.判断二叉树是否是平衡二叉树</h1><p>平衡树(Balance Tree)：任意节点的子树的高度差都小于等于1。</p><p>解题思路：</p><p>对于任意节点x，满足：</p><ol><li>x左树平衡</li><li>x右树平衡</li><li>|x左树高度 - x右树高度| &lt; 2</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(head).isBalanced;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">        isBalanced = i;</span><br><span class="line">        height = h;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>; <span class="comment">// 当前节点高度</span></span><br><span class="line">    <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!leftInfo.isBalanced) { <span class="comment">// 左树不平</span></span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!rightInfo.isBalanced) { <span class="comment">// 右树不平</span></span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) { <span class="comment">// 左右高度差 &gt; 1</span></span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-判断二叉树是否是搜索二叉树"><a href="#2-判断二叉树是否是搜索二叉树" class="headerlink" title="2.判断二叉树是否是搜索二叉树"></a>2.判断二叉树是否是搜索二叉树</h1><p>二叉查找树(Binary Search Tree)：每一棵子树均满足左树比头节点小，右树比头节点大。</p><p>解题思路：</p><p>对于任意节点x，满足：</p><ol><li>x左树是否是搜索二叉树</li><li>x右树是否是搜索二叉树</li><li>x左树最大值 &lt; x右树最小值</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(head).isBST;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>{</span><br><span class="line">        isBST = i;</span><br><span class="line">        max = ma;</span><br><span class="line">        min = mi;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="keyword">int</span> max = x.value;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) {</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) {</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> min = x.value;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) {</span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) {</span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> isBST = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; !leftInfo.isBST) {</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; !rightInfo.isBST) {</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.max &gt;= x.value) {</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; rightInfo.min &lt;= x.value) {</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBST, max, min);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-判断二叉树是否是完全二叉树"><a href="#3-判断二叉树是否是完全二叉树" class="headerlink" title="3.判断二叉树是否是完全二叉树"></a>3.判断二叉树是否是完全二叉树</h1><p>完全二叉树(Complete Binary Tree)：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。<br>满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。</p><p>解题思路：</p><p>非递归实现，按层遍历，每个节点判断：</p><ol><li>有右子节点没有左子节点直接判断不是完全二叉树</li><li>如果存在一个节点不完全（有左无右），后续节点如果有子节点，直接判断不是完全二叉树</li></ol><p>递归实现，对于节点x满足完全二叉树有以下四种情况：</p><ol><li>左树满，右树满，左树高度 == 右树高度</li><li>左树完全，右树满，左树高度 == 右树高度 + 1</li><li>左树满，右树满，左树高度 == 右树高度 + 1</li><li>左树满，右树完全，左树高度 == 右树高度</li></ol><p>合并，递归实现对于每个节点需要：</p><ol><li>是否是满二叉树</li><li>是否是完全二叉树</li><li>高度</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按层遍历实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 是否遇到过左右两个孩子不双全的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span></span><br><span class="line">            (leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>))</span><br><span class="line">            ||</span><br><span class="line">            (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">        ) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(l);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(r);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) {</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(head).isCBT;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每一棵子树，是否是满二叉树、是否是完全二叉树、高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isCBT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> full, <span class="keyword">boolean</span> cbt, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">        isFull = full;</span><br><span class="line">        isCBT = cbt;</span><br><span class="line">        height = h;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isFull = leftInfo.isFull</span><br><span class="line">                     &amp;&amp;</span><br><span class="line">                     rightInfo.isFull</span><br><span class="line">                     &amp;&amp; leftInfo.height == rightInfo.height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isCBT = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFull) {</span><br><span class="line">        isCBT = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 以x为头整棵树，不满</span></span><br><span class="line">        <span class="keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isCBT</span><br><span class="line">                    &amp;&amp; rightInfo.isFull</span><br><span class="line">                    &amp;&amp; leftInfo.height == rightInfo.height + <span class="number">1</span>) {</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isFull</span><br><span class="line">                    &amp;&amp;</span><br><span class="line">                    rightInfo.isFull</span><br><span class="line">                    &amp;&amp; leftInfo.height == rightInfo.height + <span class="number">1</span>) {</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isFull</span><br><span class="line">                    &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) {</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isFull, isCBT, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-二叉树最大距离"><a href="#4-二叉树最大距离" class="headerlink" title="4.二叉树最大距离"></a>4.二叉树最大距离</h1><p>节点距离：用最精简的走法从一个节点走到另一个节点经过的节点数（包含开始结束节点）</p><p>对于节点x最大距离有三种可能性，其中最大值即x最大距离：</p><ol><li>x左树最大距离</li><li>x右树最大距离</li><li>x左树与x最远（左树高度） + x右树与x最远（x右树高度） + 1</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(head).maxDistance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxDistance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">        maxDistance = m;</span><br><span class="line">        height = h;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = leftInfo.maxDistance;</span><br><span class="line">    <span class="keyword">int</span> p2 = rightInfo.maxDistance;</span><br><span class="line">    <span class="keyword">int</span> p3 = leftInfo.height + rightInfo.height + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxDistance = Math.max(Math.max(p1, p2), p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(maxDistance, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-判断二叉树是否是满二叉树"><a href="#5-判断二叉树是否是满二叉树" class="headerlink" title="5.判断二叉树是否是满二叉树"></a>5.判断二叉树是否是满二叉树</h1><p>满二叉树：二叉树每一个层的节点数都达到最大值，也就是说，如果二叉树的高度为 h，则结点总数是 2^h - 1。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现，第一种方法</span></span><br><span class="line"><span class="comment">// 收集整棵树的高度h，节点数n</span></span><br><span class="line"><span class="comment">// 2 ^ h - 1 == n -&gt; 整棵树是满的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFull1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Info1 all = process1(head);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; all.height) - <span class="number">1</span> == all.nodes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info1</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info1</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        height = h;</span><br><span class="line">        nodes = n;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info1 <span class="title">process1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info1(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    Info1 leftInfo = process1(head.left);</span><br><span class="line">    Info1 rightInfo = process1(head.right);</span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info1(height, nodes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现，第二种方法</span></span><br><span class="line"><span class="comment">// 收集子树是否是满二叉树，子树的高度</span></span><br><span class="line"><span class="comment">// 左树满 &amp;&amp; 右树满 &amp;&amp; 左右树高度一样 -&gt; 整棵树是满的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFull2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process2(head).isFull;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info2</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info2</span><span class="params">(<span class="keyword">boolean</span> f, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">        isFull = f;</span><br><span class="line">        height = h;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info2 <span class="title">process2</span><span class="params">(Node h)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info2(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    Info2 leftInfo = process2(h.left);</span><br><span class="line">    Info2 rightInfo = process2(h.right);</span><br><span class="line">    <span class="keyword">boolean</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;</span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info2(isFull, height);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="6-最大搜索二叉子树大小（LeetCode-333-）"><a href="#6-最大搜索二叉子树大小（LeetCode-333-）" class="headerlink" title="6.最大搜索二叉子树大小（LeetCode 333.）"></a>6.最大搜索二叉子树大小（LeetCode 333.）</h1><p>要求找到给定二叉树中所有BST子树节点数最大的子树。</p><p>对于任意节点x，要得到maxBSTSize，解题思路：</p><p>如果x不做头，需要比较：</p><ol><li>x左树maxBSTSize</li><li>x右树maxBSTSize</li></ol><p>如果x做头，需要判断：</p><ol><li>左树是否是BST</li><li>右树是否是BST</li><li>左树最大值 &lt; x</li><li>右树最小值 &gt; x</li><li>左树size + 右树size + 1</li></ol><p>合并，递归实现对于每个节点需要：</p><ol><li>maxBSTSize，当前子树最大搜索二叉子树大小</li><li>max，当前子树中最大值</li><li>min，当前子树中最小值</li><li>size，当前子树节点数（maxBSTSize == size，子树本身是BST）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestBSTSubtree</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(head).maxBSTSubtreeSize;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxBSTSubtreeSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> allSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>{</span><br><span class="line">        maxBSTSubtreeSize = m;</span><br><span class="line">        allSize = a;</span><br><span class="line">        max = ma;</span><br><span class="line">        min = mi;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="keyword">int</span> max = x.val;</span><br><span class="line">    <span class="keyword">int</span> min = x.val;</span><br><span class="line">    <span class="keyword">int</span> allSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) {</span><br><span class="line">        max = Math.max(leftInfo.max, max);</span><br><span class="line">        min = Math.min(leftInfo.min, min);</span><br><span class="line">        allSize += leftInfo.allSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) {</span><br><span class="line">        max = Math.max(rightInfo.max, max);</span><br><span class="line">        min = Math.min(rightInfo.min, min);</span><br><span class="line">        allSize += rightInfo.allSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p1 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) {</span><br><span class="line">        p1 = leftInfo.maxBSTSubtreeSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p2 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) {</span><br><span class="line">        p2 = rightInfo.maxBSTSubtreeSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> p3 = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左子树是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">boolean</span> leftBST = leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.maxBSTSubtreeSize == leftInfo.allSize);</span><br><span class="line">    <span class="comment">// 右子树是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">boolean</span> rightBST = rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (rightInfo.maxBSTSubtreeSize == rightInfo.allSize);</span><br><span class="line">    <span class="keyword">if</span> (leftBST &amp;&amp; rightBST) {</span><br><span class="line">        <span class="keyword">boolean</span> leftMaxLessX = leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.max &lt; x.val);</span><br><span class="line">        <span class="keyword">boolean</span> rightMinMoreX = rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (x.val &lt; rightInfo.min);</span><br><span class="line">        <span class="keyword">if</span> (leftMaxLessX &amp;&amp; rightMinMoreX) { <span class="comment">// 当前树是搜索二叉树</span></span><br><span class="line">            <span class="keyword">int</span> leftSize = leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.allSize;</span><br><span class="line">            <span class="keyword">int</span> rightSize = rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.allSize;</span><br><span class="line">            p3 = leftSize + rightSize + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(Math.max(p1, Math.max(p2, p3)), allSize, max, min);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="7-最大搜索二叉子树头结点"><a href="#7-最大搜索二叉子树头结点" class="headerlink" title="7.最大搜索二叉子树头结点"></a>7.最大搜索二叉子树头结点</h1><p>此题是上一题的变种，要求找到给定二叉树中所有BST子树节点数最大的子树的头结点。</p><p>对于任意节点x，要得到maxBSTHead，解题思路：</p><p>如果x不做头，需要比较maxBSTSize得到maxBSTHead：</p><ol><li>x左树maxBSTSize，maxBSTHead</li><li>x右树maxBSTSize，maxBSTHead</li></ol><p>如果x做头，需要判断：</p><ol><li>左树是否是BST</li><li>右树是否是BST</li><li>左树最大值 &lt; x</li><li>右树最小值 &gt; x</li><li>左树size + 右树size + 1</li></ol><p>合并，递归实现对于每个节点需要：</p><ol><li>maxBSTSize，当前子树最大搜索二叉子树大小</li><li>max，当前子树中最大值</li><li>min，当前子树中最小值</li><li>maxSubBSTHead，最大搜索子树头节点（maxSubBSTHead == x.left/right，子树本身是BST）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">maxSubBSTHead</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(head).maxSubBSTHead;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Node maxSubBSTHead;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxSubBSTSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(Node h, <span class="keyword">int</span> size, <span class="keyword">int</span> mi, <span class="keyword">int</span> ma)</span> </span>{</span><br><span class="line">        maxSubBSTHead = h;</span><br><span class="line">        maxSubBSTSize = size;</span><br><span class="line">        min = mi;</span><br><span class="line">        max = ma;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);</span><br><span class="line">    <span class="keyword">int</span> min = X.value;</span><br><span class="line">    <span class="keyword">int</span> max = X.value;</span><br><span class="line">    Node maxSubBSTHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSubBSTSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) {</span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">        maxSubBSTHead = leftInfo.maxSubBSTHead;</span><br><span class="line">        maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) {</span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">        <span class="keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) {</span><br><span class="line">            maxSubBSTHead = rightInfo.maxSubBSTHead;</span><br><span class="line">            maxSubBSTSize = rightInfo.maxSubBSTSize;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.maxSubBSTHead == X.left &amp;&amp; leftInfo.max &lt; X.value))</span><br><span class="line">            &amp;&amp; (rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (rightInfo.maxSubBSTHead == X.right &amp;&amp; rightInfo.min &gt; X.value))) {</span><br><span class="line">        maxSubBSTHead = X;</span><br><span class="line">        maxSubBSTSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize)</span><br><span class="line">                        + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="8-二叉树任意两节点最低公共祖先"><a href="#8-二叉树任意两节点最低公共祖先" class="headerlink" title="8.二叉树任意两节点最低公共祖先"></a>8.二叉树任意两节点最低公共祖先</h1><p>给定一棵二叉树的头结点head，以及另外两个节点a和b，要求返回a和b的最低公共祖先。</p><p>解题思路：</p><p>递归套路情况分析：</p><p>与x无关，x不是最低汇聚点：</p><ol><li>左树上汇聚</li><li>右树上汇聚</li><li>a，b不全</li></ol><p>与x有关，x是汇聚点：</p><ol><li>a，b分别在左右树</li><li>x本身就是a，b在左树或右树</li><li>x本身就是b，a在左树或右树</li></ol><p>合并，递归实现对于每个节点需要：</p><ol><li>是否发现a</li><li>是否发现b</li><li>是否是汇聚点</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestAncestor</span><span class="params">(Node head, Node a, Node b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(head, a, b).ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> findA;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> findB;</span><br><span class="line">    <span class="keyword">public</span> Node ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> fA, <span class="keyword">boolean</span> fB, Node an)</span> </span>{</span><br><span class="line">        findA = fA;</span><br><span class="line">        findB = fB;</span><br><span class="line">        ans = an;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x, Node a, Node b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    Info leftInfo = process(x.left, a, b);</span><br><span class="line">    Info rightInfo = process(x.right, a, b);</span><br><span class="line">    <span class="keyword">boolean</span> findA = (x == a) || leftInfo.findA || rightInfo.findA;</span><br><span class="line">    <span class="keyword">boolean</span> findB = (x == b) || leftInfo.findB || rightInfo.findB;</span><br><span class="line">    Node ans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo.ans != <span class="keyword">null</span>) {</span><br><span class="line">        ans = leftInfo.ans;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (rightInfo.ans != <span class="keyword">null</span>) {</span><br><span class="line">        ans = rightInfo.ans;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (findA &amp;&amp; findB) {</span><br><span class="line">            ans = x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(findA, findB, ans);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="9-派对的最大快乐值"><a href="#9-派对的最大快乐值" class="headerlink" title="9.派对的最大快乐值"></a>9.派对的最大快乐值</h1><p>在全公司中邀请员工参加派对，每个员工能带来的快乐值不一，在不能同时邀请直属上下级的情况下，返回整个派对能获得的最大快乐值。</p><p>员工定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">// 当前员工可以带来的快乐值</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; nexts; <span class="comment">// 当前员工直属下级</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题目分析：</p><ol><li>公司员工本身是一棵多叉树</li><li>从多叉树中挑选节点</li><li>不能同时选择父子节点</li><li>要求挑选节点累加值最大</li></ol><p>递归套路，解题思路：</p><p>对于任意节点x：</p><ul><li>如果选择x，x 最大累加值 = x.happy + sum(x 每一个子节点不被选择的最大累加值)</li><li>如果不选择x，x 最大累计值 = 0 + sum(max(x 每一个子节点被选择的最大累加值, x 每一个子节点不被选择的最大累加值))</li></ul><p>合并，对于每个节点需要以下信息：</p><ol><li>选择当前节点的最大累加值</li><li>不选择当前节点的最大累加值</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy</span><span class="params">(Employee head)</span> </span>{</span><br><span class="line">    Info allInfo = process(head);</span><br><span class="line">    <span class="keyword">return</span> Math.max(allInfo.no, allInfo.yes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> yes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">        no = n;</span><br><span class="line">        yes = y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Employee x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yes = x.happy;</span><br><span class="line">    <span class="keyword">for</span> (Employee next : x.nexts) {</span><br><span class="line">        Info nextInfo = process(next);</span><br><span class="line">        no += Math.max(nextInfo.no, nextInfo.yes);</span><br><span class="line">        yes += nextInfo.no;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(no, yes);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的递归套路（重要）&quot;&gt;&lt;a href=&quot;#二叉树的递归套路（重要）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的递归套路（重要）&quot;&gt;&lt;/a&gt;二叉树的递归套路（重要）&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;假设以X节点为头，可以向X左树和X右树要任何信息</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://haifuns.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】二叉树专练（一）</title>
    <link href="https://haifuns.com/2022/07/30/algorithm-binarytree-problem1/"/>
    <id>https://haifuns.com/2022/07/30/algorithm-binarytree-problem1/</id>
    <published>2022-07-30T15:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-将-N-叉树编码为二叉树（LeetCode-431-hard）"><a href="#1-将-N-叉树编码为二叉树（LeetCode-431-hard）" class="headerlink" title="1.将 N 叉树编码为二叉树（LeetCode 431. hard）"></a>1.将 N 叉树编码为二叉树（LeetCode 431. hard）</h1><p>设计一个算法，可以将 N 叉树编码为二叉树，并能将该二叉树解码为原 N 叉树。</p><p>解题思路：对于任意节点a，将其所有子节点放在左子树的右边界上。如下图所示：</p><p><img src="https://img.haifuns.com/md/img/EncodeNaryTreeToBinaryTree.png" alt="image"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>{</span><br><span class="line">        val = _val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>{</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) {</span><br><span class="line">        val = x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>{</span><br><span class="line">    <span class="comment">// N叉树编码为二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">encode</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(root.val);</span><br><span class="line">        head.left = en(root.children);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">en</span><span class="params">(List&lt;Node&gt; children)</span> </span>{</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : children) {</span><br><span class="line">            TreeNode tNode = <span class="keyword">new</span> TreeNode(child.val);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">                head = tNode; <span class="comment">// 第一个子节点</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur.right = tNode; <span class="comment">// 同级节点在右边界串联</span></span><br><span class="line">            }</span><br><span class="line">            cur = tNode;</span><br><span class="line">            cur.left = en(child.children); <span class="comment">// 深度优先，同级节点经过右边界串联后挂在父节点左子节点上</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树解码为N叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">decode</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(root.val, de(root.left));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">de</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;Node&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) {</span><br><span class="line">            Node cur = <span class="keyword">new</span> Node(root.val, de(root.left)); <span class="comment">// 深度优先</span></span><br><span class="line">            children.add(cur); <span class="comment">// 汇总所有右边界上的同级子节点</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-求二叉树最宽的层有多少个节点"><a href="#2-求二叉树最宽的层有多少个节点" class="headerlink" title="2.求二叉树最宽的层有多少个节点"></a>2.求二叉树最宽的层有多少个节点</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用容器，表记录节点层数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">    Map&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前正在统计哪一层的宽度，层数</span></span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">            levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">            levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (curNodeLevel == curLevel) {</span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevel++;</span><br><span class="line">            curLevelNodes = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    max = Math.max(max, curLevelNodes);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    Node curEnd = head; <span class="comment">// 当前层，最右节点</span></span><br><span class="line">    Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            nextEnd = cur.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            nextEnd = cur.right;</span><br><span class="line">        }</span><br><span class="line">        curLevelNodes++;</span><br><span class="line">        <span class="keyword">if</span> (cur == curEnd) {</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevelNodes = <span class="number">0</span>;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-找到二叉树的后继节点"><a href="#3-找到二叉树的后继节点" class="headerlink" title="3.找到二叉树的后继节点"></a>3.找到二叉树的后继节点</h1><p>二叉树结构定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要求给定一个二叉树节点，返回此节点的后继节点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) { <span class="comment">// 有右子树</span></span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right); <span class="comment">// 找右子树中最左的节点</span></span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 无右子树</span></span><br><span class="line">        Node parent = node.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right == node) { <span class="comment">// 当前节点是其父亲节点右孩子</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        } <span class="comment">// 结束时，父节点为空，或者当前节点是父节点的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) {</span><br><span class="line">        node = node.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-打印纸条折痕问题"><a href="#4-打印纸条折痕问题" class="headerlink" title="4.打印纸条折痕问题"></a>4.打印纸条折痕问题</h1><p>请把一张纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向。</p><p>解题思路：实际折一下，每次对折后给新折痕上标记是第几次对折以及是凹还是凸。<br>模拟对折几次可以发现，每次对折都是在上一次的每条折痕前新增一条凹折痕，后新增一条凸折痕，形成一个二叉树，折痕的打印即二叉树中序遍历。<br>如下图所示：</p><p><img src="https://img.haifuns.com/md/img/BinaryTree_PaperFolding.png" alt="image"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">    process(<span class="number">1</span>, N, <span class="keyword">true</span>); <span class="comment">// 根节点是凹痕</span></span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序打印整棵树，i是当前层，N是总层数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">true</span>); <span class="comment">// 左节点凹痕</span></span><br><span class="line">    System.out.print(down ? <span class="string">"凹 "</span> : <span class="string">"凸 "</span>);</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">false</span>); <span class="comment">// 右节点凸痕</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-将-N-叉树编码为二叉树（LeetCode-431-hard）&quot;&gt;&lt;a href=&quot;#1-将-N-叉树编码为二叉树（LeetCode-431-hard）&quot; class=&quot;headerlink&quot; title=&quot;1.将 N 叉树编码为二叉树（LeetCode 43</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://haifuns.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】二叉树</title>
    <link href="https://haifuns.com/2022/07/30/algorithm-binarytree/"/>
    <id>https://haifuns.com/2022/07/30/algorithm-binarytree/</id>
    <published>2022-07-30T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。</p><p>二叉树节点结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><ul><li>先序遍历：任何子树的处理顺序都是先头结点、再左子树、然后右子树</li><li>中序遍历：任何子树的处理顺序都是先左子树、再头结点、然后右子树</li><li>后序遍历：任何子树的处理顺序都是先左子树、再右子树、然后头结点</li></ul><p>三种遍历方式本质上都是递归序，先序、中序、后序都是在递归序的基础上加工而来。<br>递归序中每个节点总能到达三次，第一次到达一个节点就打印就是先序、第二次打印是中序、第三次打印是后序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    pre(head.left);</span><br><span class="line">    pre(head.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    in(head.left);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    in(head.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    pos(head.left);</span><br><span class="line">    pos(head.right);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">public</span> Node left;</span><br><span class="line">  <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">    value = v;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈实现先序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">  <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">      head = stack.pop(); <span class="comment">// 弹出最左</span></span><br><span class="line">      System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">      <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) { <span class="comment">// 先压入右子节点，后压入左子节点</span></span><br><span class="line">        stack.push(head.right);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(head.left);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈实现中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node cur)</span> </span>{</span><br><span class="line">  System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">  <span class="keyword">if</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">if</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(cur); <span class="comment">// 以cur为头的数整条左边界入栈，直到遇到空</span></span><br><span class="line">        cur = cur.left;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        cur = stack.pop(); <span class="comment">// 弹出节点打印，弹出节点右孩子设置为cur</span></span><br><span class="line">        System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个栈实现后序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">  <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">    Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;(); <span class="comment">// 先类似先序实现头右左</span></span><br><span class="line">    Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;(); <span class="comment">// 不打印，栈1压入栈2，得到左右头</span></span><br><span class="line">    s1.push(head);</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty()) {</span><br><span class="line">      head = s1.pop(); <span class="comment">// 头 右 左</span></span><br><span class="line">      s2.push(head);</span><br><span class="line">      <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) {</span><br><span class="line">        s1.push(head.left);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) {</span><br><span class="line">        s1.push(head.right);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 左 右 头</span></span><br><span class="line">    <span class="keyword">while</span> (!s2.isEmpty()) {</span><br><span class="line">      System.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个栈实现后序，hard，了解即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos2</span><span class="params">(Node h)</span> </span>{</span><br><span class="line">  System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">  <span class="keyword">if</span> (h != <span class="keyword">null</span>) {</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(h);</span><br><span class="line">    Node c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">      c = stack.peek();</span><br><span class="line">      <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) {</span><br><span class="line">        stack.push(c.left);</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; h != c.right) {</span><br><span class="line">        stack.push(c.right);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">        h = c;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  System.out.println();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h1><ol><li>实际上就是宽度优先遍历，使用队列实现</li><li>可以通过设置flag变量的方式来发现某一层的结束<a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的按层遍历</a></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">level</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(head); <span class="comment">// 压入头节点</span></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">    Node cur = queue.poll(); <span class="comment">// 弹出一个节点</span></span><br><span class="line">    System.out.println(cur.value);</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) {</span><br><span class="line">      queue.add(cur.left); <span class="comment">// 有左节点压入</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) {</span><br><span class="line">      queue.add(cur.right); <span class="comment">// 有右节点压入</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="实现二叉树的序列化和反序列化"><a href="#实现二叉树的序列化和反序列化" class="headerlink" title="实现二叉树的序列化和反序列化"></a>实现二叉树的序列化和反序列化</h1><ol><li>先序/后序方式序列化和反序列化</li><li>按层方式序列化和反序列化</li></ol><p>二叉树无法通过中序遍历的方式实现序列化和反序列化，因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。<br>比如如下两棵树：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  __2</span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line">和</span><br><span class="line">1__</span><br><span class="line">   \</span><br><span class="line">    2</span><br></pre></td></tr></tbody></table></figure><p>补足空位置的中序遍历结果都是{null, 1, null, 2, null}。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">preSerial</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  pres(head, ans);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pres</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">    ans.add(<span class="keyword">null</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    ans.add(String.valueOf(head.value));</span><br><span class="line">    pres(head.left, ans);</span><br><span class="line">    pres(head.right, ans);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPreQueue</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (prelist == <span class="keyword">null</span> || prelist.size() == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> preb(prelist);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">preb</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>{</span><br><span class="line">  String value = prelist.poll();</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">  head.left = preb(prelist);</span><br><span class="line">  head.right = preb(prelist);</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">posSerial</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  poss(head, ans);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poss</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">    ans.add(<span class="keyword">null</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    poss(head.left, ans);</span><br><span class="line">    poss(head.right, ans);</span><br><span class="line">    ans.add(String.valueOf(head.value));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPosQueue</span><span class="params">(Queue&lt;String&gt; poslist)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (poslist == <span class="keyword">null</span> || poslist.size() == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 左右中 -&gt; stack(中右左)</span></span><br><span class="line">  Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (!poslist.isEmpty()) {</span><br><span class="line">    stack.push(poslist.poll());</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> posb(stack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">posb</span><span class="params">(Stack&lt;String&gt; posstack)</span> </span>{</span><br><span class="line">  String value = posstack.pop();</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">  head.right = posb(posstack);</span><br><span class="line">  head.left = posb(posstack);</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按层序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">levelSerial</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">  Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">    ans.add(<span class="keyword">null</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    ans.add(String.valueOf(head.value));</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">      head = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) { <span class="comment">// 左子节点，不管是不是空都序列化，不为空放到队列</span></span><br><span class="line">        ans.add(String.valueOf(head.left.value));</span><br><span class="line">        queue.add(head.left);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        ans.add(<span class="keyword">null</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) { <span class="comment">// 右节点一样序列化， 不为空放到队列</span></span><br><span class="line">        ans.add(String.valueOf(head.right.value));</span><br><span class="line">        queue.add(head.right);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        ans.add(<span class="keyword">null</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按层反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByLevelQueue</span><span class="params">(Queue&lt;String&gt; levelList)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (levelList == <span class="keyword">null</span> || levelList.size() == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  Node head = generateNode(levelList.poll());</span><br><span class="line">  Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;(); <span class="comment">// 类似序列化步骤，用队列遍历</span></span><br><span class="line">  <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">    queue.add(head);</span><br><span class="line">  }</span><br><span class="line">  Node node = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">    node = queue.poll();</span><br><span class="line">    node.left = generateNode(levelList.poll());</span><br><span class="line">    node.right = generateNode(levelList.poll());</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) { <span class="comment">// 不为空放到队列</span></span><br><span class="line">      queue.add(node.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">      queue.add(node.right);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNode</span><span class="params">(String val)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (val == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="工具函数：打印二叉树"><a href="#工具函数：打印二叉树" class="headerlink" title="工具函数：打印二叉树"></a>工具函数：打印二叉树</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转90度打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">    printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">    String val = to + head.value + to;</span><br><span class="line">    <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">    <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">    val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height * len) + val);</span><br><span class="line">    printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    String space = <span class="string">" "</span>;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {</span><br><span class="line">        buf.append(space);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。&lt;/p&gt;
&lt;p&gt;二叉树节点结构</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://haifuns.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【排查经验】记一次mysql index_merge引发的死锁分析</title>
    <link href="https://haifuns.com/2022/07/26/mysql-fixdeadlock/"/>
    <id>https://haifuns.com/2022/07/26/mysql-fixdeadlock/</id>
    <published>2022-07-26T10:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中涉及公司业务信息已脱敏。</p></blockquote><p>在项目监控中观察到偶现数据库死锁异常，报错如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</span><br><span class="line">    at com.mysql.jdbc.Util.handleNewInstance(Util.java:400)</span><br><span class="line">    at com.mysql.jdbc.Util.getInstance(Util.java:383)</span><br><span class="line">    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:987)</span><br><span class="line">    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3847)</span><br><span class="line">    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3783)</span><br><span class="line">    at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2447)</span><br><span class="line">    at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2594)</span><br><span class="line">    at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2545)</span><br><span class="line">    at com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:1901)</span><br><span class="line">    at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2113)</span><br><span class="line">    at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2049)</span><br><span class="line">    at com.mysql.jdbc.PreparedStatement.executeUpdate(PreparedStatement.java:2034)</span><br></pre></td></tr></tbody></table></figure><p>涉及表信息如下（演示表）：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_table` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'自增id'</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'用户id'</span>,</span><br><span class="line">  `class_id` <span class="type">int</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'课程id'</span>,</span><br><span class="line">  `is_deleted` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'是否删除'</span>,</span><br><span class="line">  `add_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `mod_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_user_id` (`user_id`),</span><br><span class="line">  KEY `idx_class_id` (`class_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><h1 id="死锁日志分析"><a href="#死锁日志分析" class="headerlink" title="死锁日志分析"></a>死锁日志分析</h1><p>从RDS中拿到了死锁日志如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2022-07-19 10:10:22 0x7f269177f700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1017957458, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 3, locked 3</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 3 row lock(s)</span><br><span class="line">MySQL thread id 13133017, OS thread handle 139806311954176, query id 2776903298 10.**.**.179 k**_base_oniv updating</span><br><span class="line">/*id:182a***d*//*ip=10.**.**.179*/update test_table</span><br><span class="line">     SET is_deleted = 1,</span><br><span class="line">        mod_time = '2022-07-19 10:10:22.861' </span><br><span class="line">     WHERE (  user_id = 1548612299617681421</span><br><span class="line">                  and class_id = 1470379</span><br><span class="line">                  and is_deleted = 0 )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 883 page no 6297 n bits 1000 index idx_class_id of table `test_db`.`test_table` trx id 1017957458 lock_mode X waiting</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1017957457, ACTIVE 0 sec fetching rows</span><br><span class="line">mysql tables in use 3, locked 3</span><br><span class="line">83 lock struct(s), heap size 8400, 669 row lock(s)</span><br><span class="line">MySQL thread id 13116419, OS thread handle 139803626043136, query id 2776903296 10.**.**.178 k**_base_oniv updating</span><br><span class="line">/*id:182a***d*//*ip=10.**.**.178*/update test_table</span><br><span class="line">     SET is_deleted = 1,</span><br><span class="line">        mod_time = '2022-07-19 10:10:22.861' </span><br><span class="line">     WHERE (  user_id = 1548831949420961886</span><br><span class="line">                  and class_id = 1470379</span><br><span class="line">                  and is_deleted = 0 )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 883 page no 6297 n bits 1000 index idx_class_id of table `test_db`.`test_table` trx id 1017957457 lock_mode X</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 883 page no 8596 n bits 152 index PRIMARY of table `test_db`.`test_table` trx id 1017957457 lock_mode X locks rec but not gap waiting</span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></tbody></table></figure><p>从日志中可以看到死锁发生时间，导致死锁的事务信息，每个事务正在执行的sql，等待锁、持有锁等信息。</p><p>下面逐段对日志进行详细分析：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1017957458, ACTIVE 0 sec starting index read</span><br></pre></td></tr></tbody></table></figure><ul><li>1017957458 是第一个事务的 id。</li><li>ACTIVE 0 sec 表示事务活动时间。</li><li>starting index read 表示事务当前状态，这里表示正在读索引；其他可能的事务状态有：fetching rows，updating，deleting，inserting 等。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql tables in use 3, locked 3</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 3 row lock(s)</span><br></pre></td></tr></tbody></table></figure><ul><li>tables in use 3, locked 3 表示有3张表被使用，有3个表锁。</li><li>LOCK WAIT 表示事务正在等待锁。4 lock struct(s) 表示事务的锁链表长度为4，每个链表节点代表该事务持有的一个锁结构，包括表锁，记录锁以及自增锁等。</li><li>heap size 1136 表示为事务分配的锁堆内存大小，这里不需要关心。</li><li>3 row lock(s)  表示当前事务持有的行锁个数。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL thread id 13133017, OS thread handle 139806311954176, query id 2776903298 10.**.**.179 k**_base_oniv updating</span><br></pre></td></tr></tbody></table></figure><p>事务的线程id，数据库ip、库名信息，这里不需要关心。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update ..</span><br><span class="line">SET ..</span><br><span class="line">WHERE ..</span><br></pre></td></tr></tbody></table></figure><p>事务正在执行的sql，需要注意的是死锁日志里只会显示一条sql，分析时还需要结合代码看事务之前还执行了哪些sql。我们这里没有其他sql，只有这一个update操作。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 883 page no 6297 n bits 1000 index idx_class_id of table `test_db`.`test_table` trx id 1017957458 lock_mode X waiting</span><br></pre></td></tr></tbody></table></figure><ul><li>WAITING FOR THIS LOCK TO BE GRANTED 表示正在等待锁。</li><li>RECORD LOCKS 表示等待的锁类型，这里是记录锁。</li><li>space id 883 page no 6297 n bits 1000 表示文件位置，这里不关心。</li><li>index idx_class_id of table <code>test_db</code>.<code>test_table</code> 表示锁的索引，以及索引详情。</li><li>trx id 1017957458 是事务id。</li><li>lock_mode X waiting 表示Next-key 锁，当前处于锁等待状态。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1017957457, ACTIVE 0 sec fetching rows</span><br><span class="line">mysql tables in use 3, locked 3</span><br><span class="line">83 lock struct(s), heap size 8400, 669 row lock(s)</span><br><span class="line">MySQL thread id 13116419, OS thread handle 139803626043136, query id 2776903296 10.198.196.178 k**_base_oniv updating</span><br><span class="line">/*id:182a1bfd*//*ip=10.198.196.178*/update test_table</span><br><span class="line">     SET is_deleted = 1,</span><br><span class="line">        mod_time = '2022-07-19 10:10:22.861' </span><br><span class="line">     WHERE (  user_id = 1548831949420961886</span><br><span class="line">                  and class_id = 1470379</span><br><span class="line">                  and is_deleted = 0 )</span><br></pre></td></tr></tbody></table></figure><p>事务2这段信息跟事务1类似，不再赘述。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 883 page no 6297 n bits 1000 index idx_class_id of table `test_db`.`test_table` trx id 1017957457 lock_mode X</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 883 page no 8596 n bits 152 index PRIMARY of table `test_db`.`test_table` trx id 1017957457 lock_mode X locks rec but not gap waiting</span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></tbody></table></figure><p>锁信息比较关键，第一段表示事务2持有一个idx_class_id索引上的Next-key 锁，第二段表示事务2等待获取表主键上的记录锁。此时形成了死锁，事务1被回滚。</p><h1 id="死锁原因分析"><a href="#死锁原因分析" class="headerlink" title="死锁原因分析"></a>死锁原因分析</h1><p>死锁日志我们已经分析完毕了，从日志中可以看到事务1在等待获取索引idx_class_id上的Next-key lock，而事务2占有索引idx_class_id上的Next-key lock、等待获取主键上的记录锁，然后形成了死锁。</p><p>但是，仅靠日志还是没有弄明白死锁形成的原因，事务1占有的锁信息不知道。从结论反推原因我们可以想到事务1一定是占有了主键上的记录锁，从而相互等待形成了死锁，但是为什么？</p><p>让我们来看下sql执行计划：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>UPDATE</td><td>test_table</td><td></td><td>index_merge</td><td>idx_user_id,idx_class_id</td><td>idx_user_id,idx_class_id</td><td>8,4</td><td></td><td>1</td><td>100</td><td>Using intersect(idx_user_id,idx_class_id); Using where</td></tr></tbody></table><p>从执行计划可以看到索引类型是index_merge，mysql使用了索引合并优化。Extra中可以看到Using intersect，表示具体使用的是index merge intersection算法，对所有使用的索引同时扫描，然后将扫描结果取交集。</p><p>此时问题就比较明确了，两个事务加锁过程如下：</p><ol><li>事务1对idx_user_id加了next-key lock，然后对primary id加了record lock；</li><li>事务2对idx_class_id加了next-key lock，然后要对primary id加record lock陷入等待；</li><li>事务1要对idx_class_id加next-key lock陷入等待；</li></ol><p>在上面三步完毕后死锁就形成了。</p><p><strong>查资料过程中发现MySQL官方已经确认了此bug：<a href="https://bugs.mysql.com/bug.php?id=77209%E3%80%82">https://bugs.mysql.com/bug.php?id=77209。</a></strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>建立联合索引，避免index merge。</li><li>优化代码，避免数据库并发操作。</li><li>将优化器的index merge优化关闭。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html">解决死锁之路 - 常见 SQL 语句的加锁分析</a></li><li><a href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">解决死锁之路（终结篇） - 再见死锁</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html">8.2.1.3 Index Merge Optimization</a></li><li><a href="https://blog.csdn.net/weixin_37692493/article/details/106970386">index_merge导致死锁案例分析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中涉及公司业务信息已脱敏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在项目监控中观察到偶现数据库死锁异常，报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="排查经验" scheme="https://haifuns.com/categories/%E6%8E%92%E6%9F%A5%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="MySQL" scheme="https://haifuns.com/tags/MySQL/"/>
    
    <category term="死锁" scheme="https://haifuns.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】链表专练</title>
    <link href="https://haifuns.com/2022/07/25/algorithm-linkedlist/"/>
    <id>https://haifuns.com/2022/07/25/algorithm-linkedlist/</id>
    <published>2022-07-25T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>链表解题方法论：</p><ol><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</li><li>对于面试，时间复杂度第一位，但一定要找到空间最省的方法</li></ol><p>链表题目常用数据结构和技巧：</p><ol><li>使用容器（哈希表、数组）</li><li>快慢指针</li></ol><h1 id="快慢指针练习"><a href="#快慢指针练习" class="headerlink" title="快慢指针练习"></a>快慢指针练习</h1><ol><li>输入链表头结点，如果奇数长度返回中点，如果偶数长度返回上中点</li><li>输入链表头结点，如果奇数长度返回中点，如果偶数长度返回下中点</li><li>输入链表头结点，如果奇数长度返回中点前一个节点，如果偶数长度返回上中点前一个节点</li><li>输入链表头结点，如果奇数长度返回中点前一个节点，如果偶数长度返回下中点前一个节点</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中点或上中点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidNode</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当快指针到尾部时慢指针在中点或上中点位置</span></span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中点或下中点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidNode</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中点或上中点前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidPreNode</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中点或下中点前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidPreNode</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (head.next.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-判断链表是否是回文结构（LeetCode-234-easy）"><a href="#1-判断链表是否是回文结构（LeetCode-234-easy）" class="headerlink" title="1.判断链表是否是回文结构（LeetCode 234. easy）"></a>1.判断链表是否是回文结构（LeetCode 234. easy）</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用容器，额外空间n</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(cur); <span class="comment">// 全部压到栈中</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) { <span class="comment">// 重新遍历链表，同时从栈中弹出比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快慢指针+容器，额外空间n/2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right中点或下中点</span></span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(right); <span class="comment">// 中点后的节点压入栈中，只压入一半</span></span><br><span class="line">        right = right.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) { <span class="comment">// 遍历链表，同时从栈中弹出比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快慢指针，不需要额外空间</span></span><br><span class="line"><span class="comment">// 找到中点，反转右侧，从两边遍历比较，完成后反转恢复链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    Node n1 = head.next;</span><br><span class="line">    Node n2 = head.next;</span><br><span class="line">    <span class="keyword">while</span> (n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>) {</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n1中点或下中点</span></span><br><span class="line"></span><br><span class="line">    n2 = n1.next; <span class="comment">// 中点下一个节点</span></span><br><span class="line">    n1.next = <span class="keyword">null</span>; <span class="comment">// 中点next设为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转后半段链表，最后指向中点</span></span><br><span class="line">    Node n3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="keyword">null</span>) {</span><br><span class="line">        n3 = n2.next;</span><br><span class="line">        n2.next = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n3 = n1; <span class="comment">// 原链表最后一个节点</span></span><br><span class="line">    n2 = head;<span class="comment">// 原链表头</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>) { <span class="comment">// 从两头遍历比较</span></span><br><span class="line">        <span class="keyword">if</span> (n1.value != n2.value) {</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        n1 = n1.next; <span class="comment">// 左 -&gt; 中点</span></span><br><span class="line">        n2 = n2.next; <span class="comment">// 右 -&gt; 中点</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    n1 = n3.next; <span class="comment">// 原链表倒数第二个节点</span></span><br><span class="line">    n3.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span>) { <span class="comment">// 反转后半段链表，恢复原始链表</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一道题同样的解题思路，找中点，反转链表：<br>一个链表有偶数个节点，编号L1-&gt;L2-&gt;L3-&gt;L4-&gt;R1-&gt;R2-&gt;R3-&gt;R4，要求返回L1-&gt;R4-&gt;L2-&gt;R3-&gt;L3-&gt;R2-&gt;L4-&gt;R1</p><h1 id="2-按左边小、中间相等、右边大分隔链表（LeetCode-86-medium，相似）"><a href="#2-按左边小、中间相等、右边大分隔链表（LeetCode-86-medium，相似）" class="headerlink" title="2.按左边小、中间相等、右边大分隔链表（LeetCode 86. medium，相似）"></a>2.按左边小、中间相等、右边大分隔链表（LeetCode 86. medium，相似）</h1><ol><li>把链表放到数组里，在数组上做partition（笔试用）</li><li>分成小中大三部分，再把各个部分串起来（面试用）</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用容器实现，放到数组做partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) { <span class="comment">// 放到数组里</span></span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    arrPartition(nodeArr, pivot); <span class="comment">// 分区</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) { <span class="comment">// 恢复链表</span></span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    }</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>; <span class="comment">// 小于区域右边界</span></span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length; <span class="comment">// 大于区域左边界</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != big) {</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) {</span><br><span class="line">            swap(nodeArr, ++small, index++); <span class="comment">// 小于交换当前节点与小于区域最右+1交换，交换过来的值不会大于pivot，直接判断下一个</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) {</span><br><span class="line">            index++; <span class="comment">// 等于直接判断下一个</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            swap(nodeArr, --big, index); <span class="comment">// 大于与大于区域左-1交换，交换完不需要移动，接着判断交换过来的节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    Node tmp = nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用额外空间实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>{</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head，小于区域头节点</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail，小于区域尾节点</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head，等于区域头节点</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail，等于区域尾节点</span></span><br><span class="line">    Node mH = <span class="keyword">null</span>; <span class="comment">// big head，大于区域头节点</span></span><br><span class="line">    Node mT = <span class="keyword">null</span>; <span class="comment">// big tail，大于区域尾节点</span></span><br><span class="line">    Node next = <span class="keyword">null</span>; <span class="comment">// 下一个要处理的节点</span></span><br><span class="line">    <span class="comment">// 遍历链表，将所有节点分别放到小于等于大于三个区域</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) { <span class="comment">// 小于</span></span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) {</span><br><span class="line">                sH = head; <span class="comment">// 如果头为空，头尾都指向当前节点</span></span><br><span class="line">                sT = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sT.next = head; <span class="comment">// 头不是空，当前节点链到尾部</span></span><br><span class="line">                sT = head;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) { <span class="comment">// 等于</span></span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) {</span><br><span class="line">                eH = head; <span class="comment">// 如果头为空，头尾都指向当前节点</span></span><br><span class="line">                eT = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                eT.next = head; <span class="comment">// 头不是空，当前节点链到尾部</span></span><br><span class="line">                eT = head;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 大于</span></span><br><span class="line">            <span class="keyword">if</span> (mH == <span class="keyword">null</span>) {</span><br><span class="line">                mH = head; <span class="comment">// 如果头为空，头尾都指向当前节点</span></span><br><span class="line">                mT = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                mT.next = head; <span class="comment">// 头不是空，当前节点链到尾部</span></span><br><span class="line">                mT = head;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始串联三个部分，小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) { <span class="comment">// 如果有小于区域</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 下一步，一定是需要用eT 去接 大于区域的头</span></span><br><span class="line">    <span class="comment">// 有等于区域，eT -&gt; 等于区域的尾结点</span></span><br><span class="line">    <span class="comment">// 无等于区域，eT -&gt; 小于区域的尾结点</span></span><br><span class="line">    <span class="comment">// eT 尽量不为空的尾巴节点</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) { <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">        eT.next = mH;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : (eH != <span class="keyword">null</span> ? eH : mH);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-复制带随机指针的链表（LeetCode-138-medium）"><a href="#3-复制带随机指针的链表（LeetCode-138-medium）" class="headerlink" title="3.复制带随机指针的链表（LeetCode 138. medium）"></a>3.复制带随机指针的链表（LeetCode 138. medium）</h1><p>链表节点有一个新增的指针，该指针可以指向链表中的任何节点或空节点。<br>给定一个此类节点组成的无环单链表头节点，要求实现链表的复制，返回新链表头节点。</p><p>要求时间复杂度O(N)，额外空间复杂度O(1)。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用额外容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyRandomList1</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="comment">// key 老节点 -&gt; value 新节点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// cur cur.next cur.random 老</span></span><br><span class="line">        <span class="comment">// get(cur) get(cur.next) get(cur.random) 新</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不利用额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyRandomList2</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 在链表基础上复制</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 1' -&gt; 2 -&gt; 2' -&gt; 3 -&gt; 3'</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    }</span><br><span class="line">    cur = head;</span><br><span class="line">    Node copy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1 1' 2 2' 3 3'</span></span><br><span class="line">    <span class="comment">// 依次设置 1' 2' 3' random指针</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        copy = cur.next;</span><br><span class="line">        copy.random = cur.random != <span class="keyword">null</span> ? cur.random.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    }</span><br><span class="line">    Node res = head.next;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// next方向上老新混在一起，random正确</span></span><br><span class="line">    <span class="comment">// next方向上，把新老链表分离</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        copy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        copy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-链表相交（LeetCode-160-141-142-，相似）"><a href="#4-链表相交（LeetCode-160-141-142-，相似）" class="headerlink" title="4.链表相交（LeetCode 160. 141. 142. ，相似）"></a>4.链表相交（LeetCode 160. 141. 142. ，相似）</h1><p>给定两个可能有环也可能无环的单链表的头结点head1和head2，请找出两个链表相交的第一个节点，如果不存在返回null。</p><p>要求时间复杂度O(N)，空间复杂度O(1)。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 链表1入环节点</span></span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    <span class="comment">// 链表2入环节点</span></span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2); <span class="comment">// 都不为环</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2); <span class="comment">// 都是环</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 一个是环一个不是环一定不相交</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个链表的头节点，返回第一个入环节点，如果没有环，则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="comment">// 移动快慢指针到相遇</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 无环，直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当相遇时，快指针重新从头节点开始一步一步移动，慢指针继续移动，最终会在入环位置相遇</span></span><br><span class="line">    <span class="comment">// 推导过程可参考leetcode142题解</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不相交返回null</span></span><br><span class="line"><span class="comment">// 丢弃长链表更长的部分，遍历长度相同的两个链表，相同的节点就是相交位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) {</span><br><span class="line">        sum++; <span class="comment">// 累计cur1的长度</span></span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) {</span><br><span class="line">        sum--; <span class="comment">// 减掉cur2的长度</span></span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sum的绝对值为长链表-短链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历到结尾都不相等，则表示不相交</span></span><br><span class="line">    <span class="comment">// 两个链表相交末尾节点一定是同一个</span></span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长链表</span></span><br><span class="line">    cur1 = sum &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">    <span class="comment">// 短链表</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">    sum = Math.abs(sum);</span><br><span class="line">    <span class="keyword">while</span> (sum != <span class="number">0</span>) {</span><br><span class="line">        sum--;</span><br><span class="line">        cur1 = cur1.next; <span class="comment">// 移动长链表，放弃更长的部分</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) { <span class="comment">// 同时遍历两个链表找到相同的位置</span></span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个链表都有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>{</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) { <span class="comment">// 入环位置已经相交，第一个相交位置在入环前或者入环位置</span></span><br><span class="line">        cur1 = head1; <span class="comment">// 从头节点到入环位置判断相交，处理方式同无环</span></span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) {</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) {</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        }</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) {</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) {</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// 入环位置没有相交，要么链表没有相交，要么在环其他位置相交</span></span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) { <span class="comment">// 两个链表在环其他位置相交</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) {</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            }</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 两个链表有环但是不相交</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表解题方法论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于笔试，不用太在乎空间复杂度，一切为了时间复杂度&lt;/li&gt;
&lt;li&gt;对于面试，时间复杂度第一位，但一定要找到空间最省的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链表题目常用数据结构和技巧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用容器（哈希表、数</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://haifuns.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】排序算法（总）</title>
    <link href="https://haifuns.com/2022/07/18/algorithm-sort/"/>
    <id>https://haifuns.com/2022/07/18/algorithm-sort/</id>
    <published>2022-07-18T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h1><h2 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h2><p>排序算法执行效率分析从以下几个方面来衡量：</p><ul><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ul><h2 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序（Sorted in place）概念，特指空间复杂度是 O(1) 的排序算法。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变则稳定，否则不稳定。</p><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/BubbleSort.gif" alt="image"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 - n</span></span><br><span class="line">    <span class="comment">// 0 - n-1</span></span><br><span class="line">    <span class="comment">// 0 - n-2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = n - <span class="number">1</span>; end &gt;= <span class="number">0</span>; end--) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0, 1</span></span><br><span class="line">        <span class="comment">// 1, 2</span></span><br><span class="line">        <span class="comment">// 2, 3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> second = <span class="number">1</span>; second &lt;= end; second++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[second - <span class="number">1</span>] &gt; arr[second]) {</span><br><span class="line">                <span class="comment">// 表示有数据交换</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                swap(arr, second - <span class="number">1</span>, second);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><ul><li>最好情况：要排序的数据已经是有序的了，只需要进行一次冒泡操作，时间复杂度O(n)，例如：“1,2,3,4,5,6”</li><li>最坏情况：要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，时间复杂度为 O(n^2)，例如：“6,5,4,3,2,1”</li><li>平均情况：O(n^2)</li></ul><p>空间复杂度：</p><p>冒泡排序只涉及相邻数据交换操作，时间复杂度为O(1)，是一个原地排序算法。</p><h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><p>插入排序包含元素比较和元素移动两种操作。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。然后将插入点之后的元素顺序往后移动一位，再插入 a 元素。</p><h2 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/InsertionSort.gif" alt="image"></p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; arr[j] &gt; arr[j + <span class="number">1</span>] &amp;&amp; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">            swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><ul><li>最好情况，数据有序，复杂度O(n)</li><li>最坏情况，数据倒序，复杂度O(n^2)</li><li>平均情况：O(n^2)</li></ul><p>空间复杂度：</p><p>插入排序算法是原地排序算法，空间复杂度O(1)</p><h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><h2 id="动画演示-2"><a href="#动画演示-2" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/SelectionSort.gif" alt="image"></p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> minValueIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">            minValueIndex = arr[minValueIndex] &gt; arr[j] ? j : minValueIndex;</span><br><span class="line">        }</span><br><span class="line">        swap(arr, i, minValueIndex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>最好/最坏/平均情况下时间复杂度都为 O(n^2)</p><p>空间复杂度：</p><p>原地排序，复杂度O(1)</p><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>归并排序：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并。</p><h2 id="动画演示-3"><a href="#动画演示-3" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/MergeSort.gif" alt="image"></p><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中点位置 (l+r)/2</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分后分别排序</span></span><br><span class="line">    process(arr, l, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并已经排好序的两块数组</span></span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用两个指针分别指向[l,mid], (mid, r]</span></span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常范围, 依次比较, 小的放到辅助数组, 指针后移</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p1没越界, p2越界, 把p1剩下的数拷贝到辅助数组</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) {</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p2没越界, p1越界, 把p2剩下的数拷贝到辅助数组</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) {</span><br><span class="line">        arr[l + j] = help[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><p>根据Master公式，T(N) = 2 * T(N/2) + O(N)，a=2，b=2，d=1, log(b,a)==d，所以时间复杂度为O(N * logN)</p><p>最好情况、最坏情况，平均情况，时间复杂度都是 O(nlogn)。</p><p>空间复杂度：</p><p>空间复杂度O(n)。</p><h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>快速排序算法（Quicksort），简称为“快排”，利用的也是分治思想。</p><p>快排思想：(要排序数组中下标从 p 到 r 之间的一组数据)</p><ul><li>选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</li><li>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。</li></ul><p>经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p>根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，所有的数据都有序了。</p><h2 id="动画演示-4"><a href="#动画演示-4" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/QuickSort.gif" alt="image"></p><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    swap(arr, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">    <span class="keyword">int</span>[] equalArea = partition(arr, l, r);</span><br><span class="line">    process(arr, l, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在arr[l...r]范围上, 对arr[r]做划分值</span></span><br><span class="line"><span class="comment">// 对于l...r范围, 小于arr[r]在左边, 等于在中间, 大于在右边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) {</span><br><span class="line">    <span class="comment">// 小于区域右边界</span></span><br><span class="line">    <span class="keyword">int</span> lessR = l - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 大于区域左边界</span></span><br><span class="line">    <span class="keyword">int</span> moreL = r;</span><br><span class="line">    <span class="keyword">int</span> index = l;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; moreL) {</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt; arr[r]) {</span><br><span class="line">            <span class="comment">// 如果小于, 跟小于区域右侧第一个值交换, 继续处理下一个值</span></span><br><span class="line">            swap(arr, ++lessR, index++);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; arr[r]) {</span><br><span class="line">            <span class="comment">// 如果大于, 跟大于区域左侧第一个值交换, 交换完不需要移动index</span></span><br><span class="line">            swap(arr, --moreL, index);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 交换大于区域左侧第一个值和目标arr[r]</span></span><br><span class="line">    swap(arr, moreL, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回等于位置左右边界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { lessR + <span class="number">1</span>, moreL };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：</p><ul><li>最好、平均情况 O(nlogn)，每次分区操作，都能正好把数组分成大小接近相等的两个小区间</li><li>最坏情况 O(n^2)，数组已有序排列</li></ul><p>空间复杂度：O(nlogn)</p><h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><p>堆结构是用数组实现的完全二叉树结构，具体实现：优先级队列PriorityQueue。</p><p>完全二叉树中对于任意一个节点index=i，满足：</p><p>左孩子位置：2 * i + 1<br>右孩子位置：2 * i + 2<br>父节点位置：(i - 1) / 2</p><p>堆排序思想：</p><ol><li>先让整个数组变成大根堆结构，建堆过程：<br> a. 从上到下的方法，时间复杂度O(n*logn)<br> b. 从下到上的方法，时间复杂度O(n)</li><li>把堆的最大值和堆末尾的值交换，减少堆的大小并重新调整堆，循环操作到堆的大小减小到0时，排序完成</li></ol><p>大根堆：完全二叉树中如果每棵子树的最大值都在顶部就是大根堆。<br>小根堆：完全二叉树中如果每棵子树的最小值都在顶部就是小根堆。</p><h2 id="动画演示-5"><a href="#动画演示-5" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://img.haifuns.com/md/img/heapsort.gif" alt="image"></p><h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式构建大根堆，从上到下</span></span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; arr.length; i++) {</span></span><br><span class="line">    <span class="comment">// heapInsert(arr, i);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式构建大根堆，从下到上</span></span><br><span class="line">    <span class="comment">// O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// 交换0位置最大值到大根堆最后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) { <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]位置的数，往上移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) {</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]位置的数，往下移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) { <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">        <span class="comment">// 1) 只有左孩子，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值 &lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值 &gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n*logn)，空间复杂度：O(1)。</p><h1 id="计数排序（Count-Sort）"><a href="#计数排序（Count-Sort）" class="headerlink" title="计数排序（Count Sort）"></a>计数排序（Count Sort）</h1><p>对于有限数据范围的数据，利用一个相应大小的桶（从小到大对应每个数），对给定数组中每个值进行计数，完毕后从左到右每个数*n重新输出，完成排序。</p><h2 id="动画演示-6"><a href="#动画演示-6" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://img.haifuns.com/md/img/countsort.gif"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) {</span><br><span class="line">        <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) {</span><br><span class="line">            arr[i++] = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n+k)，空间复杂度：O(k)。</p><h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>基数排序：准备一个大小为10的桶表示0-9，从个位开始，将每个数放到个位对应桶的位置里，然后按照先进先进输出，继续按照高位循环直到最大数最高位，相当于每次按照每位排序，到最高位后完成排序。</p><h2 id="动画演示-7"><a href="#动画演示-7" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://img.haifuns.com/md/img/radixsort.gif"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只适用非负数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxbits</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) {</span><br><span class="line">        res++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]排序 , 最大值的十进制位数digit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> digit)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= digit; d++) { <span class="comment">// 有多少位就进出几次</span></span><br><span class="line">        <span class="comment">// 10个空间</span></span><br><span class="line">        <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">        <span class="keyword">for</span> (i = L; i &lt;= R; i++) {</span><br><span class="line">            <span class="comment">// 103 1 3</span></span><br><span class="line">            <span class="comment">// 209 1 9</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            count[j]++; <span class="comment">// count数组先按照位数计数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) {</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>]; <span class="comment">// count转变成累加和，累加和：大于等于当前数个数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = R; i &gt;= L; i--) { <span class="comment">// 原数组从右往左遍历，利用累加和可以直接找到应该在的位置</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            help[count[j] - <span class="number">1</span>] = arr[i]; <span class="comment">// 当前数应该在的位置就是相应累加和-1的位置</span></span><br><span class="line">            count[j]--; <span class="comment">// 使用完之后把相应位置累加和-1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) {</span><br><span class="line">            arr[i] = help[j]; <span class="comment">// 辅助空间 -&gt; 原始数组</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位，大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n*k)，空间复杂度：O(n+k)。</p><h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><ol><li>不基于比较的排序，对样本数据有严格要求，不易改写</li><li>基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用</li><li>基于比较的排序，时间复杂度极限是O(N*logN)</li><li>时间复杂度O(N*logN)，额外空间复杂度低于O(N)，并且稳定的基于比较的排序不存在</li><li>为了绝对的速度选快排，为了省空间选堆排，为了稳定性选归并</li></ol><h1 id="排序算法复杂度快查表"><a href="#排序算法复杂度快查表" class="headerlink" title="排序算法复杂度快查表"></a>排序算法复杂度快查表</h1><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/sort.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法分析&quot;&gt;&lt;a href=&quot;#排序算法分析&quot; class=&quot;headerlink&quot; title=&quot;排序算法分析&quot;&gt;&lt;/a&gt;排序算法分析&lt;/h1&gt;&lt;h2 id=&quot;执行效率&quot;&gt;&lt;a href=&quot;#执行效率&quot; class=&quot;headerlink&quot; title=&quot;执</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://haifuns.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】不基于比较的排序（计数、基数）</title>
    <link href="https://haifuns.com/2022/07/17/algorithm-uncomparesort/"/>
    <id>https://haifuns.com/2022/07/17/algorithm-uncomparesort/</id>
    <published>2022-07-17T15:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序和基数排序是不基于比较的排序，其思想都是基于容器（桶）进行排序。</p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序：对于有限数据范围的数据，利用一个相应大小的桶（从小到大对应每个数），对给定数组中每个值进行计数，完毕后从左到右每个数*n重新输出，完成排序。</p><p>时间复杂度：O(n+k)，空间复杂度：O(k)。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) {</span><br><span class="line">        <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) {</span><br><span class="line">            arr[i++] = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序：准备一个大小为10的桶表示0-9，从个位开始，将每个数放到个位对应桶的位置里，然后按照先进先进输出，继续按照高位循环直到最大数最高位，相当于每次按照每位排序，到最高位后完成排序。</p><p>时间复杂度：O(n*k)，空间复杂度：O(n+k)。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只适用非负数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxbits</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) {</span><br><span class="line">        res++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]排序 , 最大值的十进制位数digit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> digit)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= digit; d++) { <span class="comment">// 有多少位就进出几次</span></span><br><span class="line">        <span class="comment">// 10个空间</span></span><br><span class="line">        <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">        <span class="keyword">for</span> (i = L; i &lt;= R; i++) {</span><br><span class="line">            <span class="comment">// 103 1 3</span></span><br><span class="line">            <span class="comment">// 209 1 9</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            count[j]++; <span class="comment">// count数组先按照位数计数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) {</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>]; <span class="comment">// count转变成累加和，累加和：大于等于当前数个数</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = R; i &gt;= L; i--) { <span class="comment">// 原数组从右往左遍历，利用累加和可以直接找到应该在的位置</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            help[count[j] - <span class="number">1</span>] = arr[i]; <span class="comment">// 当前数应该在的位置就是相应累加和-1的位置</span></span><br><span class="line">            count[j]--; <span class="comment">// 使用完之后把相应位置累加和-1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) {</span><br><span class="line">            arr[i] = help[j]; <span class="comment">// 辅助空间 -&gt; 原始数组</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位，大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计数排序和基数排序是不基于比较的排序，其思想都是基于容器（桶）进行排序。&lt;/p&gt;
&lt;h1 id=&quot;计数排序&quot;&gt;&lt;a href=&quot;#计数排序&quot; class=&quot;headerlink&quot; title=&quot;计数排序&quot;&gt;&lt;/a&gt;计数排序&lt;/h1&gt;&lt;p&gt;计数排序：对于有限数据范围的数据，利</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://haifuns.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】前缀树</title>
    <link href="https://haifuns.com/2022/07/17/algorithm-trietree/"/>
    <id>https://haifuns.com/2022/07/17/algorithm-trietree/</id>
    <published>2022-07-17T07:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>前缀树也称为字典树、Trie树，优点在于利用字符串的公共前缀来减少查询时间，常被搜索引擎用于文本词频统计。</p><h1 id="前缀树构建过程"><a href="#前缀树构建过程" class="headerlink" title="前缀树构建过程"></a>前缀树构建过程</h1><p>以字符串“abc”，“abd”，“bce”，“abcd”为例，前缀树构建过程如下图所示：</p><ul><li>每个节点记录经过当前节点的字符串数量p和是否是字符串结尾e</li><li>每条线段表示字符</li></ul><p><img src="https://img.haifuns.com/md/img/trie.png" alt="image"></p><h1 id="前缀树实现"><a href="#前缀树实现" class="headerlink" title="前缀树实现"></a>前缀树实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> Node[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>{</span><br><span class="line">        pass = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>{</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符串word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        Node node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) { <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">            path = chs[i] - <span class="string">'a'</span>; <span class="comment">// 字符</span></span><br><span class="line">            <span class="keyword">if</span> (node.nexts[path] == <span class="keyword">null</span>) { <span class="comment">// 当前字符对应的node不存在就新建</span></span><br><span class="line">                node.nexts[path] = <span class="keyword">new</span> Node();</span><br><span class="line">            }</span><br><span class="line">            node = node.nexts[path]; <span class="comment">// 指针移动到当前node</span></span><br><span class="line">            node.pass++; <span class="comment">// 当前node pass + 1</span></span><br><span class="line">        }</span><br><span class="line">        node.end++; <span class="comment">// 最后一个字符对应的node end + 1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除字符串word</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (search(word) != <span class="number">0</span>) { <span class="comment">// 不存在直接跳过</span></span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            Node node = root;</span><br><span class="line">            node.pass--; <span class="comment">// root pass直接-1</span></span><br><span class="line">            <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">                path = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) { <span class="comment">// 如果字符pass-1后是0，直接设为空结束</span></span><br><span class="line">                    node.nexts[path] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            }</span><br><span class="line">            node.end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找word加入过几次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node.end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找以pre作为前缀的字符串数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) {</span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node.pass;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前缀树也称为字典树、Trie树，优点在于利用字符串的公共前缀来减少查询时间，常被搜索引擎用于文本词频统计。&lt;/p&gt;
&lt;h1 id=&quot;前缀树构建过程&quot;&gt;&lt;a href=&quot;#前缀树构建过程&quot; class=&quot;headerlink&quot; title=&quot;前缀树构建过程&quot;&gt;&lt;/a&gt;前缀树构</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="异或" scheme="https://haifuns.com/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】加强堆</title>
    <link href="https://haifuns.com/2022/07/06/algorithm-heapgreater/"/>
    <id>https://haifuns.com/2022/07/06/algorithm-heapgreater/</id>
    <published>2022-07-06T15:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>加强堆在普通堆的基础上通过建立反向索引表和比较器，额外实现了任意节点更新和任意节点删除的功能。</p><h1 id="加强堆实现"><a href="#加强堆实现" class="headerlink" title="加强堆实现"></a>加强堆实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapGreater</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆数组</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; heap;</span><br><span class="line">    <span class="comment">// 反向索引，增加结构</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;T, Integer&gt; indexMap;</span><br><span class="line">    <span class="comment">// 堆大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="comment">// 自定义比较器</span></span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> T&gt; comp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapGreater</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>{</span><br><span class="line">        heap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">        comp = c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heapSize == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heapSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T obj)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> indexMap.containsKey(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heap.get(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T obj)</span> </span>{</span><br><span class="line">        heap.add(obj);</span><br><span class="line">        indexMap.put(obj, heapSize);</span><br><span class="line">        heapInsert(heapSize++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        T ans = heap.get(<span class="number">0</span>);</span><br><span class="line">        swap(<span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">        indexMap.remove(ans);</span><br><span class="line">        heap.remove(--heapSize);</span><br><span class="line">        heapify(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加功能，移除任意节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj)</span> </span>{</span><br><span class="line">        <span class="comment">// 堆最后位置的节点</span></span><br><span class="line">        T replace = heap.get(heapSize - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 指定节点位置</span></span><br><span class="line">        <span class="keyword">int</span> index = indexMap.get(obj);</span><br><span class="line">        <span class="comment">// 从反向索引中移除指定节点</span></span><br><span class="line">        indexMap.remove(obj);</span><br><span class="line">        <span class="comment">// 从堆中移除最后一个节点</span></span><br><span class="line">        heap.remove(--heapSize);</span><br><span class="line">        <span class="keyword">if</span> (obj != replace) { <span class="comment">// 如果指定的不是最后一个节点</span></span><br><span class="line">            heap.set(index, replace); <span class="comment">// 把取出来的原最后节点放到指定位置</span></span><br><span class="line">            indexMap.put(replace, index); <span class="comment">// 更新反向索引</span></span><br><span class="line">            resign(replace); <span class="comment">// 更新指定位置节点，重新建堆</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增强功能，任意节点变化后重新建堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resign</span><span class="params">(T obj)</span> </span>{</span><br><span class="line">        <span class="comment">// 向上移或者向下移，只会执行一个</span></span><br><span class="line">        heapInsert(indexMap.get(obj));</span><br><span class="line">        heapify(indexMap.get(obj));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆上的所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getAllElements</span><span class="params">()</span> </span>{</span><br><span class="line">        List&lt;T&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T c : heap) {</span><br><span class="line">            ans.add(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上移</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (comp.compare(heap.get(index), heap.get((index - <span class="number">1</span>) / <span class="number">2</span>)) &lt; <span class="number">0</span>) {</span><br><span class="line">            swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下移</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) {</span><br><span class="line">            <span class="keyword">int</span> best = left + <span class="number">1</span> &lt; heapSize &amp;&amp; comp.compare(heap.get(left + <span class="number">1</span>), heap.get(left)) &lt; <span class="number">0</span> ? (left + <span class="number">1</span>) : left;</span><br><span class="line">            best = comp.compare(heap.get(best), heap.get(index)) &lt; <span class="number">0</span> ? best : index;</span><br><span class="line">            <span class="keyword">if</span> (best == index) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            swap(best, index);</span><br><span class="line">            index = best;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        T o1 = heap.get(i);</span><br><span class="line">        T o2 = heap.get(j);</span><br><span class="line">        heap.set(i, o2);</span><br><span class="line">        heap.set(j, o1);</span><br><span class="line">        indexMap.put(o2, i);</span><br><span class="line">        indexMap.put(o1, j);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-前K名购买最多者得奖问题（笔试题）"><a href="#1-前K名购买最多者得奖问题（笔试题）" class="headerlink" title="1. 前K名购买最多者得奖问题（笔试题）"></a>1. 前K名购买最多者得奖问题（笔试题）</h1><p>给定一个整型数组int[] arr和一个布尔类型的数组boolean[] op，两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作。</p><p>例如：<br>arr = [3, 3, 1, 2, 1, 2, 5]<br>op  = [T, T, T, T, F, T, F]<br>依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品。</p><p>得奖系统规则：</p><ol><li>如果某个用户购买数量为0，但是又发生了退货时间，则认为该事件无效</li><li>用户发生购买商品事件，购买商品数量+1，发生退货事件，购买商品数量-1</li><li>每次都是最多K个用户得奖，如果得奖人数不足K个，那就以不够的情况输出结果</li><li>得奖系统分为得奖区和候选区，任何用户只要购买数&gt;0，一定在两个区域中的一个</li><li>购买数最大的前K名用户进入得奖区，在最初时如果得奖区没有达到K个用户，那就新来的用户直接进入得奖区</li><li>购买数不足以进入得奖区的用户进入候选区</li><li>如果候选区购买数最多的用户已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（大于才能替换）<ul><li>如果得奖区中购买数最少的用户有多个，就替换最早进入的得奖区的用户</li><li>如果候选区中购买数最多的用户有多个，机会给最早进入候选区的用户</li></ul></li><li>候选区和得奖区是两套时间，用户只会在其中一个区域，所有只会有一个区域的时间，另一个没有<ul><li>从得奖区出来进入候选区的用户，得奖区时间会删除，进入候选区的时间就是当前事件的时间（可以认为是arr[i]和op[i]中的i）</li><li>从候选区进入得奖区的用户，候选区时间会删除，进入得奖区的时间就是当前事件的时间（可以认为是arr[i]和op[i]中的i）</li></ul></li><li>如果用户购买数为0，从区域中移除，区域时间也删除，如果用户重新发生购买按照规则进去区域，时间重记</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WhosYourDaddy</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Customer&gt; customers;</span><br><span class="line">    <span class="keyword">private</span> HeapGreater&lt;Customer&gt; candHeap; <span class="comment">// 候选区，大根堆</span></span><br><span class="line">    <span class="keyword">private</span> HeapGreater&lt;Customer&gt; daddyHeap; <span class="comment">// 得奖区，小根堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> daddyLimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhosYourDaddy</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        customers = <span class="keyword">new</span> HashMap&lt;Integer, Customer&gt;();</span><br><span class="line">        candHeap = <span class="keyword">new</span> HeapGreater&lt;&gt;(<span class="keyword">new</span> CandidateComparator());</span><br><span class="line">        daddyHeap = <span class="keyword">new</span> HeapGreater&lt;&gt;(<span class="keyword">new</span> DaddyComparator());</span><br><span class="line">        daddyLimit = limit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前处理i号事件，arr[i] -&gt; id, buyOrRefund</span></span><br><span class="line">    <span class="comment">// O(N*(logN+logK+K))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> time, <span class="keyword">int</span> id, <span class="keyword">boolean</span> buyOrRefund)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!buyOrRefund &amp;&amp; !customers.containsKey(id)) { <span class="comment">// 没买东西退款</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!customers.containsKey(id)) { <span class="comment">// 新买</span></span><br><span class="line">            customers.put(id, <span class="keyword">new</span> Customer(id, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line">        Customer c = customers.get(id);</span><br><span class="line">        <span class="keyword">if</span> (buyOrRefund) {</span><br><span class="line">            c.buy++; <span class="comment">// 买加商品数量</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            c.buy--; <span class="comment">// 退减商品数量</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (c.buy == <span class="number">0</span>) {</span><br><span class="line">            customers.remove(id); <span class="comment">// 退没了移除记录</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!candHeap.contains(c) &amp;&amp; !daddyHeap.contains(c)) { <span class="comment">// 不在候选区，不在得将区</span></span><br><span class="line">            <span class="keyword">if</span> (daddyHeap.size() &lt; daddyLimit) { <span class="comment">// 得奖区没满直接放进去，时间重置</span></span><br><span class="line">                c.enterTime = time;</span><br><span class="line">                daddyHeap.push(c);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 得奖区满了放到候选区，时间重置</span></span><br><span class="line">                c.enterTime = time;</span><br><span class="line">                candHeap.push(c);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (candHeap.contains(c)) { <span class="comment">// 之前在候选区</span></span><br><span class="line">            <span class="keyword">if</span> (c.buy == <span class="number">0</span>) {</span><br><span class="line">                candHeap.remove(c); <span class="comment">// 购买数量是0从候选区移除</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                candHeap.resign(c); <span class="comment">// 数量变化重新建堆</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 之前在得奖区</span></span><br><span class="line">            <span class="keyword">if</span> (c.buy == <span class="number">0</span>) {</span><br><span class="line">                daddyHeap.remove(c); <span class="comment">// 购买数量是0从得奖区移除</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                daddyHeap.resign(c); <span class="comment">// 数量变化重新建堆</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        daddyMove(time); <span class="comment">// 检查得奖区</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中奖人</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getDaddies</span><span class="params">()</span> </span>{</span><br><span class="line">        List&lt;Customer&gt; customers = daddyHeap.getAllElements();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : customers) {</span><br><span class="line">            ans.add(c.id);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">daddyMove</span><span class="params">(<span class="keyword">int</span> time)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (candHeap.isEmpty()) { <span class="comment">// 如果候选区空了直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (daddyHeap.size() &lt; daddyLimit) { <span class="comment">// 如果得奖区有空位，从候选区弹出一个最大放到得奖区，时间重置</span></span><br><span class="line">            Customer p = candHeap.pop();</span><br><span class="line">            p.enterTime = time;</span><br><span class="line">            daddyHeap.push(p);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 如果得奖区满了，候选区没空</span></span><br><span class="line">            <span class="keyword">if</span> (candHeap.peek().buy &gt; daddyHeap.peek().buy) { <span class="comment">// 候选区最大和得奖区最小比较，如果候选区更大交换，时间重置</span></span><br><span class="line">                Customer oldDaddy = daddyHeap.pop();</span><br><span class="line">                Customer newDaddy = candHeap.pop();</span><br><span class="line">                oldDaddy.enterTime = time;</span><br><span class="line">                newDaddy.enterTime = time;</span><br><span class="line">                daddyHeap.push(newDaddy);</span><br><span class="line">                candHeap.push(oldDaddy);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> buy;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> enterTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> b, <span class="keyword">int</span> o)</span> </span>{</span><br><span class="line">        id = v;</span><br><span class="line">        buy = b;</span><br><span class="line">        enterTime = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CandidateComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Customer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Customer o1, Customer o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.buy != o2.buy ? (o2.buy - o1.buy) : (o1.enterTime - o2.enterTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaddyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Customer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Customer o1, Customer o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> o1.buy != o2.buy ? (o1.buy - o2.buy) : (o1.enterTime - o2.enterTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;加强堆在普通堆的基础上通过建立反向索引表和比较器，额外实现了任意节点更新和任意节点删除的功能。&lt;/p&gt;
&lt;h1 id=&quot;加强堆实现&quot;&gt;&lt;a href=&quot;#加强堆实现&quot; class=&quot;headerlink&quot; title=&quot;加强堆实现&quot;&gt;&lt;/a&gt;加强堆实现&lt;/h1&gt;&lt;figur</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://haifuns.com/tags/%E5%A0%86/"/>
    
    <category term="排序" scheme="https://haifuns.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】堆和堆排序</title>
    <link href="https://haifuns.com/2022/07/04/algorithm-heapandheapsort/"/>
    <id>https://haifuns.com/2022/07/04/algorithm-heapandheapsort/</id>
    <published>2022-07-04T15:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>堆结构是用数组实现的完全二叉树结构，具体实现：优先级队列PriorityQueue。</p><p>完全二叉树中对于任意一个节点index=i，满足：</p><ul><li>左孩子位置：2 * i + 1</li><li>右孩子位置：2 * i + 2</li><li>父节点位置：(i - 1) / 2</li></ul><p>大根堆：完全二叉树中如果每棵子树的最大值都在顶部就是大根堆。<br>小根堆：完全二叉树中如果每棵子树的最小值都在顶部就是小根堆。</p><h1 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h1><p>大根堆和小根堆实现方式类似，这里只看大根堆实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMaxHeap</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMaxHeap</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="keyword">int</span>[limit];</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heapSize == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heapSize == limit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (heapSize == limit) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"heap is full"</span>);</span><br><span class="line">        }</span><br><span class="line">        heap[heapSize] = value;</span><br><span class="line">        <span class="comment">// value heapSize</span></span><br><span class="line">        heapInsert(heap, heapSize++);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最大值，并且在大根堆中，把最大值删掉</span></span><br><span class="line">    <span class="comment">// 剩下的数，依然保持大根堆组织</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = heap[<span class="number">0</span>]; <span class="comment">// 最大值</span></span><br><span class="line">        swap(heap, <span class="number">0</span>, --heapSize); <span class="comment">// 交换最后位置的值和最大值</span></span><br><span class="line">        heapify(heap, <span class="number">0</span>, heapSize); <span class="comment">// 最后的值在0位置，从0出发重新构建堆</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="comment">// 新加进来的数，现在停在了index位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="comment">// [index] [(index-1)/2]</span></span><br><span class="line">        <span class="comment">// index == 0</span></span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) { <span class="comment">// 如果大于父节点</span></span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 跟父节点交换</span></span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 更新位置</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从index位置，往下看，不断的下沉</span></span><br><span class="line">    <span class="comment">// 停：较大的孩子都不再比index位置的数大；已经没孩子了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) { <span class="comment">// 如果有左孩子，有没有右孩子，可能有可能没有！</span></span><br><span class="line">            <span class="comment">// 把较大孩子的下标，给largest</span></span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="keyword">if</span> (largest == index) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// index和较大孩子，要互换</span></span><br><span class="line">            swap(arr, largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序思想：</p><ol><li>先让整个数组变成大根堆结构，建堆过程：<br> a. 从上到下的方法，时间复杂度O(N*logN)<br> b. 从下到上的方法，时间复杂度O(N)</li><li>把堆的最大值和堆末尾的值交换，减少堆的大小并重新调整堆，循环操作，时间复杂度O(N*logN)</li><li>堆的大小减小到0时，排序完成</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式构建大根堆，从上到下</span></span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; arr.length; i++) {</span></span><br><span class="line">    <span class="comment">// heapInsert(arr, i);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式构建大根堆，从下到上</span></span><br><span class="line">    <span class="comment">// O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// 交换0位置最大值到大根堆最后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) { <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]位置的数，往上移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) {</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]位置的数，往下移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) { <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">        <span class="comment">// 1) 只有左孩子，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值 &lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值 &gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-几乎有序的数组排序问题"><a href="#1-几乎有序的数组排序问题" class="headerlink" title="1. 几乎有序的数组排序问题"></a>1. 几乎有序的数组排序问题</h1><p>已知一个几乎有序的数组，几乎有序指如果把数组排好序的话，每个元素移动的距离一定不超过K，并且K相对于数组长度来说是比较小的。<br>选择一种合适的排序策略，对这个数组进行排序。</p><p>思路：利用小根堆，小根堆大小为K，保持K个数放到小根堆里，弹出最小值就是当前堆+剩余数中的最小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(N*logK)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedArrDistanceLessK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 默认小根堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0...K-1</span></span><br><span class="line">    <span class="keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="number">1</span>, k - <span class="number">1</span>); index++) {</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; arr.length; i++, index++) {</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">        arr[i] = heap.poll();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) {</span><br><span class="line">        arr[i++] = heap.poll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-最大线段重合问题"><a href="#2-最大线段重合问题" class="headerlink" title="2. 最大线段重合问题"></a>2. 最大线段重合问题</h1><p>给定很多线段，线段用[start,end]表示线段开始和结束位置，左右都是闭区间。</p><p>规定：</p><ol><li>线段的开始和结束位置一定是整数值</li><li>线段重合区域的长度一定&gt;=1</li></ol><p>要求返回最多重合区域中，包含了几段线段。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力方法 O((max - min) * N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCover1</span><span class="params">(<span class="keyword">int</span>[][] lines)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE; <span class="comment">// 所有线段最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; <span class="comment">// 所有线段最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.length; i++) {</span><br><span class="line">        min = Math.min(min, lines[i][<span class="number">0</span>]);</span><br><span class="line">        max = Math.max(max, lines[i][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> cover = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> p = min + <span class="number">0.5</span>; p &lt; max; p += <span class="number">1</span>) { <span class="comment">// 每0.5统计在范围内的线段数</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">// 包含当前0.5的线段数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (lines[i][<span class="number">0</span>] &lt; p &amp;&amp; lines[i][<span class="number">1</span>] &gt; p) {</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cover = Math.max(cover, cur); <span class="comment">// 重合最多的0.5对应的线段数量</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cover;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆实现 O(N*logN)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCover2</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>{</span><br><span class="line">    <span class="comment">// 先按照线段左位置start排序</span></span><br><span class="line">    Arrays.sort(m, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 准备好小根堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] line : m) {</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; heap.peek() &lt;= line[<span class="number">0</span>]) {</span><br><span class="line">            heap.poll(); <span class="comment">// 弹出所有小于start的数</span></span><br><span class="line">        }</span><br><span class="line">        heap.add(line[<span class="number">1</span>]); <span class="comment">// end加入小根堆</span></span><br><span class="line">        max = Math.max(max, heap.size()); <span class="comment">// 小根堆里剩下的是跟当前线段重合的线段数量</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;堆结构是用数组实现的完全二叉树结构，具体实现：优先级队列PriorityQueue。&lt;/p&gt;
&lt;p&gt;完全二叉树中对于任意一个节点index=i，满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左孩子位置：2 * i + 1&lt;/li&gt;
&lt;li&gt;右孩子位置：2 * i + 2&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="堆" scheme="https://haifuns.com/tags/%E5%A0%86/"/>
    
    <category term="排序" scheme="https://haifuns.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】快速排序</title>
    <link href="https://haifuns.com/2022/06/30/algorithm-quicksort/"/>
    <id>https://haifuns.com/2022/06/30/algorithm-quicksort/</id>
    <published>2022-06-30T15:55:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序算法（Quicksort），简称为“快排”，利用的是分治思想。</p><p>快排思想：(要排序数组中下标从 p 到 r 之间的一组数据)</p><p>选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。<br>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。<br>经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p>根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，所有的数据都有序了。</p><h1 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h1><p>快速排序思想中数据按大小分区也即荷兰国旗问题：</p><p>给定一个数组arr和一个数num，要求对于[l,r]范围内的数，小于num的数放到最左边，等于num放到中间，大于num放到最右边。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 荷兰国旗问题, 在arr[l..r]上, 以arr[r]做划分值, 小于arr[r] 等于arr[r] 大于arr[r]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回等于区域左右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherlandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) {</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>; <span class="comment">// 小于区域右边界</span></span><br><span class="line">    <span class="keyword">int</span> more = r; <span class="comment">// 大于区域左边界</span></span><br><span class="line">    <span class="keyword">int</span> index = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; more) { <span class="comment">// 只需要处理到大于区域左边界左边第一个数</span></span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt; arr[r]) {</span><br><span class="line">            swap(arr, index++, ++less); <span class="comment">// 当前值交换到小于区域, 小于区域右边界+1, index+1</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; arr[r]) {</span><br><span class="line">            swap(arr, index, --more); <span class="comment">// 当前值交换到大于区域, 大于区域左边界-1, index不动因为交换过来的值没判断过</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    swap(arr, more, r); <span class="comment">// arr[r] 交换到大于区域左边界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] { less + <span class="number">1</span>, more }; <span class="comment">// 等于区域边界</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="普通快速排序"><a href="#普通快速排序" class="headerlink" title="普通快速排序"></a>普通快速排序</h1><p>普通快速排序直接利用荷兰国旗问题递归求解，复杂度为O(N^2)，当数组本身有序时，每次都需要对[0,r-1]做分区处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通快排 O(N^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R] 排有序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// [equalArea[0] , equalArea[0]]</span></span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="随机快速排序"><a href="#随机快速排序" class="headerlink" title="随机快速排序*"></a>随机快速排序*</h1><p>随机快速排序是针对普通快排优化后的排序算法，也是通常快速排序所指的排序方式，复杂度为O(N*logN)，最好最坏情况都是概率事件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机快速排序 O(N*logN)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="非递归实现快排"><a href="#非递归实现快排" class="headerlink" title="非递归实现快排"></a>非递归实现快排</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排非递归版本需要的辅助类</span></span><br><span class="line"><span class="comment">// 要处理的是什么范围上的排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Op</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        l = left;</span><br><span class="line">        r = right;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排非递归版本 用栈来执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortByStack</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    swap(arr, (<span class="keyword">int</span>) (Math.random() * N), N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> el = equalArea[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> er = equalArea[<span class="number">1</span>];</span><br><span class="line">    Stack&lt;Op&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Op(<span class="number">0</span>, el - <span class="number">1</span>));</span><br><span class="line">    stack.push(<span class="keyword">new</span> Op(er + <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">        Op op = stack.pop(); <span class="comment">// op.l ... op.r</span></span><br><span class="line">        <span class="keyword">if</span> (op.l &lt; op.r) {</span><br><span class="line">            swap(arr, op.l + (<span class="keyword">int</span>) (Math.random() * (op.r - op.l + <span class="number">1</span>)), op.r);</span><br><span class="line">            equalArea = netherlandsFlag(arr, op.l, op.r);</span><br><span class="line">            el = equalArea[<span class="number">0</span>];</span><br><span class="line">            er = equalArea[<span class="number">1</span>];</span><br><span class="line">            stack.push(<span class="keyword">new</span> Op(op.l, el - <span class="number">1</span>));</span><br><span class="line">            stack.push(<span class="keyword">new</span> Op(er + <span class="number">1</span>, op.r));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排非递归版本 用队列来执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortByQueue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    swap(arr, (<span class="keyword">int</span>) (Math.random() * N), N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> el = equalArea[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> er = equalArea[<span class="number">1</span>];</span><br><span class="line">    Queue&lt;Op&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> Op(<span class="number">0</span>, el - <span class="number">1</span>));</span><br><span class="line">    queue.offer(<span class="keyword">new</span> Op(er + <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        Op op = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (op.l &lt; op.r) {</span><br><span class="line">            swap(arr, op.l + (<span class="keyword">int</span>) (Math.random() * (op.r - op.l + <span class="number">1</span>)), op.r);</span><br><span class="line">            equalArea = netherlandsFlag(arr, op.l, op.r);</span><br><span class="line">            el = equalArea[<span class="number">0</span>];</span><br><span class="line">            er = equalArea[<span class="number">1</span>];</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Op(op.l, el - <span class="number">1</span>));</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Op(er + <span class="number">1</span>, op.r));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速排序算法（Quicksort），简称为“快排”，利用的是分治思想。&lt;/p&gt;
&lt;p&gt;快排思想：(要排序数组中下标从 p 到 r 之间的一组数据)&lt;/p&gt;
&lt;p&gt;选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。&lt;br&gt;遍历 p 到 r 之间的数据，将小于 p</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://haifuns.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】归并排序</title>
    <link href="https://haifuns.com/2022/06/29/algorithm-mergesort/"/>
    <id>https://haifuns.com/2022/06/29/algorithm-mergesort/</id>
    <published>2022-06-29T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并。</p><p>根据Master公式，T(N) = 2 * T(N/2) + O(N)，a=2，b=2，d=1, log(b,a)==d，所以时间复杂度为O(N * logN)。</p><h1 id="归并排序递归实现"><a href="#归并排序递归实现" class="headerlink" title="归并排序递归实现"></a>归并排序递归实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中点位置 (l+r)/2</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分后分别排序</span></span><br><span class="line">    process(arr, l, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并已经排好序的两块数组</span></span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用两个指针分别指向[l,mid], (mid, r]</span></span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常范围, 依次比较, 小的放到辅助数组, 指针后移</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p1没越界, p2越界, 把p1剩下的数拷贝到辅助数组</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) {</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p2没越界, p1越界, 把p2剩下的数拷贝到辅助数组</span></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) {</span><br><span class="line">        arr[l + j] = help[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="归并排序非递归实现"><a href="#归并排序非递归实现" class="headerlink" title="归并排序非递归实现"></a>归并排序非递归实现</h1><p>非递归核心在于操作步长</p><ol><li>步长为2^0, 每1个一组排序</li><li>步长为2^1, 每2个一组排序, 最后凑不够单独一组</li><li>步长为2^2, 每4个一组排序, 最后凑不够单独一组</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> N = arr.length;</span><br><span class="line">  <span class="comment">// 步长</span></span><br><span class="line">  <span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (mergeSize &lt; N) { <span class="comment">// log N</span></span><br><span class="line">    <span class="comment">// 当前左组的，第一个位置</span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; N) {</span><br><span class="line">      <span class="keyword">if</span> (mergeSize &gt;= N - L) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> R = M + Math.min(mergeSize, N - M - <span class="number">1</span>);</span><br><span class="line">      merge(arr, L, M, R);</span><br><span class="line">      L = R + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 防止溢出</span></span><br><span class="line">    <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> p1 = L;</span><br><span class="line">  <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) {</span><br><span class="line">    help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= M) {</span><br><span class="line">    help[i++] = arr[p1++];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= R) {</span><br><span class="line">    help[i++] = arr[p2++];</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) {</span><br><span class="line">    arr[L + i] = help[i];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="1-小和问题"><a href="#1-小和问题" class="headerlink" title="1. 小和问题"></a>1. 小和问题</h1><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求指定数组的小和。</p><p>归并解题思路：<br>找到每个数右边更大的数数量*当前数，求和</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[l..r]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的小和，累加</span></span><br><span class="line"><span class="comment">// 左 排序   merge</span></span><br><span class="line"><span class="comment">// 右 排序  merge</span></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(arr, l, mid) +</span><br><span class="line">           process(arr, mid + <span class="number">1</span>, r) +</span><br><span class="line">           merge(arr, l, mid, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) {</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>; <span class="comment">// 左侧第一个数比右侧第一个更小, 此时右侧剩余的数都更大</span></span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) {</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) {</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-逆序对问题（LeetCode-剑指-Offer-51-hard）"><a href="#2-逆序对问题（LeetCode-剑指-Offer-51-hard）" class="headerlink" title="2. 逆序对问题（LeetCode 剑指 Offer 51. hard）"></a>2. 逆序对问题（LeetCode 剑指 Offer 51. hard）</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reversePairNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求逆序对数量返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的逆序对数量，累加，返回</span></span><br><span class="line"><span class="comment">// 左 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">// 右 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(arr, l, mid) + process(arr, mid + <span class="number">1</span>, r) + merge(arr, l, mid, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = help.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = m;</span><br><span class="line">    <span class="keyword">int</span> p2 = r;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L &amp;&amp; p2 &gt; m) {</span><br><span class="line">        res += arr[p1] &gt; arr[p2] ? (p2 - m) : <span class="number">0</span>; <span class="comment">// 如果p1位置数大于p2位置，那么从m-p2都小于p1</span></span><br><span class="line">        help[i--] = arr[p1] &gt; arr[p2] ? arr[p1--] : arr[p2--]; <span class="comment">// 逆序合并</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L) {</span><br><span class="line">        help[i--] = arr[p1--];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &gt; m) {</span><br><span class="line">        help[i--] = arr[p2--];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) {</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-翻转对问题（LeetCode-493-hard）"><a href="#3-翻转对问题（LeetCode-493-hard）" class="headerlink" title="3. 翻转对问题（LeetCode 493. hard）"></a>3. 翻转对问题（LeetCode 493. hard）</h1><p>给定一个数组nums，如果i &lt; j且nums[i] &gt; 2*nums[j]就将(i, j)称作一个重要翻转对。返回给定数组中的重要翻转对的数量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(arr, l, mid) + process(arr, mid + <span class="number">1</span>, r) + merge(arr, l, mid, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="comment">// [L....M] [M+1....R]</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先统计数量</span></span><br><span class="line">    <span class="comment">// 目前囊括进来的数，是从[M+1, windowR)</span></span><br><span class="line">    <span class="keyword">int</span> windowR = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= r &amp;&amp; (<span class="keyword">long</span>) arr[i] &gt; (<span class="keyword">long</span>) arr[windowR] * <span class="number">2</span>) { <span class="comment">// 不需要回溯</span></span><br><span class="line">            windowR++;</span><br><span class="line">        }</span><br><span class="line">        ans += windowR - m - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个排序数组</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) {</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) {</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) {</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-区间和的个数（LeetCode-327-hard）"><a href="#4-区间和的个数（LeetCode-327-hard）" class="headerlink" title="4. 区间和的个数（LeetCode 327. hard）"></a>4. 区间和的个数（LeetCode 327. hard）</h1><p>给定一个整数数组nums 以及两个整数lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含lower和upper）之内的 区间和的个数 。<br>区间和S(i, j)表示在nums中，位置从i到j的元素之和，包含i和j(i ≤ j)。</p><p>思路：<br>S(i, j) = S(0,j) - S(0,i-1)，提前准备好前缀和数组，用前缀和相减减少频繁累加i-j。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// S(i, j) = S(0, j) - S(0, i-1), 用前缀和相减代替遍历求和</span></span><br><span class="line">    <span class="comment">// 提前准备好前缀和数组</span></span><br><span class="line">    <span class="keyword">long</span>[] sum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length];</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> process(sum, <span class="number">0</span>, sum.length - <span class="number">1</span>, lower, upper);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">long</span>[] sum, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (L == R) { <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">return</span> sum[L] &gt;= lower &amp;&amp; sum[L] &lt;= upper ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 不能再merge直接判断</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> process(sum, L, M, lower, upper) + process(sum, M + <span class="number">1</span>, R, lower, upper)</span><br><span class="line">           + merge(sum, L, M, R, lower, upper);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">long</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> windowL = L;</span><br><span class="line">    <span class="keyword">int</span> windowR = L;</span><br><span class="line">    <span class="comment">// [windowL, windowR)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= R; i++) { <span class="comment">// [M+1,R]</span></span><br><span class="line">        <span class="keyword">long</span> min = arr[i] - upper; <span class="comment">// 最小前缀和</span></span><br><span class="line">        <span class="keyword">long</span> max = arr[i] - lower; <span class="comment">// 最大前缀和</span></span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= M &amp;&amp; arr[windowR] &lt;= max) {</span><br><span class="line">            windowR++; <span class="comment">// 满足条件的最大位置</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (windowL &lt;= M &amp;&amp; arr[windowL] &lt; min) {</span><br><span class="line">            windowL++; <span class="comment">// 满足条件的最小位置</span></span><br><span class="line">        }</span><br><span class="line">        ans += windowR - windowL; <span class="comment">// 满足条件的前缀和个数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span>[] help = <span class="keyword">new</span> <span class="keyword">long</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) {</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) {</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) {</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) {</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;归并排序：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并。&lt;/p&gt;
&lt;p&gt;根据Master公式，T(N) = 2 * T(N/2) + O(N)，a=2，b=2，d=1, log(b,a)==d，所以时间复杂度为O(N *</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="归并" scheme="https://haifuns.com/tags/%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】递归</title>
    <link href="https://haifuns.com/2022/06/26/algorithm-recursion/"/>
    <id>https://haifuns.com/2022/06/26/algorithm-recursion/</id>
    <published>2022-06-26T14:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。递归是一种应用非常广泛的算法（或者编程技巧）。</p><p>递归的优缺点：</p><ul><li>优点：代码简洁、清晰、可读性高。</li><li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算（如斐波那契数列的递归）、过多的函数调用会耗时较多等问题。</li></ul><p>递归需要满足的三个条件：</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><p>如何编写递归代码？：<br>写递归代码最关键的是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><h1 id="从数组中找到最大值（递归实现）"><a href="#从数组中找到最大值（递归实现）" class="headerlink" title="从数组中找到最大值（递归实现）"></a>从数组中找到最大值（递归实现）</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求arr中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[l..r]位置找到最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">    <span class="comment">// arr[l..r]范围只有一个数, 直接返回, bad case</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) {</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> leftMax = process(arr, l, mid);</span><br><span class="line">    <span class="keyword">int</span> rightMax = process(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="递归复杂度分析：Master公式"><a href="#递归复杂度分析：Master公式" class="headerlink" title="递归复杂度分析：Master公式"></a>递归复杂度分析：Master公式</h1><p>T(N) = a * T(N/b) + O(N^d)，a,b,d都是常数。</p><p>Master公式估计递归复杂度要求：子问题规模一致都是N/b，调用了a次，除了调用子问题其他问题的时间复杂度O(N^d)。</p><p>满足条件通过Master公式来确定时间复杂度：</p><ol><li>如果 log(b,a) &lt; d，复杂度为O(N^d)</li><li>如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))</li><li>如果 log(b,a) == d，复杂度为O(N^d * logN)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。递归是一种应用非常广泛的算法（或者编程技巧）。&lt;/p&gt;
&lt;p&gt;递归的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：代码简洁、清晰、可读性高。&lt;/li&gt;
&lt;li&gt;缺点：空间复杂度高、有堆栈溢出风险、存在重复计算（如斐波</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归" scheme="https://haifuns.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】链表、栈、队列</title>
    <link href="https://haifuns.com/2022/06/24/algorithm-datastructure/"/>
    <id>https://haifuns.com/2022/06/24/algorithm-datastructure/</id>
    <published>2022-06-24T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">private</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1. 链表反转"></a>1. 链表反转</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) {</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转双链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DoubleNode <span class="title">reverseDoubleLinkedList</span><span class="params">(DoubleNode head)</span> </span>{</span><br><span class="line"></span><br><span class="line">    DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">    DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) {</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.last = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-给定值删除"><a href="#2-给定值删除" class="headerlink" title="2. 给定值删除"></a>2. 给定值删除</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeValue</span><span class="params">(Node head, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="comment">// 移除头部为指定值的节点</span></span><br><span class="line">    <span class="comment">// 移动head到第一个不需要删除的位置</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (head.value != num) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (cur.value == num) {</span><br><span class="line">            pre.next = cur.next; <span class="comment">// 将前一个node.next设置为当前这个node的下一个node</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pre = cur;</span><br><span class="line">        }</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈：数据先进后出，犹如弹匣<br>队列：数据先进先出，好似排队</p><p>栈和队列的实际实现方式：</p><ul><li>双向链表实现</li><li>数组实现</li></ul><h2 id="1-双向链表实现栈和队列"><a href="#1-双向链表实现栈和队列" class="headerlink" title="1. 双向链表实现栈和队列"></a>1. 双向链表实现栈和队列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListToQueueAndStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.value = v;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(V v)</span> </span>{</span><br><span class="line"></span><br><span class="line">            Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;V&gt;(v);</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="keyword">null</span>) {</span><br><span class="line">                head = cur;</span><br><span class="line">                tail = cur;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                tail.next = cur;</span><br><span class="line">                tail = cur;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">            V ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">                ans = head.value;</span><br><span class="line">                head = head.next;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">            V ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">                ans = head.value;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(V v)</span> </span>{</span><br><span class="line">            Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;V&gt;(v);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">                head = cur;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur.next = head;</span><br><span class="line">                head = cur;</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">            V ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">                ans = head.value;</span><br><span class="line">                head = head.next;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> head != <span class="keyword">null</span> ? head.value : <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-数组实现栈和队列"><a href="#2-数组实现栈和队列" class="headerlink" title="2. 数组实现栈和队列"></a>2. 数组实现栈和队列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayToQueueAndStack</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环数组实现队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> pushi;<span class="comment">// end</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> polli;<span class="comment">// begin</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>{</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="keyword">int</span>[limit];</span><br><span class="line">            pushi = <span class="number">0</span>;</span><br><span class="line">            polli = <span class="number">0</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (size == limit) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列满了，不能再加了"</span>);</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">            arr[pushi] = value;</span><br><span class="line">            pushi = nextIndex(pushi);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空了，不能再拿了"</span>);</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">int</span> ans = arr[polli];</span><br><span class="line">            polli = nextIndex(polli);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果现在的下标是i，返回下一个位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> i &lt; limit - <span class="number">1</span> ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>; <span class="comment">//栈顶</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (top &gt; arr.length - <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈满了，不能再加了"</span>);</span><br><span class="line">            }</span><br><span class="line">            arr[++top] = num;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (top &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空了，不能再拿了"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> arr[top--];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"><a href="#3-实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能" class="headerlink" title="3. 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能"></a>3. 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</h2><p>要求：</p><ol><li>pop、push、getMin操作的时间复杂度都是O(1)</li><li>设计的栈类型可以使用现成的栈结构</li></ol><p>思路：<br>两个栈：数据栈+最小栈<br>push时，数据栈正常压入，最小栈压入当前最小值<br>pop时，数据栈弹出返回，最小栈弹出<br>getMin，最小栈peek</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) {</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="keyword">this</span>.getmin()) {</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> newMin = <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newMin);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-栈实现队列，队列实现栈"><a href="#4-栈实现队列，队列实现栈" class="headerlink" title="4. 栈实现队列，队列实现栈"></a>4. 栈实现队列，队列实现栈</h2><p>栈实现队列思路：<br>两个栈实现队列，一个push栈一个pop栈，队列push压入push栈，队列poll从pop弹出</p><ol><li>从push栈倒数据到pop栈要一次性倒完</li><li>pop栈空了才能倒数据</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacksQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push栈向pop栈倒入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushToPop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty()) {</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.empty()) {</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>{</span><br><span class="line">        stackPush.push(pushInt);</span><br><span class="line">        pushToPop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        }</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        }</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>队列实现栈思路：<br>两个队列，push进第一个队列，pop时poll第一个队列所有元素，如果是第一个队列最后一个值直接返回，如果不是push进第二个队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span> </span>{</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> </span>{</span><br><span class="line">        queue.offer(value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) {</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        }</span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        Queue&lt;T&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) {</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        }</span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        help.offer(ans);</span><br><span class="line">        Queue&lt;T&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;h2 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://haifuns.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】异或运算</title>
    <link href="https://haifuns.com/2022/06/22/algorithm-xor/"/>
    <id>https://haifuns.com/2022/06/22/algorithm-xor/</id>
    <published>2022-06-22T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.041Z</updated>
    
    <content type="html"><![CDATA[<p>异或运算：相同为0，不同为1。异或运算相当于无进位相加。</p><h1 id="1-不用额外变量交换两个数"><a href="#1-不用额外变量交换两个数" class="headerlink" title="1. 不用额外变量交换两个数"></a>1. 不用额外变量交换两个数</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line"></span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b; <span class="comment">// a ^ b ^ b = a</span></span><br><span class="line">    a = a ^ b; <span class="comment">// a ^ b ^ a = b</span></span><br><span class="line"></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = { <span class="number">1</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">61</span> };</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    swap(arr, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或实现数组位置交换</span></span><br><span class="line"><span class="comment">// 前提是i, j不为同一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j]; <span class="comment">// arr[i] ^ arr[j] ^ arr[j] = arr[i]</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// arr[i] ^ arr[j] ^ arr[i] = arr[j]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-一个数组中有一个数出现了奇数次，其他数出现偶数次，找到出现奇数次的数"><a href="#2-一个数组中有一个数出现了奇数次，其他数出现偶数次，找到出现奇数次的数" class="headerlink" title="2. 一个数组中有一个数出现了奇数次，其他数出现偶数次，找到出现奇数次的数"></a>2. 一个数组中有一个数出现了奇数次，其他数出现偶数次，找到出现奇数次的数</h1><p>遍历异或，结果是出现奇数次的数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] arr2 = { <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span> };</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) {</span><br><span class="line">        ans = ans ^ arr2[i];</span><br><span class="line">    }</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-怎么提取出一个int类型的数二进制最低位的1"><a href="#3-怎么提取出一个int类型的数二进制最低位的1" class="headerlink" title="3. 怎么提取出一个int类型的数二进制最低位的1"></a>3. 怎么提取出一个int类型的数二进制最低位的1</h1><p><code>a &amp; (~a+1)</code> 即 <code>a &amp; -a</code>。</p><p>补码公式：<code>-n = ~n + 1</code>，引申：<code>~n = -n - 1</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         a = 011011100110000</span><br><span class="line">        ~a = 100100011001111</span><br><span class="line">    ~a + 1 = 100100011010000 = -a</span><br><span class="line">a &amp; (~a+1) = 000000000010000</span><br></pre></td></tr></tbody></table></figure><h1 id="4-一个数组中有两种数出现了奇数次，其他数出现偶数次，找到出现奇数次的数"><a href="#4-一个数组中有两种数出现了奇数次，其他数出现偶数次，找到出现奇数次的数" class="headerlink" title="4. 一个数组中有两种数出现了奇数次，其他数出现偶数次，找到出现奇数次的数"></a>4. 一个数组中有两种数出现了奇数次，其他数出现偶数次，找到出现奇数次的数</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        eor ^= arr[i]; <span class="comment">// 最终eor得到两个奇数异或后的值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">// 提取出最右的1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) { <span class="comment">// &amp;运算不等于0, 满足条件条件的是部分出现偶数次的数和一个奇数次的数</span></span><br><span class="line">            onlyOne ^= arr[i]; <span class="comment">// 最终eor'为在eor最右1位置不为1的奇数</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(onlyOne + <span class="string">" "</span> + (eor ^ onlyOne)); <span class="comment">// eor ^ eor'得到另一个奇数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="5-一个数组中有一种数出现了K次，其他数出现M次，1-lt-x3D-K-lt-M，找到出现K次的数"><a href="#5-一个数组中有一种数出现了K次，其他数出现M次，1-lt-x3D-K-lt-M，找到出现K次的数" class="headerlink" title="5. 一个数组中有一种数出现了K次，其他数出现M次，1 <= K < M，找到出现K次的数"></a>5. 一个数组中有一种数出现了K次，其他数出现M次，1 &lt;= K &lt; M，找到出现K次的数</h1><p>要求：额外空间复杂度O(1)，时间复杂度O(n)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onlyKTimes</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">// 整个数组二进制每位计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) {</span><br><span class="line">            help[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) {</span><br><span class="line">        help[i] %= m; <span class="comment">// 取余不为0说明是出现k次的数</span></span><br><span class="line">        <span class="keyword">if</span> (help[i] != <span class="number">0</span>) {</span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i; <span class="comment">// 合并每一个二进制位</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异或运算：相同为0，不同为1。异或运算相当于无进位相加。&lt;/p&gt;
&lt;h1 id=&quot;1-不用额外变量交换两个数&quot;&gt;&lt;a href=&quot;#1-不用额外变量交换两个数&quot; class=&quot;headerlink&quot; title=&quot;1. 不用额外变量交换两个数&quot;&gt;&lt;/a&gt;1. 不用额外变量交</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="异或" scheme="https://haifuns.com/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】二分法</title>
    <link href="https://haifuns.com/2022/06/21/algorithm-dichotomy/"/>
    <id>https://haifuns.com/2022/06/21/algorithm-dichotomy/</id>
    <published>2022-06-21T14:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<p>二分法是一种常用的算法，对于一个有序数组，通过折半查找的方式可以有效降低查找时的时间复杂度，O(n) -&gt; O(logn)。但是有序并不是所有问题求解时使用二分的必要条件，只要能正确构建左右两侧的淘汰逻辑就可以使用二分。</p><h1 id="1-在一个有序数组中，找到某个数是否存在"><a href="#1-在一个有序数组中，找到某个数是否存在" class="headerlink" title="1. 在一个有序数组中，找到某个数是否存在"></a>1. 在一个有序数组中，找到某个数是否存在</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == num) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; num) {</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2-在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2. 在一个有序数组中，找>=某个数最左侧的位置"></a>2. 在一个有序数组中，找&gt;=某个数最左侧的位置</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mostLeftNoLessNumIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) {</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-在一个有序数组中，找-lt-x3D-某个数最右侧的位置"><a href="#3-在一个有序数组中，找-lt-x3D-某个数最右侧的位置" class="headerlink" title="3. 在一个有序数组中，找<=某个数最右侧的位置"></a>3. 在一个有序数组中，找&lt;=某个数最右侧的位置</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostRightNoLessNumIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= num) {</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-局部最小值问题，数据整体无序且满足相邻的数不相等-返回一个局部最小"><a href="#4-局部最小值问题，数据整体无序且满足相邻的数不相等-返回一个局部最小" class="headerlink" title="4. 局部最小值问题，数据整体无序且满足相邻的数不相等, 返回一个局部最小"></a>4. 局部最小值问题，数据整体无序且满足相邻的数不相等, 返回一个局部最小</h1><p>局部最小:</p><ol><li>arr[0] &lt; arr[1], 则0是局部最小</li><li>arr[n-2] &gt; arr[n-1], 则n-1是局部最小</li><li>arr[i-1] &lt; arr[i] &lt; arr[i+1], 则i为局部最小</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">oneMinIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最左局部最小</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最右局部最小</span></span><br><span class="line">    <span class="keyword">if</span> (arr[n - <span class="number">2</span>] &gt; arr[n - <span class="number">1</span>]) {</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通情况局部最小</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r - <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 直接满足局部最小</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &gt; arr[mid] &amp;&amp; arr[mid] &lt; arr[mid + <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 此时arr最左下降↘, 最右上升↗</span></span><br><span class="line">            <span class="comment">// 如果mid左侧上升, 则0 - mid之间必存在局部最小, ↘ ... ↗, 移动右边界</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) {</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[l] &lt; arr[r] ? l : r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二分法是一种常用的算法，对于一个有序数组，通过折半查找的方式可以有效降低查找时的时间复杂度，O(n) -&amp;gt; O(logn)。但是有序并不是所有问题求解时使用二分的必要条件，只要能正确构建左右两侧的淘汰逻辑就可以使用二分。&lt;/p&gt;
&lt;h1 id=&quot;1-在一个有序数组中，</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分法" scheme="https://haifuns.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法基础】复杂度分析</title>
    <link href="https://haifuns.com/2022/06/20/algorithm-complexity/"/>
    <id>https://haifuns.com/2022/06/20/algorithm-complexity/</id>
    <published>2022-06-20T14:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<p>衡量不同算法之间的优劣主要是从算法所占用的「时间」、「空间」两个维度考量，即：</p><ul><li>时间维度：指执行当前算法所消耗的时间，由流程决定，通常用「时间复杂度」描述。</li><li>空间维度：指执行当前算法需要占用多少内存空间，由流程决定，通常用「空间复杂度」描述。</li></ul><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>时间复杂度通过运行程序验证所消耗时间时，受运行环境、数据规模等因素影响差异很大，因此使用通用表示法描述时间复杂度。例如，大O符号表示法，即T(n) = O(f(n))，表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度（asymptotic time complexity）。</p><p><strong>常见时间复杂度量级：</strong></p><ol><li>常数阶O(1)</li><li>线性阶O(n)</li><li>对数阶O(logn)、线性对数阶O(nlogn)</li><li>平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)</li><li>指数阶O(2^n)</li><li>阶乘阶O(n!)</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1) &lt; O(logn) &lt; O(√n) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)</span><br></pre></td></tr></tbody></table></figure><h2 id="常数时间操作"><a href="#常数时间操作" class="headerlink" title="常数时间操作"></a>常数时间操作</h2><p>常数时间操作与算法流程无关，而与实现细节有关，通常不需要参与时间复杂度评估。</p><p>常见的常数时间操作有：</p><ul><li>算术运算，+、-、*、/、%等</li><li>位运算，&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;、|、&amp;、^等</li><li>赋值、比较、自增、自减操作</li><li>数组寻址操作</li></ul><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度全称是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。空间复杂度是对算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。常用的有：O(1)、O(n)、O(n^2)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;衡量不同算法之间的优劣主要是从算法所占用的「时间」、「空间」两个维度考量，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：指执行当前算法所消耗的时间，由流程决定，通常用「时间复杂度」描述。&lt;/li&gt;
&lt;li&gt;空间维度：指执行当前算法需要占用多少内存空间，由流程决定，通常用「空间复</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="复杂度" scheme="https://haifuns.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法体系学习</title>
    <link href="https://haifuns.com/2022/06/15/algorithm-all/"/>
    <id>https://haifuns.com/2022/06/15/algorithm-all/</id>
    <published>2022-06-15T02:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法学习路线"><a href="#算法学习路线" class="headerlink" title="算法学习路线"></a>算法学习路线</h1><ul><li><a href="https://haifuns.com/2022/06/20/algorithm-complexity/">【算法基础】复杂度分析</a></li><li><a href="https://haifuns.com/2022/06/21/algorithm-dichotomy/">【算法基础】二分法</a></li><li><a href="https://haifuns.com/2022/06/22/algorithm-xor/">【算法基础】异或运算</a></li><li><a href="https://haifuns.com/2022/06/24/algorithm-datastructure">【算法基础】链表、栈、队列</a></li><li><a href="https://haifuns.com/2022/06/26/algorithm-recursion">【算法基础】递归</a></li><li><a href="https://haifuns.com/2022/06/29/algorithm-mergesort">【算法基础】归并排序</a></li><li><a href="https://haifuns.com/2022/06/30/algorithm-quicksort">【算法基础】快速排序</a></li><li><a href="https://haifuns.com/2022/07/04/algorithm-heapandheapsort">【算法基础】堆和堆排序</a></li><li><a href="https://haifuns.com/2022/07/06/algorithm-heapgreater">【算法基础】加强堆</a></li><li><a href="https://haifuns.com/2022/07/17/algorithm-trietree">【算法基础】前缀树</a></li><li><a href="https://haifuns.com/2022/07/17/algorithm-uncomparesort">【算法基础】不基于比较的排序（计数、基数）</a></li><li><a href="https://haifuns.com/2022/07/18/algorithm-sort/">【算法基础】排序算法（总）</a></li><li><a href="https://haifuns.com/2022/07/25/algorithm-linkedlist/">【算法基础】链表专练</a></li><li><a href="https://haifuns.com/2022/07/30/algorithm-binarytree/">【算法基础】二叉树</a></li><li><a href="https://haifuns.com/2022/07/30/algorithm-binarytree-problem1/">【算法基础】二叉树专练（一）</a></li><li><a href="https://haifuns.com/2022/08/16/algorithm-binarytree-problem2/">【算法基础】二叉树专练（二）</a></li><li><a href="https://haifuns.com/2022/08/28/algorithm-greddy">【算法基础】贪心算法</a></li><li><a href="https://haifuns.com/2022/08/30/algorithm-unionfind">【算法基础】并查集</a></li><li><a href="https://haifuns.com/2022/08/31/algorithm-graph">【算法基础】图</a></li><li><a href="https://haifuns.com/2022/09/01/algorithm-recursion-procedure">【算法基础】经典递归过程</a></li><li><a href="https://haifuns.com/2022/09/03/algorithm-dp1">【算法基础】暴力递归到动态规划（一）</a></li><li><a href="https://haifuns.com/2022/09/04/algorithm-dp2">【算法基础】暴力递归到动态规划（二）</a></li><li><a href="https://haifuns.com/2022/09/05/algorithm-dp3">【算法基础】暴力递归到动态规划（三）</a></li><li><a href="https://haifuns.com/2022/09/06/algorithm-dp4">【算法基础】暴力递归到动态规划（四）</a></li><li><a href="https://haifuns.com/2022/09/07/algorithm-dp5">【算法基础】暴力递归到动态规划（五）</a></li><li><a href="https://haifuns.com/2022/09/11/algorithm-dp6">【算法基础】暴力递归到动态规划（六）</a></li><li><a href="https://haifuns.com/2022/09/11/algorithm-dp">【算法基础】暴力递归到动态规划（小结）</a></li></ul><h1 id="常备算法网站"><a href="#常备算法网站" class="headerlink" title="常备算法网站"></a>常备算法网站</h1><ul><li><a href="https://leetcode.cn/problemset/all/">leetcode：算法题库</a></li><li><a href="https://visualgo.net/zh">visualgo：算法可视化</a></li><li><a href="https://www.bigocheatsheet.com/">bigocheatsheet：常用算法数据结构复杂度速查表</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法学习路线&quot;&gt;&lt;a href=&quot;#算法学习路线&quot; class=&quot;headerlink&quot; title=&quot;算法学习路线&quot;&gt;&lt;/a&gt;算法学习路线&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://haifuns.com/2022/06/20/algorith</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://haifuns.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】故障感知与恢复</title>
    <link href="https://haifuns.com/2022/04/12/zookeeper-09/"/>
    <id>https://haifuns.com/2022/04/12/zookeeper-09/</id>
    <published>2022-04-12T04:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.050Z</updated>
    
    <content type="html"><![CDATA[<p>本篇着重关注zk中对各种故障的感知与恢复，下面将针对不同的故障情况进行分析。</p><h1 id="消息通信故障"><a href="#消息通信故障" class="headerlink" title="消息通信故障"></a>消息通信故障</h1><h2 id="客户端故障"><a href="#客户端故障" class="headerlink" title="客户端故障"></a>客户端故障</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIOServerCnxn.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(SelectionKey k)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (sock == <span class="keyword">null</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"trying to do i/o on a null socket for session:0x"</span></span><br><span class="line">                     + Long.toHexString(sessionId));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k.isReadable()) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k.isWritable()) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (CancelledKeyException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Exception causing close of session 0x"</span></span><br><span class="line">                 + Long.toHexString(sessionId)</span><br><span class="line">                 + <span class="string">" due to "</span> + e);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"CancelledKeyException stack trace"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        close();</span><br><span class="line">    } <span class="keyword">catch</span> (CloseRequestException e) {</span><br><span class="line">        <span class="comment">// expecting close to log session closure</span></span><br><span class="line">        close();</span><br><span class="line">    } <span class="keyword">catch</span> (EndOfStreamException e) {</span><br><span class="line">        LOG.warn(<span class="string">"caught end of stream exception"</span>, e); <span class="comment">// tell user why</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// expecting close to log session closure</span></span><br><span class="line">        close();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Exception causing close of session 0x"</span></span><br><span class="line">                 + Long.toHexString(sessionId)</span><br><span class="line">                 + <span class="string">" due to "</span> + e);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"IOException stack trace"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (factory.cnxns) {</span><br><span class="line">        <span class="comment">// if this is not in cnxns then it's already closed</span></span><br><span class="line">        <span class="keyword">if</span> (!factory.cnxns.remove(<span class="keyword">this</span>)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (factory.ipMap) {</span><br><span class="line">            Set&lt;NIOServerCnxn&gt; s =</span><br><span class="line">                factory.ipMap.get(sock.socket().getInetAddress());</span><br><span class="line">            s.remove(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        factory.unregisterConnection(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkServer != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 移除watcher</span></span><br><span class="line">            zkServer.removeCnxn(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        closeSock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sk != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// need to cancel this selection key from the selector</span></span><br><span class="line">                sk.cancel();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                    LOG.debug(<span class="string">"ignoring exception during selectionkey cancel"</span>, e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当客户端故障时，服务端会捕获相应的异常，接着移除连接实例，移除当前客户端注册的watcher，最后关闭底层连接。</p><h2 id="服务端故障"><a href="#服务端故障" class="headerlink" title="服务端故障"></a>服务端故障</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn.SendThread.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    clientCnxnSocket.introduce(<span class="keyword">this</span>, sessionId);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">long</span> lastPingRwServer = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span> (state.isAlive()) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) {</span><br><span class="line">                <span class="comment">// 当前不是第一次连接</span></span><br><span class="line">                <span class="keyword">if</span> (!isFirstConnect) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// don't re-establish connection if we are closing</span></span><br><span class="line">                <span class="keyword">if</span> (closing || !state.isAlive()) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 与zk服务端建立长连接</span></span><br><span class="line">                startConnect();</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            <span class="keyword">if</span> (closing) {</span><br><span class="line">                <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                    <span class="comment">// closing so this is expected</span></span><br><span class="line">                    LOG.debug(<span class="string">"An exception was thrown while closing send thread for session 0x"</span></span><br><span class="line">                              + Long.toHexString(getSessionId())</span><br><span class="line">                              + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// this is ugly, you have a better way speak up</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionExpiredException) {</span><br><span class="line">                    LOG.info(e.getMessage() + <span class="string">", closing socket connection"</span>);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SessionTimeoutException) {</span><br><span class="line">                    LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> EndOfStreamException) {</span><br><span class="line">                    LOG.info(e.getMessage() + RETRY_CONN_MSG);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RWServerFoundException) {</span><br><span class="line">                    LOG.info(e.getMessage());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    LOG.warn(</span><br><span class="line">                        <span class="string">"Session 0x"</span></span><br><span class="line">                        + Long.toHexString(getSessionId())</span><br><span class="line">                        + <span class="string">" for server "</span></span><br><span class="line">                        + clientCnxnSocket.getRemoteSocketAddress()</span><br><span class="line">                        + <span class="string">", unexpected error"</span></span><br><span class="line">                        + RETRY_CONN_MSG, e);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 关闭连接、标记所有请求失败</span></span><br><span class="line">                cleanup();</span><br><span class="line">                <span class="keyword">if</span> (state.isAlive()) {</span><br><span class="line">                    <span class="comment">// 发布一个disconnected事件</span></span><br><span class="line">                    <span class="comment">// 创建ZooKeeper时加的默认监听器</span></span><br><span class="line">                    eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                               Event.EventType.None,</span><br><span class="line">                                               Event.KeeperState.Disconnected,</span><br><span class="line">                                               <span class="keyword">null</span>));</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 重新更新底层网络连接初始化时间</span></span><br><span class="line">                clientCnxnSocket.updateNow();</span><br><span class="line">                <span class="comment">// 重新初始化底层网络连接最近一次发送和接收请求响应的时间</span></span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 客户端状态异常处理</span></span><br><span class="line">    cleanup();</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    <span class="keyword">if</span> (state.isAlive()) {</span><br><span class="line">        eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(Event.EventType.None,</span><br><span class="line">                                                Event.KeeperState.Disconnected, <span class="keyword">null</span>));</span><br><span class="line">    }</span><br><span class="line">    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),</span><br><span class="line">                             <span class="string">"SendThread exitedloop."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当与客户端已经建立好连接的服务端节点故障，客户端会在消息发送时捕获到异常，接着关闭连接、标记所有请求失败，重新选择一个服务端节点建立连接。</p><h1 id="集群间故障"><a href="#集群间故障" class="headerlink" title="集群间故障"></a>集群间故障</h1><h2 id="follower故障"><a href="#follower故障" class="headerlink" title="follower故障"></a>follower故障</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LearnerHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ia = BinaryInputArchive.getArchive(<span class="keyword">new</span> BufferedInputStream(sock</span><br><span class="line">                                           .getInputStream()));</span><br><span class="line">        bufferedOutput = <span class="keyword">new</span> BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        oa = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来循环处理正常消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">            ia.readRecord(qp, <span class="string">"packet"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">if</span> (sock != <span class="keyword">null</span> &amp;&amp; !sock.isClosed()) {</span><br><span class="line">            LOG.error(<span class="string">"Unexpected exception causing shutdown while sock "</span></span><br><span class="line">                      + <span class="string">"still open"</span>, e);</span><br><span class="line">            <span class="comment">//close the socket to make sure the</span></span><br><span class="line">            <span class="comment">//other side can see it being close</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// io异常关闭socket</span></span><br><span class="line">                sock.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException ie) {</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing shutdown"</span>, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        LOG.warn(<span class="string">"******* GOODBYE "</span></span><br><span class="line">                 + (sock != <span class="keyword">null</span> ? sock.getRemoteSocketAddress() : <span class="string">"&lt;null&gt;"</span>)</span><br><span class="line">                 + <span class="string">" ********"</span>);</span><br><span class="line">        shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Send the packet of death</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        queuedPackets.put(proposalOfDeath);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Ignoring unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (sock != <span class="keyword">null</span> &amp;&amp; !sock.isClosed()) {</span><br><span class="line">            sock.close();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Ignoring unexpected exception during socket close"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.interrupt();</span><br><span class="line">    leader.removeLearnerHandler(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeLearnerHandler</span><span class="params">(LearnerHandler peer)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (forwardingFollowers) {</span><br><span class="line">        forwardingFollowers.remove(peer);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (learners) {</span><br><span class="line">        learners.remove(peer);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (observingLearners) {</span><br><span class="line">        observingLearners.remove(peer);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当follower故障时，leader LearnerHandler会感知到异常，接着关闭连接、从follower列表中移除。此时，只要集群可以满足过半ACK则仍然可以正常提供服务。</p><h2 id="leader故障"><a href="#leader故障" class="headerlink" title="leader故障"></a>leader故障</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QourumPeer.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    setName(<span class="string">"QuorumPeer"</span> + <span class="string">"[myid="</span> + getId() + <span class="string">"]"</span> +</span><br><span class="line">            cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 主要逻辑</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) {</span><br><span class="line">            <span class="comment">// 根据当前节点的状态执行相应的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) {</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">// 选举中状态</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOG.info(<span class="string">"FOLLOWING"</span>);</span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// followLeader异常, 关闭follower, 节点重新进入LOOKING状态</span></span><br><span class="line">                    follower.shutdown();</span><br><span class="line">                    setFollower(<span class="keyword">null</span>);</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        LOG.warn(<span class="string">"QuorumPeer main thread exited"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            MBeanRegistry.getInstance().unregisterAll();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    self.end_fle = System.currentTimeMillis();</span><br><span class="line">    LOG.info(<span class="string">"FOLLOWING - LEADER ELECTION TOOK - "</span> +</span><br><span class="line">             (self.end_fle - self.start_fle));</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line">    fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 寻找leader地址</span></span><br><span class="line">        InetSocketAddress addr = findLeader();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 向leader发起连接</span></span><br><span class="line">            connectToLeader(addr);</span><br><span class="line">            <span class="comment">// 注册到leader</span></span><br><span class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//check to see if the leader zxid is lower than ours</span></span><br><span class="line">            <span class="comment">//this should never happen but is just a safety check</span></span><br><span class="line">            <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);</span><br><span class="line">            <span class="keyword">if</span> (newEpoch &lt; self.getAcceptedEpoch()) {</span><br><span class="line">                LOG.error(<span class="string">"Proposed leader epoch "</span> + ZxidUtils.zxidToString(newEpochZxid)</span><br><span class="line">                          + <span class="string">" is less than our accepted epoch "</span> + ZxidUtils.zxidToString(self.getAcceptedEpoch()));</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Error: Epoch of leader is lower"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 从leader同步数据</span></span><br><span class="line">            syncWithLeader(newEpochZxid);</span><br><span class="line">            QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">            <span class="keyword">while</span> (self.isRunning()) {</span><br><span class="line">                <span class="comment">// 读取从leader同步过来的数据</span></span><br><span class="line">                readPacket(qp);</span><br><span class="line">                <span class="comment">// 数据处理</span></span><br><span class="line">                processPacket(qp);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Exception when following the leader"</span>, e);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sock.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e1) {</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clear pending revalidations</span></span><br><span class="line">            pendingRevalidations.clear();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        zk.unregisterJMX((Learner)<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当leader故障时，follower followLeader会发生异常被捕获，接着关闭follower，设置节点状态为LOOKING状态，集群会进行一轮新的选举。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>客户端故障服务端处理：关闭session，删除watcher，关闭底层连接</li><li>服务端故障客户端处理：切换服务端节点，重新建立长连接，建立会话，重新把内存中注册的监听器在新的服务端节点上注册。</li><li>follower故障leader处理：关闭连接，从follower列表中移除，当可以满足过半节点ACK时集群可以正常对外提供服务。</li><li>leader故障follower处理：关闭连接，关闭follwer，进入LOOKING状态开始新一轮选举。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇着重关注zk中对各种故障的感知与恢复，下面将针对不同的故障情况进行分析。&lt;/p&gt;
&lt;h1 id=&quot;消息通信故障&quot;&gt;&lt;a href=&quot;#消息通信故障&quot; class=&quot;headerlink&quot; title=&quot;消息通信故障&quot;&gt;&lt;/a&gt;消息通信故障&lt;/h1&gt;&lt;h2 id=&quot;客户端</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】Watcher机制</title>
    <link href="https://haifuns.com/2022/04/07/zookeeper-08/"/>
    <id>https://haifuns.com/2022/04/07/zookeeper-08/</id>
    <published>2022-04-07T11:35:00.000Z</published>
    <updated>2025-02-23T13:53:31.050Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将继续上一篇消息处理器链对create消息的处理，分析在最后FinalRequestProcessor中对内存数据库进行数据操作，以及如何实现的watcher回调机制。</p><h1 id="注册watcher"><a href="#注册watcher" class="headerlink" title="注册watcher"></a>注册watcher</h1><p>以客户端执行getData时注册Watcher为例：</p><h2 id="客户端注册"><a href="#客户端注册" class="headerlink" title="客户端注册"></a>客户端注册</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br><span class="line"><span class="keyword">throws</span> KeeperException, InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> String clientPath = path;</span><br><span class="line">    PathUtils.validatePath(clientPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the watch contains the un-chroot path</span></span><br><span class="line">    WatchRegistration wcb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) {</span><br><span class="line">        wcb = <span class="keyword">new</span> DataWatchRegistration(watcher, clientPath);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">    RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">    h.setType(ZooDefs.OpCode.getData);</span><br><span class="line">    GetDataRequest request = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">    request.setPath(serverPath);</span><br><span class="line">    request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">    GetDataResponse response = <span class="keyword">new</span> GetDataResponse();</span><br><span class="line">    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line">    <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</span><br><span class="line">                                     clientPath);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stat != <span class="keyword">null</span>) {</span><br><span class="line">        DataTree.copyStat(response.getStat(), stat);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> response.getData();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCnxn.SendThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    ByteBufferInputStream bbis = <span class="keyword">new</span> ByteBufferInputStream(</span><br><span class="line">        incomingBuffer);</span><br><span class="line">    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">    ReplyHeader replyHdr = <span class="keyword">new</span> ReplyHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Packet packet;</span><br><span class="line">    <span class="keyword">synchronized</span> (pendingQueue) {</span><br><span class="line">        <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Nothing in the queue, but got "</span></span><br><span class="line">                                  + replyHdr.getXid());</span><br><span class="line">        }</span><br><span class="line">        packet = pendingQueue.remove();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">     * to the first request!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) {</span><br><span class="line">            packet.replyHeader.setErr(</span><br><span class="line">                KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Xid out of order. Got Xid "</span></span><br><span class="line">                                  + replyHdr.getXid() + <span class="string">" with err "</span> +</span><br><span class="line">                                  + replyHdr.getErr() +</span><br><span class="line">                                  <span class="string">" expected Xid "</span></span><br><span class="line">                                  + packet.requestHeader.getXid()</span><br><span class="line">                                  + <span class="string">" for a packet with details: "</span></span><br><span class="line">                                  + packet );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">        packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">        <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) {</span><br><span class="line">            lastZxid = replyHdr.getZxid();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (packet.response != <span class="keyword">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) {</span><br><span class="line">            packet.response.deserialize(bbia, <span class="string">"response"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Reading reply sessionid:0x"</span></span><br><span class="line">                      + Long.toHexString(sessionId) + <span class="string">", packet:: "</span> + packet);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        finishPacket(packet);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCnxn.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 客户端注册监听器</span></span><br><span class="line">        p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (p) {</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            p.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p.finished = <span class="keyword">true</span>;</span><br><span class="line">        eventThread.queuePacket(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper.WatchReginstration.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (shouldAddWatch(rc)) {</span><br><span class="line">        Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</span><br><span class="line">        <span class="keyword">synchronized</span> (watches) {</span><br><span class="line">            Set&lt;Watcher&gt; watchers = watches.get(clientPath);</span><br><span class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) {</span><br><span class="line">                watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line">                watches.put(clientPath, watchers);</span><br><span class="line">            }</span><br><span class="line">            watchers.add(watcher);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataWatchRegistration</span> <span class="keyword">extends</span> <span class="title">WatchRegistration</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataWatchRegistration</span><span class="params">(Watcher watcher, String clientPath)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(watcher, clientPath);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Set&lt;Watcher&gt;&gt; getWatches(<span class="keyword">int</span> rc) {</span><br><span class="line">        <span class="keyword">return</span> watchManager.dataWatches;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Watcher defaultWatcher;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可知，当客户端在getData的同时注册Watcher时，在收到成功的响应后会把Watcher保存在本地内存Map中。</p><h2 id="服务端注册"><a href="#服务端注册" class="headerlink" title="服务端注册"></a>服务端注册</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FinalRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">switch</span> (request.type) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> OpCode.getData: {</span><br><span class="line">            lastOp = <span class="string">"GETD"</span>;</span><br><span class="line">            GetDataRequest getDataRequest = <span class="keyword">new</span> GetDataRequest();</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">                                                    getDataRequest);</span><br><span class="line">            <span class="comment">// 从内存中查询指定路径node</span></span><br><span class="line">            DataNode n = zks.getZKDatabase().getNode(getDataRequest.getPath());</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">            }</span><br><span class="line">            Long aclL;</span><br><span class="line">            <span class="keyword">synchronized</span> (n) {</span><br><span class="line">                aclL = n.acl;</span><br><span class="line">            }</span><br><span class="line">            PrepRequestProcessor.checkACL(zks, zks.getZKDatabase().convertLong(aclL),</span><br><span class="line">                                          ZooDefs.Perms.READ,</span><br><span class="line">                                          request.authInfo);</span><br><span class="line">            Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">            <span class="comment">// 获得数据、处理watcher</span></span><br><span class="line">            <span class="keyword">byte</span> b[] = zks.getZKDatabase().getData(getDataRequest.getPath(), stat,</span><br><span class="line">                                                   getDataRequest.getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">            rsp = <span class="keyword">new</span> GetDataResponse(b, stat);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZKDatabase.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(String path, Stat stat, Watcher watcher)</span><br><span class="line"><span class="keyword">throws</span> KeeperException.NoNodeException {</span><br><span class="line">    <span class="keyword">return</span> dataTree.getData(path, stat, watcher);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataTree.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(String path, Stat stat, Watcher watcher)</span><br><span class="line"><span class="keyword">throws</span> KeeperException.NoNodeException {</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (n) {</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 服务端添加watcher</span></span><br><span class="line">            dataWatches.addWatch(path, watcher);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n.data;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatcherManager.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths = <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWatch</span><span class="params">(String path, Watcher watcher)</span> </span>{</span><br><span class="line">    HashSet&lt;Watcher&gt; list = watchTable.get(path);</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// don't waste memory if there are few watches on a node</span></span><br><span class="line">        <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></span><br><span class="line">        <span class="comment">// seems like a good compromise</span></span><br><span class="line">        list = <span class="keyword">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>);</span><br><span class="line">        watchTable.put(path, list);</span><br><span class="line">    }</span><br><span class="line">    list.add(watcher);</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; paths = watch2Paths.get(watcher);</span><br><span class="line">    <span class="keyword">if</span> (paths == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// cnxns typically have many watches, so use default cap here</span></span><br><span class="line">        paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        watch2Paths.put(watcher, paths);</span><br><span class="line">    }</span><br><span class="line">    paths.add(path);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，当客户端请求创建watcher时，服务端会创建watcher保存在Map结构中，其中key为path。</p><h1 id="回调watcher"><a href="#回调watcher" class="headerlink" title="回调watcher"></a>回调watcher</h1><p>接下来查看Watcher被触发回调的过程，以Create为例，继续分析FinalRequestProcessor对内存数据的处理：</p><h2 id="服务端回调"><a href="#服务端回调" class="headerlink" title="服务端回调"></a>服务端回调</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeperServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(TxnHeader hdr, Record txn)</span> </span>{</span><br><span class="line">    ProcessTxnResult rc;</span><br><span class="line">    <span class="keyword">int</span> opCode = hdr.getType();</span><br><span class="line">    <span class="keyword">long</span> sessionId = hdr.getClientId();</span><br><span class="line">    rc = getZKDatabase().processTxn(hdr, txn);</span><br><span class="line">    <span class="keyword">if</span> (opCode == OpCode.createSession) {</span><br><span class="line">        <span class="keyword">if</span> (txn <span class="keyword">instanceof</span> CreateSessionTxn) {</span><br><span class="line">            CreateSessionTxn cst = (CreateSessionTxn) txn;</span><br><span class="line">            sessionTracker.addSession(sessionId, cst</span><br><span class="line">                                      .getTimeOut());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            LOG.warn(<span class="string">"*****&gt;&gt;&gt;&gt;&gt; Got "</span></span><br><span class="line">                     + txn.getClass() + <span class="string">" "</span></span><br><span class="line">                     + txn.toString());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (opCode == OpCode.closeSession) {</span><br><span class="line">        sessionTracker.removeSession(sessionId);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZKDatabase.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(TxnHeader hdr, Record txn)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> dataTree.processTxn(hdr, txn);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataTree.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProcessTxnResult <span class="title">processTxn</span><span class="params">(TxnHeader header, Record txn)</span> </span>{</span><br><span class="line">    ProcessTxnResult rc = <span class="keyword">new</span> ProcessTxnResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        rc.clientId = header.getClientId();</span><br><span class="line">        rc.cxid = header.getCxid();</span><br><span class="line">        rc.zxid = header.getZxid();</span><br><span class="line">        rc.type = header.getType();</span><br><span class="line">        rc.err = <span class="number">0</span>;</span><br><span class="line">        rc.multiResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (header.getType()) {</span><br><span class="line">        <span class="keyword">case</span> OpCode.create:</span><br><span class="line">            CreateTxn createTxn = (CreateTxn) txn;</span><br><span class="line">            rc.path = createTxn.getPath();</span><br><span class="line">            createNode(</span><br><span class="line">                createTxn.getPath(),</span><br><span class="line">                createTxn.getData(),</span><br><span class="line">                createTxn.getAcl(),</span><br><span class="line">                createTxn.getEphemeral() ? header.getClientId() : <span class="number">0</span>,</span><br><span class="line">                createTxn.getParentCVersion(),</span><br><span class="line">                header.getZxid(), header.getTime());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Failed: "</span> + header + <span class="string">":"</span> + txn, e);</span><br><span class="line">        }</span><br><span class="line">        rc.err = e.code().intValue();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Failed: "</span> + header + <span class="string">":"</span> + txn, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createNode</span><span class="params">(String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">long</span> ephemeralOwner, <span class="keyword">int</span> parentCVersion, <span class="keyword">long</span> zxid, <span class="keyword">long</span> time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> KeeperException.NoNodeException,</span></span><br><span class="line"><span class="function">    KeeperException.NodeExistsException </span>{</span><br><span class="line">    <span class="keyword">int</span> lastSlash = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">    String parentName = path.substring(<span class="number">0</span>, lastSlash);</span><br><span class="line">    String childName = path.substring(lastSlash + <span class="number">1</span>);</span><br><span class="line">    StatPersisted stat = <span class="keyword">new</span> StatPersisted();</span><br><span class="line">    stat.setCtime(time);</span><br><span class="line">    stat.setMtime(time);</span><br><span class="line">    stat.setCzxid(zxid);</span><br><span class="line">    stat.setMzxid(zxid);</span><br><span class="line">    stat.setPzxid(zxid);</span><br><span class="line">    stat.setVersion(<span class="number">0</span>);</span><br><span class="line">    stat.setAversion(<span class="number">0</span>);</span><br><span class="line">    stat.setEphemeralOwner(ephemeralOwner);</span><br><span class="line">    DataNode parent = nodes.get(parentName);</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (parent) {</span><br><span class="line">        Set&lt;String&gt; children = parent.getChildren();</span><br><span class="line">        <span class="keyword">if</span> (children != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (children.contains(childName)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NodeExistsException();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parentCVersion == -<span class="number">1</span>) {</span><br><span class="line">            parentCVersion = parent.stat.getCversion();</span><br><span class="line">            parentCVersion++;</span><br><span class="line">        }</span><br><span class="line">        parent.stat.setCversion(parentCVersion);</span><br><span class="line">        parent.stat.setPzxid(zxid);</span><br><span class="line">        Long longval = convertAcls(acl);</span><br><span class="line">        DataNode child = <span class="keyword">new</span> DataNode(parent, data, longval, stat);</span><br><span class="line">        <span class="comment">// 添加到父节点下</span></span><br><span class="line">        parent.addChild(childName);</span><br><span class="line">        nodes.put(path, child);</span><br><span class="line">        <span class="keyword">if</span> (ephemeralOwner != <span class="number">0</span>) {</span><br><span class="line">            HashSet&lt;String&gt; list = ephemerals.get(ephemeralOwner);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">                list = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                ephemerals.put(ephemeralOwner, list);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (list) {</span><br><span class="line">                list.add(path);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// now check if its one of the zookeeper node child</span></span><br><span class="line">    <span class="keyword">if</span> (parentName.startsWith(quotaZookeeper)) {</span><br><span class="line">        <span class="comment">// now check if its the limit node</span></span><br><span class="line">        <span class="keyword">if</span> (Quotas.limitNode.equals(childName)) {</span><br><span class="line">            <span class="comment">// this is the limit node</span></span><br><span class="line">            <span class="comment">// get the parent and add it to the trie</span></span><br><span class="line">            pTrie.addPath(parentName.substring(quotaZookeeper.length()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (Quotas.statNode.equals(childName)) {</span><br><span class="line">            updateQuotaForPath(parentName</span><br><span class="line">                               .substring(quotaZookeeper.length()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// also check to update the quotas for this node</span></span><br><span class="line">    String lastPrefix;</span><br><span class="line">    <span class="keyword">if</span> ((lastPrefix = getMaxPrefixWithQuota(path)) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// ok we have some match and need to update</span></span><br><span class="line">        updateCount(lastPrefix, <span class="number">1</span>);</span><br><span class="line">        updateBytes(lastPrefix, data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// znode发生变化后, 触发当前节点以及父节点上的watcher监听器</span></span><br><span class="line">    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);</span><br><span class="line">    childWatches.triggerWatch(parentName.equals(<span class="string">""</span>) ? <span class="string">"/"</span> : parentName,</span><br><span class="line">                              Event.EventType.NodeChildrenChanged);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatcherManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> triggerWatch(path, type, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>{</span><br><span class="line">    WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</span><br><span class="line">                                      KeeperState.SyncConnected, path);</span><br><span class="line">    HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="comment">// 触发watcher后, 服务端直接删除此节点上的所有watcher</span></span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">        <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) {</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                                         ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                         <span class="string">"No watchers for "</span> + path);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) {</span><br><span class="line">            HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">            <span class="keyword">if</span> (paths != <span class="keyword">null</span>) {</span><br><span class="line">                paths.remove(path);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) {</span><br><span class="line">        <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        w.process(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NIOServerCnxn.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>{</span><br><span class="line">    ReplyHeader h = <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                                 <span class="string">"Deliver event "</span> + event + <span class="string">" to 0x"</span></span><br><span class="line">                                 + Long.toHexString(<span class="keyword">this</span>.sessionId)</span><br><span class="line">                                 + <span class="string">" through "</span> + <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></span><br><span class="line">    WatcherEvent e = event.getWrapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送监听器事件到客户端</span></span><br><span class="line">    sendResponse(h, e, <span class="string">"notification"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendResponse</span><span class="params">(ReplyHeader h, Record r, String tag)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// Make space for length</span></span><br><span class="line">        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            baos.write(fourBytes);</span><br><span class="line">            bos.writeRecord(h, <span class="string">"header"</span>);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) {</span><br><span class="line">                bos.writeRecord(r, tag);</span><br><span class="line">            }</span><br><span class="line">            baos.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.error(<span class="string">"Error serializing response"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">byte</span> b[] = baos.toByteArray();</span><br><span class="line">        ByteBuffer bb = ByteBuffer.wrap(b);</span><br><span class="line">        bb.putInt(b.length - <span class="number">4</span>).rewind();</span><br><span class="line">        sendBuffer(bb);</span><br><span class="line">        <span class="keyword">if</span> (h.getXid() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                outstandingRequests--;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// check throttling</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.factory) {</span><br><span class="line">                <span class="keyword">if</span> (zkServer.getInProcess() &lt; outstandingLimit</span><br><span class="line">                        || outstandingRequests &lt; <span class="number">1</span>) {</span><br><span class="line">                    sk.selector().wakeup();</span><br><span class="line">                    enableRecv();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.warn(<span class="string">"Unexpected exception. Destruction averted."</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，在create时，构建了一个DataNode节点放到父节点下，然后删除并触发父节点和当前节点的Watcher事件，发送监听器事件到客户端。</p><h2 id="客户端处理"><a href="#客户端处理" class="headerlink" title="客户端处理"></a>客户端处理</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn.SendThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// -1 means notification</span></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Got notification sessionid:0x"</span></span><br><span class="line">                      + Long.toHexString(sessionId));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收到事件通知</span></span><br><span class="line">        WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</span><br><span class="line">        event.deserialize(bbia, <span class="string">"response"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">        <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) {</span><br><span class="line">            String serverPath = event.getPath();</span><br><span class="line">            <span class="keyword">if</span> (serverPath.compareTo(chrootPath) == <span class="number">0</span>)</span><br><span class="line">                event.setPath(<span class="string">"/"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</span><br><span class="line">                event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                LOG.warn(<span class="string">"Got server path "</span> + event.getPath()</span><br><span class="line">                         + <span class="string">" which is too short for chroot path "</span></span><br><span class="line">                         + chrootPath);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Got "</span> + we + <span class="string">" for sessionid 0x"</span></span><br><span class="line">                      + Long.toHexString(sessionId));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        eventThread.queueEvent( we );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCnxn.EventThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueEvent</span><span class="params">(WatchedEvent event)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (event.getType() == EventType.None</span><br><span class="line">            &amp;&amp; sessionState == event.getState()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    sessionState = event.getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// materialize the watchers based on the event</span></span><br><span class="line">    WatcherSetEventPair pair = <span class="keyword">new</span> WatcherSetEventPair(</span><br><span class="line">        watcher.materialize(event.getState(), event.getType(),</span><br><span class="line">                            event.getPath()),</span><br><span class="line">        event);</span><br><span class="line">    <span class="comment">// queue the pair (watch set &amp; event) for later processing</span></span><br><span class="line">    waitingEvents.add(pair);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        isRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            Object event = waitingEvents.take();</span><br><span class="line">            <span class="keyword">if</span> (event == eventOfDeath) {</span><br><span class="line">                wasKilled = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 处理watcher事件</span></span><br><span class="line">                processEvent(event);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (wasKilled)</span><br><span class="line">                <span class="keyword">synchronized</span> (waitingEvents) {</span><br><span class="line">                    <span class="keyword">if</span> (waitingEvents.isEmpty()) {</span><br><span class="line">                        isRunning = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Event thread exiting due to interruption"</span>, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">"EventThread shut down"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(Object event)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WatcherSetEventPair) {</span><br><span class="line">            <span class="comment">// each watcher will process the event</span></span><br><span class="line">            WatcherSetEventPair pair = (WatcherSetEventPair) event;</span><br><span class="line">            <span class="keyword">for</span> (Watcher watcher : pair.watchers) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 回调客户端注册的监听器</span></span><br><span class="line">                    watcher.process(pair.event);</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                    LOG.error(<span class="string">"Error while calling watcher "</span>, t);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        LOG.error(<span class="string">"Caught unexpected throwable"</span>, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeper.ZKWatchManager.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">materialize</span><span class="params">(Watcher.Event.KeeperState state,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Watcher.Event.EventType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                String clientPath)</span> </span>{</span><br><span class="line">    Set&lt;Watcher&gt; result = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">    <span class="keyword">case</span> None:</span><br><span class="line">        result.add(defaultWatcher);</span><br><span class="line">        <span class="keyword">boolean</span> clear = ClientCnxn.getDisableAutoResetWatch() &amp;&amp;</span><br><span class="line">                        state != Watcher.Event.KeeperState.SyncConnected;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (dataWatches) {</span><br><span class="line">            <span class="keyword">for</span> (Set&lt;Watcher&gt; ws : dataWatches.values()) {</span><br><span class="line">                result.addAll(ws);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (clear) {</span><br><span class="line">                dataWatches.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (existWatches) {</span><br><span class="line">            <span class="keyword">for</span> (Set&lt;Watcher&gt; ws : existWatches.values()) {</span><br><span class="line">                result.addAll(ws);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (clear) {</span><br><span class="line">                existWatches.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (childWatches) {</span><br><span class="line">            <span class="keyword">for</span> (Set&lt;Watcher&gt; ws : childWatches.values()) {</span><br><span class="line">                result.addAll(ws);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (clear) {</span><br><span class="line">                childWatches.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">    <span class="keyword">case</span> NodeCreated:</span><br><span class="line">        <span class="keyword">synchronized</span> (dataWatches) {</span><br><span class="line">            addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (existWatches) {</span><br><span class="line">            addTo(existWatches.remove(clientPath), result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">        <span class="keyword">synchronized</span> (childWatches) {</span><br><span class="line">            addTo(childWatches.remove(clientPath), result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">        <span class="keyword">synchronized</span> (dataWatches) {</span><br><span class="line">            addTo(dataWatches.remove(clientPath), result);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// XXX This shouldn't be needed, but just in case</span></span><br><span class="line">        <span class="keyword">synchronized</span> (existWatches) {</span><br><span class="line">            Set&lt;Watcher&gt; list = existWatches.remove(clientPath);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) {</span><br><span class="line">                addTo(existWatches.remove(clientPath), result);</span><br><span class="line">                LOG.warn(<span class="string">"We are triggering an exists watch for delete! Shouldn't happen!"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (childWatches) {</span><br><span class="line">            addTo(childWatches.remove(clientPath), result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        String msg = <span class="string">"Unhandled watch event type "</span> + type</span><br><span class="line">                     + <span class="string">" with state "</span> + state + <span class="string">" on path "</span> + clientPath;</span><br><span class="line">        LOG.error(msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，当watcher回调消息到达客户端时，首先会从内存中找到对应的watcher，然后把消息写入内存队列中，由单独的线程依次从队列中获取消息，回调watcher处理逻辑。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>watcher注册过程：当客户端发起请求注册watcher时，服务端会将watcher保存到内存Map中，key为path，value为watcher集合，客户端收到处理成功响应后也会将watcher放到本地内存中等待回调。</li><li>watcher触发回调：当服务端数据变化时，会触发所有path对应的watcher，向客户端发送回调消息。客户端收到回调消息后，首先会找到path对应的watcher，然后执行watcher回调处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇将继续上一篇消息处理器链对create消息的处理，分析在最后FinalRequestProcessor中对内存数据库进行数据操作，以及如何实现的watcher回调机制。&lt;/p&gt;
&lt;h1 id=&quot;注册watcher&quot;&gt;&lt;a href=&quot;#注册watcher&quot; class=</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】消息处理器链</title>
    <link href="https://haifuns.com/2022/03/21/zookeeper-07/"/>
    <id>https://haifuns.com/2022/03/21/zookeeper-07/</id>
    <published>2022-03-21T11:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.050Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇session处理过程中我们略过了touchSession之后的消息处理过程，本篇将继续分析消息处理器链对消息的处理过程。</p><h1 id="Leader处理器链"><a href="#Leader处理器链" class="headerlink" title="Leader处理器链"></a>Leader处理器链</h1><p>leader节点过滤器链在LeaderZooKeeperServer启动过程中完成初始化，相关代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) {</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 启动session管理组件</span></span><br><span class="line">    startSessionTracker();</span><br><span class="line">    <span class="comment">// 启动过滤器链</span></span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeaderZooKeeperServer.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// leader处理器链</span></span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor toBeAppliedProcessor = <span class="keyword">new</span> Leader.ToBeAppliedRequestProcessor(</span><br><span class="line">        finalProcessor, getLeader().toBeApplied);</span><br><span class="line">    <span class="comment">// commit到内存, 发送commit请求到follower</span></span><br><span class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(toBeAppliedProcessor,</span><br><span class="line">                                          Long.toString(getServerId()), <span class="keyword">false</span>);</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    <span class="comment">// 写入本地事务日志, 2PC同步, follower写入本地事务日志后ACK, 等待过半ACK</span></span><br><span class="line">    ProposalRequestProcessor proposalProcessor = <span class="keyword">new</span> ProposalRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            commitProcessor);</span><br><span class="line">    proposalProcessor.initialize();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, proposalProcessor);</span><br><span class="line">    ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码中可以看到leader消息处理器链为<code>PrepRequestProcessor -&gt; ProposalRequestProcessor -&gt; CommitProcessor -&gt; Leader.ToBeAppliedRequestProcessor -&gt; FinalRequestProcessor</code>。</p><p>接下来以一条create类型的事务消息为例，分析leader消息处理流程：</p><h2 id="PreRequestProcessor"><a href="#PreRequestProcessor" class="headerlink" title="PreRequestProcessor"></a>PreRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新session过期时间, 重新分桶</span></span><br><span class="line">    touch(si.cnxn);</span><br><span class="line">    <span class="keyword">boolean</span> validpacket = Request.isValid(si.type);</span><br><span class="line">    <span class="keyword">if</span> (validpacket) {</span><br><span class="line">        <span class="comment">// preRequestProcessor处理器链开始正式处理消息</span></span><br><span class="line">        firstProcessor.processRequest(si);</span><br><span class="line">        <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) {</span><br><span class="line">            incInProcess();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepRequestProcessor</span></span><br><span class="line">LinkedBlockingQueue&lt;Request&gt; submittedRequests = <span class="keyword">new</span> LinkedBlockingQueue&lt;Request&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="comment">// request.addRQRec("&gt;prep="+zks.outstandingChanges.size());</span></span><br><span class="line">    submittedRequests.add(request);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            Request request = submittedRequests.take();</span><br><span class="line">            <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (request.type == OpCode.ping) {</span><br><span class="line">                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logRequest(LOG, traceMask, <span class="string">'P'</span>, request, <span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (Request.requestOfDeath == request) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            pRequest(request);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>{</span><br><span class="line">    <span class="comment">// LOG.info("Prep&gt;&gt;&gt; cxid = " + request.cxid + " type = " +</span></span><br><span class="line">    <span class="comment">// request.type + " id = 0x" + Long.toHexString(request.sessionId));</span></span><br><span class="line">    request.hdr = <span class="keyword">null</span>;</span><br><span class="line">    request.txn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">switch</span> (request.type) {</span><br><span class="line">        <span class="keyword">case</span> OpCode.create:</span><br><span class="line">            CreateRequest createRequest = <span class="keyword">new</span> CreateRequest();</span><br><span class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OpCode.delete:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">    request.zxid = zks.getZxid();</span><br><span class="line">    nextProcessor.processRequest(request);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest2Txn</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> zxid, Request request, Record record, <span class="keyword">boolean</span> deserialize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> KeeperException, IOException, RequestProcessorException </span>{</span><br><span class="line">    request.hdr = <span class="keyword">new</span> TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">                                zks.getTime(), type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) {</span><br><span class="line">    <span class="keyword">case</span> OpCode.create:</span><br><span class="line">        <span class="comment">// 检查session是否过期</span></span><br><span class="line">        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());</span><br><span class="line">        CreateRequest createRequest = (CreateRequest)record;</span><br><span class="line">        <span class="keyword">if</span> (deserialize)</span><br><span class="line">            ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);</span><br><span class="line">        String path = createRequest.getPath();</span><br><span class="line">        <span class="keyword">int</span> lastSlash = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span> (lastSlash == -<span class="number">1</span> || path.indexOf(<span class="string">'\0'</span>) != -<span class="number">1</span> || failCreate) {</span><br><span class="line">            LOG.info(<span class="string">"Invalid path "</span> + path + <span class="string">" with session 0x"</span> +</span><br><span class="line">                     Long.toHexString(request.sessionId));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException(path);</span><br><span class="line">        }</span><br><span class="line">        List&lt;ACL&gt; listACL = removeDuplicates(createRequest.getAcl());</span><br><span class="line">        <span class="keyword">if</span> (!fixupACL(request.authInfo, listACL)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.InvalidACLException(path);</span><br><span class="line">        }</span><br><span class="line">        String parentPath = path.substring(<span class="number">0</span>, lastSlash);</span><br><span class="line">        ChangeRecord parentRecord = getRecordForPath(parentPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前路径权限</span></span><br><span class="line">        checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,</span><br><span class="line">                 request.authInfo);</span><br><span class="line">        <span class="keyword">int</span> parentCVersion = parentRecord.stat.getCversion();</span><br><span class="line">        CreateMode createMode =</span><br><span class="line">            CreateMode.fromFlag(createRequest.getFlags());</span><br><span class="line">        <span class="comment">// 是否是顺序节点</span></span><br><span class="line">        <span class="keyword">if</span> (createMode.isSequential()) {</span><br><span class="line">            <span class="comment">// 拼接序号</span></span><br><span class="line">            path = path + String.format(Locale.ENGLISH, <span class="string">"%010d"</span>, parentCVersion);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            PathUtils.validatePath(path);</span><br><span class="line">        } <span class="keyword">catch</span> (IllegalArgumentException ie) {</span><br><span class="line">            LOG.info(<span class="string">"Invalid path "</span> + path + <span class="string">" with session 0x"</span> +</span><br><span class="line">                     Long.toHexString(request.sessionId));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException(path);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (getRecordForPath(path) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NodeExistsException(path);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (KeeperException.NoNodeException e) {</span><br><span class="line">            <span class="comment">// ignore this one</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">boolean</span> ephemeralParent = parentRecord.stat.getEphemeralOwner() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ephemeralParent) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoChildrenForEphemeralsException(path);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> newCversion = parentRecord.stat.getCversion() + <span class="number">1</span>;</span><br><span class="line">        request.txn = <span class="keyword">new</span> CreateTxn(path, createRequest.getData(),</span><br><span class="line">                                    listACL,</span><br><span class="line">                                    createMode.isEphemeral(), newCversion);</span><br><span class="line">        StatPersisted s = <span class="keyword">new</span> StatPersisted();</span><br><span class="line">        <span class="keyword">if</span> (createMode.isEphemeral()) {</span><br><span class="line">            s.setEphemeralOwner(request.sessionId);</span><br><span class="line">        }</span><br><span class="line">        parentRecord = parentRecord.duplicate(request.hdr.getZxid());</span><br><span class="line">        parentRecord.childCount++;</span><br><span class="line">        parentRecord.stat.setCversion(newCversion);</span><br><span class="line">        <span class="comment">// 修改父目录</span></span><br><span class="line">        addChangeRecord(parentRecord);</span><br><span class="line">        <span class="comment">// 添加当前节点</span></span><br><span class="line">        addChangeRecord(<span class="keyword">new</span> ChangeRecord(request.hdr.getZxid(), path, s,</span><br><span class="line">                                         <span class="number">0</span>, listACL));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// final List&lt;ChangeRecord&gt; outstandingChanges = new ArrayList&lt;ChangeRecord&gt;();</span></span><br><span class="line"><span class="comment">// final HashMap&lt;String, ChangeRecord&gt; outstandingChangesForPath = new HashMap&lt;String, ChangeRecord&gt;();</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeRecord</span><span class="params">(ChangeRecord c)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (zks.outstandingChanges) {</span><br><span class="line">        zks.outstandingChanges.add(c); <span class="comment">// 即将要处理的changeRecord</span></span><br><span class="line">        zks.outstandingChangesForPath.put(c.path, c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，PrepRequestProcessor处理器将请求封装成ChangeRecord，暂存在outstandingChanges中，然后就交由下一个处理器ProposalRequestProcessor。</p><h2 id="ProposalRequestProcessor"><a href="#ProposalRequestProcessor" class="headerlink" title="ProposalRequestProcessor"></a>ProposalRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrepRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProposalRequestProcessor</span><span class="params">(LeaderZooKeeperServer zks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RequestProcessor nextProcessor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.zks = zks;</span><br><span class="line">    <span class="keyword">this</span>.nextProcessor = nextProcessor;</span><br><span class="line">    AckRequestProcessor ackProcessor = <span class="keyword">new</span> AckRequestProcessor(zks.getLeader());</span><br><span class="line">    syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(zks, ackProcessor);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> LearnerSyncRequest) {</span><br><span class="line">        zks.getLeader().processSync((LearnerSyncRequest)request);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// commitProcessor</span></span><br><span class="line">        nextProcessor.processRequest(request);</span><br><span class="line">        <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// We need to sync and get consensus on any transactions</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 创建Propose, 发送到follower</span></span><br><span class="line">                zks.getLeader().propose(request);</span><br><span class="line">            } <span class="keyword">catch</span> (XidRolloverException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RequestProcessorException(e.getMessage(), e);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 写入事务日志</span></span><br><span class="line">            syncProcessor.processRequest(request);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Proposal <span class="title">propose</span><span class="params">(Request request)</span> <span class="keyword">throws</span> XidRolloverException </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Address the rollover issue. All lower 32bits set indicate a new leader</span></span><br><span class="line"><span class="comment">     * election. Force a re-election instead. See ZOOKEEPER-1277</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((request.zxid &amp; <span class="number">0xffffffffL</span>) == <span class="number">0xffffffffL</span>) {</span><br><span class="line">        String msg =</span><br><span class="line">            <span class="string">"zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start"</span>;</span><br><span class="line">        shutdown(msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XidRolloverException(msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        request.hdr.serialize(boa, <span class="string">"hdr"</span>);</span><br><span class="line">        <span class="keyword">if</span> (request.txn != <span class="keyword">null</span>) {</span><br><span class="line">            request.txn.serialize(boa, <span class="string">"txn"</span>);</span><br><span class="line">        }</span><br><span class="line">        baos.close();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.warn(<span class="string">"This really should be impossible"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    QuorumPacket pp = <span class="keyword">new</span> QuorumPacket(Leader.PROPOSAL, request.zxid,</span><br><span class="line">                                       baos.toByteArray(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    Proposal p = <span class="keyword">new</span> Proposal();</span><br><span class="line">    p.packet = pp;</span><br><span class="line">    p.request = request;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Proposing:: "</span> + request);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        lastProposed = p.packet.getZxid();</span><br><span class="line">        outstandingProposals.put(lastProposed, p);</span><br><span class="line">        <span class="comment">// 发送Proposal到follower</span></span><br><span class="line">        sendPacket(pp);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从ProposalRequestProcessor处理器构造函数中可以看到其内包含了另一个处理器链<code>SyncRequestProcessor -&gt; AckRequestProcessor</code>。消息在此处理器中首先会继续发给下一个处理器CommitProcessor处理，接着把propose消息发送给所有follower，然后交给SyncRequestProcessor处理。</p><h3 id="SyncRequestProcessor"><a href="#SyncRequestProcessor" class="headerlink" title="SyncRequestProcessor"></a>SyncRequestProcessor</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="comment">// request.addRQRec("&gt;sync");</span></span><br><span class="line">    queuedRequests.add(request);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyncRequestProcessor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">int</span> logCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></span><br><span class="line">        <span class="comment">// in the ensemble take a snapshot at the same time</span></span><br><span class="line">        <span class="keyword">int</span> randRoll = r.nextInt(snapCount / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            Request si = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (toFlush.isEmpty()) {</span><br><span class="line">                si = queuedRequests.take();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                si = queuedRequests.poll();</span><br><span class="line">                <span class="keyword">if</span> (si == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// 队列里的propose都写入事务日志, 执行flush到磁盘</span></span><br><span class="line">                    flush(toFlush);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (si == requestOfDeath) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// track the number of records written to the log</span></span><br><span class="line">                <span class="comment">// 追加日志</span></span><br><span class="line">                <span class="keyword">if</span> (zks.getZKDatabase().append(si)) {</span><br><span class="line">                    logCount++;</span><br><span class="line">                    <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) {</span><br><span class="line">                        randRoll = r.nextInt(snapCount / <span class="number">2</span>);</span><br><span class="line">                        <span class="comment">// roll the log</span></span><br><span class="line">                        zks.getZKDatabase().rollLog();</span><br><span class="line">                        <span class="comment">// take a snapshot</span></span><br><span class="line">                        <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) {</span><br><span class="line">                            LOG.warn(<span class="string">"Too busy to snap, skipping"</span>);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// 每隔一定次数保存快照</span></span><br><span class="line">                            snapInProcess = <span class="keyword">new</span> Thread(<span class="string">"Snapshot Thread"</span>) {</span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                                    <span class="keyword">try</span> {</span><br><span class="line">                                        zks.takeSnapshot();</span><br><span class="line">                                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            };</span><br><span class="line">                            snapInProcess.start();</span><br><span class="line">                        }</span><br><span class="line">                        logCount = <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) {</span><br><span class="line">                    <span class="comment">// optimization for read heavy workloads</span></span><br><span class="line">                    <span class="comment">// iff this is a read, and there are no pending</span></span><br><span class="line">                    <span class="comment">// flushes (writes), then just pass this to the next</span></span><br><span class="line">                    <span class="comment">// processor</span></span><br><span class="line">                    nextProcessor.processRequest(si);</span><br><span class="line">                    <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) {</span><br><span class="line">                        ((Flushable)nextProcessor).flush();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                toFlush.add(si);</span><br><span class="line">                <span class="comment">// 事务日志大于1000条flush到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (toFlush.size() &gt; <span class="number">1000</span>) {</span><br><span class="line">                    flush(toFlush);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        LOG.error(<span class="string">"Severe unrecoverable error, exiting"</span>, t);</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">        System.exit(<span class="number">11</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG.info(<span class="string">"SyncRequestProcessor exited!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SyncRequestProcessor处理器将事务追加到内存数据库中，当日志数量大于1000条会flush到磁盘。并且每当累计到一定次数会切换日志文件并将内存数据库保存快照。</p><p>在flush到磁盘时会调用下一个处理器AckRequestProcessor。</p><h3 id="AckRequestProcessor"><a href="#AckRequestProcessor" class="headerlink" title="AckRequestProcessor"></a>AckRequestProcessor</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    QuorumPeer self = leader.self;</span><br><span class="line">    <span class="keyword">if</span> (self != <span class="keyword">null</span>)</span><br><span class="line">        leader.processAck(self.getId(), request.zxid, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LOG.error(<span class="string">"Null QuorumPeer"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAck</span><span class="params">(<span class="keyword">long</span> sid, <span class="keyword">long</span> zxid, SocketAddress followerAddr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">        LOG.trace(<span class="string">"Ack zxid: 0x{}"</span>, Long.toHexString(zxid));</span><br><span class="line">        <span class="keyword">for</span> (Proposal p : outstandingProposals.values()) {</span><br><span class="line">            <span class="keyword">long</span> packetZxid = p.packet.getZxid();</span><br><span class="line">            LOG.trace(<span class="string">"outstanding proposal: 0x{}"</span>,</span><br><span class="line">                      Long.toHexString(packetZxid));</span><br><span class="line">        }</span><br><span class="line">        LOG.trace(<span class="string">"outstanding proposals all"</span>);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 没有处理中的事务</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingProposals.size() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"outstanding is 0"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断当前zxid是否已经被commit</span></span><br><span class="line">    <span class="keyword">if</span> (lastCommitted &gt;= zxid) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"proposal has already been committed, pzxid: 0x{} zxid: 0x{}"</span>,</span><br><span class="line">                      Long.toHexString(lastCommitted), Long.toHexString(zxid));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// The proposal has already been committed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Proposal p = outstandingProposals.get(zxid);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) {</span><br><span class="line">        LOG.warn(<span class="string">"Trying to commit future proposal: zxid 0x{} from {}"</span>,</span><br><span class="line">                 Long.toHexString(zxid), followerAddr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 记录peer proposal ack</span></span><br><span class="line">    p.ackSet.add(sid);</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">        LOG.debug(<span class="string">"Count for zxid: 0x{} is {}"</span>,</span><br><span class="line">                  Long.toHexString(zxid), p.ackSet.size());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 是否满足大多数节点ACK</span></span><br><span class="line">    <span class="keyword">if</span> (self.getQuorumVerifier().containsQuorum(p.ackSet)) {</span><br><span class="line">        <span class="keyword">if</span> (zxid != lastCommitted + <span class="number">1</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Commiting zxid 0x{} from {} not first!"</span>,</span><br><span class="line">                     Long.toHexString(zxid), followerAddr);</span><br><span class="line">            LOG.warn(<span class="string">"First is 0x{}"</span>, Long.toHexString(lastCommitted + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        outstandingProposals.remove(zxid);</span><br><span class="line">        <span class="keyword">if</span> (p.request != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 保存已经完成投票被commit的proposal</span></span><br><span class="line">            toBeApplied.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// We don't commit the new leader proposal</span></span><br><span class="line">        <span class="keyword">if</span> ((zxid &amp; <span class="number">0xffffffffL</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.request == <span class="keyword">null</span>) {</span><br><span class="line">                LOG.warn(<span class="string">"Going to commmit null request for proposal: {}"</span>, p);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 发送给所有follower commit消息</span></span><br><span class="line">            commit(zxid);</span><br><span class="line">            <span class="comment">// 同步给所有observer</span></span><br><span class="line">            inform(p);</span><br><span class="line">            <span class="comment">// commit proposal</span></span><br><span class="line">            zk.commitProcessor.commit(p.request);</span><br><span class="line">            <span class="keyword">if</span> (pendingSyncs.containsKey(zxid)) {</span><br><span class="line">                <span class="keyword">for</span> (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {</span><br><span class="line">                    sendSync(r);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// NEWLEADER消息</span></span><br><span class="line">            lastCommitted = zxid;</span><br><span class="line">            LOG.info(<span class="string">"Have quorum of supporters; starting up and setting last processed zxid: 0x{}"</span>,</span><br><span class="line">                     Long.toHexString(zk.getZxid()));</span><br><span class="line">            <span class="comment">// 启动leader zk服务</span></span><br><span class="line">            zk.startup();</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>AckRequestProcessor处理逻辑比较简单，Leader#processAck方法是用来处理针对proposal的ACK消息，这里相当于leader给自己投了一票。</p><p>如果已经满足大多数节点ACK，就发送commit消息给所有follower以及observer，接着调用CommitProcessor执行commit。</p><h2 id="CommitProcessor"><a href="#CommitProcessor" class="headerlink" title="CommitProcessor"></a>CommitProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Request nextPending = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!finished) {</span><br><span class="line">            <span class="keyword">int</span> len = toProcess.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">                <span class="comment">// leader Leader.ToBeAppliedRequestProcessor</span></span><br><span class="line">                <span class="comment">// follower FinalRequestProcessor 结束处理</span></span><br><span class="line">                nextProcessor.processRequest(toProcess.get(i));</span><br><span class="line">            }</span><br><span class="line">            toProcess.clear();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((queuedRequests.size() == <span class="number">0</span> || nextPending != <span class="keyword">null</span>)</span><br><span class="line">                        &amp;&amp; committedRequests.size() == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 在多数节点ack之前会阻塞</span></span><br><span class="line">                    wait();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// First check and see if the commit came in for the pending</span></span><br><span class="line">                <span class="comment">// request</span></span><br><span class="line">                <span class="keyword">if</span> ((queuedRequests.size() == <span class="number">0</span> || nextPending != <span class="keyword">null</span>)</span><br><span class="line">                        &amp;&amp; committedRequests.size() &gt; <span class="number">0</span>) {</span><br><span class="line">                    Request r = committedRequests.remove();</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * We match with nextPending so that we can move to the</span></span><br><span class="line"><span class="comment">                     * next request when it is committed. We also want to</span></span><br><span class="line"><span class="comment">                     * use nextPending because it has the cnxn member set</span></span><br><span class="line"><span class="comment">                     * properly.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">// 只有当已经可以commit消息保存到toProcess</span></span><br><span class="line">                    <span class="keyword">if</span> (nextPending != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; nextPending.sessionId == r.sessionId</span><br><span class="line">                            &amp;&amp; nextPending.cxid == r.cxid) {</span><br><span class="line">                        <span class="comment">// we want to send our version of the request.</span></span><br><span class="line">                        <span class="comment">// the pointer to the connection in the request</span></span><br><span class="line">                        nextPending.hdr = r.hdr;</span><br><span class="line">                        nextPending.txn = r.txn;</span><br><span class="line">                        nextPending.zxid = r.zxid;</span><br><span class="line">                        toProcess.add(nextPending);</span><br><span class="line">                        nextPending = <span class="keyword">null</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// this request came from someone else so just</span></span><br><span class="line">                        <span class="comment">// send the commit packet</span></span><br><span class="line">                        toProcess.add(r);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We haven't matched the pending requests, so go back to</span></span><br><span class="line">            <span class="comment">// waiting</span></span><br><span class="line">            <span class="comment">// 等待处理第一个请求, 保证顺序性</span></span><br><span class="line">            <span class="keyword">if</span> (nextPending != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                <span class="comment">// Process the next requests in the queuedRequests</span></span><br><span class="line">                <span class="keyword">while</span> (nextPending == <span class="keyword">null</span> &amp;&amp; queuedRequests.size() &gt; <span class="number">0</span>) {</span><br><span class="line">                    Request request = queuedRequests.remove();</span><br><span class="line">                    <span class="keyword">switch</span> (request.type) {</span><br><span class="line">                    <span class="keyword">case</span> OpCode.create:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.delete:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.setData:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.multi:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.setACL:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.createSession:</span><br><span class="line">                    <span class="keyword">case</span> OpCode.closeSession:</span><br><span class="line">                        nextPending = request;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OpCode.sync:</span><br><span class="line">                        <span class="keyword">if</span> (matchSyncs) {</span><br><span class="line">                            nextPending = request;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            toProcess.add(request);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        toProcess.add(request);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Interrupted exception while waiting"</span>, e);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing CommitProcessor to exit"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    LOG.info(<span class="string">"CommitProcessor exited loop!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!finished) {</span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Committed a null!"</span>,</span><br><span class="line">                     <span class="keyword">new</span> Exception(<span class="string">"committing a null! "</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Committing request:: "</span> + request);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 增加commitRequest, 唤醒线程</span></span><br><span class="line">        committedRequests.add(request);</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="comment">// request.addRQRec("&gt;commit");</span></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">        LOG.debug(<span class="string">"Processing request:: "</span> + request);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!finished) {</span><br><span class="line">        queuedRequests.add(request);</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LearnerHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来循环处理正常消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">            ia.readRecord(qp, <span class="string">"packet"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (qp.getType() == Leader.PING) {</span><br><span class="line">                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logQuorumPacket(LOG, traceMask, <span class="string">'i'</span>, qp);</span><br><span class="line">            }</span><br><span class="line">            tickOfLastAck = leader.self.tick;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ByteBuffer bb;</span><br><span class="line">            <span class="keyword">long</span> sessionId;</span><br><span class="line">            <span class="keyword">int</span> cxid;</span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (qp.getType()) {</span><br><span class="line">            <span class="keyword">case</span> Leader.ACK:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.learnerType == LearnerType.OBSERVER) {</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                        LOG.debug(<span class="string">"Received ACK from Observer  "</span> + <span class="keyword">this</span>.sid);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                leader.processAck(<span class="keyword">this</span>.sid, qp.getZxid(), sock.getLocalSocketAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing shutdown"</span>, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        LOG.warn(<span class="string">"******* GOODBYE "</span></span><br><span class="line">                 + (sock != <span class="keyword">null</span> ? sock.getRemoteSocketAddress() : <span class="string">"&lt;null&gt;"</span>)</span><br><span class="line">                 + <span class="string">" ********"</span>);</span><br><span class="line">        shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAck</span><span class="params">(<span class="keyword">long</span> sid, <span class="keyword">long</span> zxid, SocketAddress followerAddr)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 是否满足大多数节点ACK</span></span><br><span class="line">    <span class="keyword">if</span> (self.getQuorumVerifier().containsQuorum(p.ackSet)) {</span><br><span class="line">        <span class="keyword">if</span> (zxid != lastCommitted + <span class="number">1</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Commiting zxid 0x{} from {} not first!"</span>,</span><br><span class="line">                     Long.toHexString(zxid), followerAddr);</span><br><span class="line">            LOG.warn(<span class="string">"First is 0x{}"</span>, Long.toHexString(lastCommitted + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        outstandingProposals.remove(zxid);</span><br><span class="line">        <span class="keyword">if</span> (p.request != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 保存已经完成投票被commit的proposal</span></span><br><span class="line">            toBeApplied.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// We don't commit the new leader proposal</span></span><br><span class="line">        <span class="keyword">if</span> ((zxid &amp; <span class="number">0xffffffffL</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.request == <span class="keyword">null</span>) {</span><br><span class="line">                LOG.warn(<span class="string">"Going to commmit null request for proposal: {}"</span>, p);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 发送给所有follower commit消息</span></span><br><span class="line">            commit(zxid);</span><br><span class="line">            <span class="comment">// 同步给所有observer</span></span><br><span class="line">            inform(p);</span><br><span class="line">            <span class="comment">// commit proposal</span></span><br><span class="line">            zk.commitProcessor.commit(p.request);</span><br><span class="line">            <span class="keyword">if</span> (pendingSyncs.containsKey(zxid)) {</span><br><span class="line">                <span class="keyword">for</span> (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {</span><br><span class="line">                    sendSync(r);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结合ProposalRequestProcessor，在接收到请求时会将proposal发送给所有follower，然后将proposal写入事务日志并且定期提交。而请求会保存到CommitProcessor queuedRequests数组中，在LearnerHandler#run中收到follower ACK回复后会进行过半判断，如果达到过半节点ACK就调用提交到CommitProcessor committedRequests中。</p><p>CommitProcessor线程本身会按照请求顺序处理提交的事务消息，接着将消息发送给下一个处理器ToBeAppliedRequestProcessor。</p><h2 id="Leader-ToBeAppliedRequestProcessor"><a href="#Leader-ToBeAppliedRequestProcessor" class="headerlink" title="Leader.ToBeAppliedRequestProcessor"></a>Leader.ToBeAppliedRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line">ConcurrentLinkedQueue&lt;Proposal&gt; toBeApplied = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Proposal&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAck</span><span class="params">(<span class="keyword">long</span> sid, <span class="keyword">long</span> zxid, SocketAddress followerAddr)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 是否满足大多数节点ACK</span></span><br><span class="line">    <span class="keyword">if</span> (self.getQuorumVerifier().containsQuorum(p.ackSet)) {</span><br><span class="line">        <span class="keyword">if</span> (zxid != lastCommitted + <span class="number">1</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Commiting zxid 0x{} from {} not first!"</span>,</span><br><span class="line">                     Long.toHexString(zxid), followerAddr);</span><br><span class="line">            LOG.warn(<span class="string">"First is 0x{}"</span>, Long.toHexString(lastCommitted + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        outstandingProposals.remove(zxid);</span><br><span class="line">        <span class="keyword">if</span> (p.request != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 保存已经完成投票被commit的proposal</span></span><br><span class="line">            toBeApplied.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// We don't commit the new leader proposal</span></span><br><span class="line">        <span class="keyword">if</span> ((zxid &amp; <span class="number">0xffffffffL</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.request == <span class="keyword">null</span>) {</span><br><span class="line">                LOG.warn(<span class="string">"Going to commmit null request for proposal: {}"</span>, p);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 发送给所有follower commit消息</span></span><br><span class="line">            commit(zxid);</span><br><span class="line">            <span class="comment">// 同步给所有observer</span></span><br><span class="line">            inform(p);</span><br><span class="line">            <span class="comment">// commit proposal</span></span><br><span class="line">            zk.commitProcessor.commit(p.request);</span><br><span class="line">            <span class="keyword">if</span> (pendingSyncs.containsKey(zxid)) {</span><br><span class="line">                <span class="keyword">for</span> (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {</span><br><span class="line">                    sendSync(r);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// NEWLEADER消息</span></span><br><span class="line">            lastCommitted = zxid;</span><br><span class="line">            LOG.info(<span class="string">"Have quorum of supporters; starting up and setting last processed zxid: 0x{}"</span>,</span><br><span class="line">                     Long.toHexString(zk.getZxid()));</span><br><span class="line">            <span class="comment">// 启动leader zk服务</span></span><br><span class="line">            zk.startup();</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.ToBeAppliedRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>{</span><br><span class="line">    <span class="comment">// request.addRQRec("&gt;tobe");</span></span><br><span class="line">    <span class="comment">// FinalRequestProcessor 结束处理</span></span><br><span class="line">    next.processRequest(request);</span><br><span class="line">    Proposal p = toBeApplied.peek();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; p.request != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; p.request.zxid == request.zxid) {</span><br><span class="line">        <span class="comment">// 移除已经完成投票被commit的proposal</span></span><br><span class="line">        toBeApplied.remove();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处理器逻辑比较简单，在CommitProcessor处理完成后，移除Leader队列中暂存的可以commit的proposal。然后交给下一个处理FinalRequestProcessor处理。</p><h2 id="FinalRequestProcessor"><a href="#FinalRequestProcessor" class="headerlink" title="FinalRequestProcessor"></a>FinalRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// request.addRQRec("&gt;final");</span></span><br><span class="line">    <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (request.type == OpCode.ping) {</span><br><span class="line">        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">        ZooTrace.logRequest(LOG, traceMask, <span class="string">'E'</span>, request, <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">    ProcessTxnResult rc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (zks.outstandingChanges) {</span><br><span class="line">        <span class="keyword">while</span> (!zks.outstandingChanges.isEmpty()</span><br><span class="line">                &amp;&amp; zks.outstandingChanges.get(<span class="number">0</span>).zxid &lt;= request.zxid) {</span><br><span class="line">            ChangeRecord cr = zks.outstandingChanges.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cr.zxid &lt; request.zxid) {</span><br><span class="line">                LOG.warn(<span class="string">"Zxid outstanding "</span></span><br><span class="line">                         + cr.zxid</span><br><span class="line">                         + <span class="string">" is less than current "</span> + request.zxid);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (zks.outstandingChangesForPath.get(cr.path) == cr) {</span><br><span class="line">                zks.outstandingChangesForPath.remove(cr.path);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) {</span><br><span class="line">            TxnHeader hdr = request.hdr;</span><br><span class="line">            Record txn = request.txn;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改内存数据库</span></span><br><span class="line">            rc = zks.processTxn(hdr, txn);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// do not add non quorum packets to the queue.</span></span><br><span class="line">        <span class="keyword">if</span> (Request.isQuorum(request.type)) {</span><br><span class="line">            zks.getZKDatabase().addCommittedProposal(request);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭session</span></span><br><span class="line">    <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span> &amp;&amp; request.hdr.getType() == OpCode.closeSession) {</span><br><span class="line">        ServerCnxnFactory scxn = zks.getServerCnxnFactory();</span><br><span class="line">        <span class="comment">// this might be possible since</span></span><br><span class="line">        <span class="comment">// we might just be playing diffs from the leader</span></span><br><span class="line">        <span class="keyword">if</span> (scxn != <span class="keyword">null</span> &amp;&amp; request.cnxn == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// calling this if we have the cnxn results in the client's</span></span><br><span class="line">            <span class="comment">// close session response being lost - we've already closed</span></span><br><span class="line">            <span class="comment">// the session/socket here before we can send the closeSession</span></span><br><span class="line">            <span class="comment">// in the switch block below</span></span><br><span class="line">            <span class="comment">// 关闭连接, 移除watcher</span></span><br><span class="line">            scxn.closeSession(request.sessionId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.cnxn == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ServerCnxn cnxn = request.cnxn;</span><br><span class="line"></span><br><span class="line">    String lastOp = <span class="string">"NA"</span>;</span><br><span class="line">    zks.decInProcess();</span><br><span class="line">    Code err = Code.OK;</span><br><span class="line">    Record rsp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> closeSession = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span> &amp;&amp; request.hdr.getType() == OpCode.error) {</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get((</span><br><span class="line">                                             (ErrorTxn) request.txn).getErr()));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        KeeperException ke = request.getException();</span><br><span class="line">        <span class="keyword">if</span> (ke != <span class="keyword">null</span> &amp;&amp; request.type != OpCode.multi) {</span><br><span class="line">            <span class="keyword">throw</span> ke;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"{}"</span>, request);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">switch</span> (request.type) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> OpCode.create: {</span><br><span class="line">            lastOp = <span class="string">"CREA"</span>;</span><br><span class="line">            rsp = <span class="keyword">new</span> CreateResponse(rc.path);</span><br><span class="line">            err = Code.get(rc.err);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (SessionMovedException e) {</span><br><span class="line">        cnxn.sendCloseSession();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (KeeperException e) {</span><br><span class="line">        err = e.code();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">    ReplyHeader hdr =</span><br><span class="line">        <span class="keyword">new</span> ReplyHeader(request.cxid, lastZxid, err.intValue());</span><br><span class="line"></span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp,</span><br><span class="line">                                request.createTime, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cnxn.sendResponse(hdr, rsp, <span class="string">"response"</span>);</span><br><span class="line">        <span class="keyword">if</span> (closeSession) {</span><br><span class="line">            cnxn.sendCloseSession();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.error(<span class="string">"FIXMSG"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>FinalRequestProcessor是整个处理器链的最后一环，消息到达此处理器后，对于事务消息会按照请求修改内存数据库，修改过后所有客户端可读，接着发送响应到客户端。</p><h1 id="Follower处理器链"><a href="#Follower处理器链" class="headerlink" title="Follower处理器链"></a>Follower处理器链</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FollowerZooKeeperServer.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FollowerRequestProcessor -&gt; CommitProcessor -&gt; FinalRequestProcessor</span></span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</span><br><span class="line">                                          Long.toString(getServerId()), <span class="keyword">true</span>);</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> FollowerRequestProcessor(<span class="keyword">this</span>, commitProcessor);</span><br><span class="line">    ((FollowerRequestProcessor) firstProcessor).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SyncRequestProcessor -&gt; SendAckRequestProcessor</span></span><br><span class="line">    syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            <span class="keyword">new</span> SendAckRequestProcessor((Learner)getFollower()));</span><br><span class="line">    syncProcessor.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从Follower启动处理器链代码中可以看到，follwer处理器链分为两条，<code>FollowerRequestProcessor -&gt; CommitProcessor -&gt; FinalRequestProcessor</code>，<code>SyncRequestProcessor -&gt; SendAckRequestProcessor</code>。</p><p>由于其他处理器已经看过了，接下来只对FollowerRequestProcessor和SendAckRequestProcessor进行分析。</p><h2 id="FollowerRequestProcessor"><a href="#FollowerRequestProcessor" class="headerlink" title="FollowerRequestProcessor"></a>FollowerRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (!finished) {</span><br><span class="line">            Request request = queuedRequests.take();</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,</span><br><span class="line">                                    <span class="string">'F'</span>, request, <span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (request == Request.requestOfDeath) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// We want to queue the request to be processed before we submit</span></span><br><span class="line">            <span class="comment">// the request to the leader so that we are ready to receive</span></span><br><span class="line">            <span class="comment">// the response</span></span><br><span class="line">            nextProcessor.processRequest(request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We now ship the request to the leader. As with all</span></span><br><span class="line">            <span class="comment">// other quorum operations, sync also follows this code</span></span><br><span class="line">            <span class="comment">// path, but different from others, we need to keep track</span></span><br><span class="line">            <span class="comment">// of the sync operations this follower has pending, so we</span></span><br><span class="line">            <span class="comment">// add it to pendingSyncs.</span></span><br><span class="line">            <span class="keyword">switch</span> (request.type) {</span><br><span class="line">            <span class="keyword">case</span> OpCode.sync:</span><br><span class="line">                zks.pendingSyncs.add(request);</span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OpCode.create:</span><br><span class="line">            <span class="keyword">case</span> OpCode.delete:</span><br><span class="line">            <span class="keyword">case</span> OpCode.setData:</span><br><span class="line">            <span class="keyword">case</span> OpCode.setACL:</span><br><span class="line">            <span class="keyword">case</span> OpCode.createSession:</span><br><span class="line">            <span class="keyword">case</span> OpCode.closeSession:</span><br><span class="line">            <span class="keyword">case</span> OpCode.multi:</span><br><span class="line">                <span class="comment">// 转发请求到leader</span></span><br><span class="line">                zks.getFollower().request(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing exit"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    LOG.info(<span class="string">"FollowerRequestProcessor exited loop!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!finished) {</span><br><span class="line">        queuedRequests.add(request);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>FollowerRequestProcessor处理器位于<code>FollowerRequestProcessor -&gt; CommitProcessor -&gt; FinalRequestProcessor</code>处理器链的头部，用来处理客户端发送过来的消息。</p><p>对于事务请求，follower会转发给leader，其他类型，比如读请求会直接处理响应。</p><h2 id="SendAckRequestProcessor"><a href="#SendAckRequestProcessor" class="headerlink" title="SendAckRequestProcessor"></a>SendAckRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SendAckRequestProcessor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request si)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (si.type != OpCode.sync) {</span><br><span class="line">        QuorumPacket qp = <span class="keyword">new</span> QuorumPacket(Leader.ACK, si.hdr.getZxid(), <span class="keyword">null</span>,</span><br><span class="line">                                           <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            learner.writePacket(qp, <span class="keyword">false</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Closing connection to leader, exception during packet send"</span>, e);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!learner.sock.isClosed()) {</span><br><span class="line">                    learner.sock.close();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e1) {</span><br><span class="line">                <span class="comment">// Nothing to do, we are shutting things down, so an exception here is irrelevant</span></span><br><span class="line">                LOG.debug(<span class="string">"Ignoring error closing the connection"</span>, e1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>SyncRequestProcessor -&gt; SendAckRequestProcessor</code>处理器链用来处理leader发送过来的proposal请求，由SyncRequestProcessor写入日志文件，然后SendAckRequestProcessor回复一个ACK响应。</p><h1 id="Observer处理器链"><a href="#Observer处理器链" class="headerlink" title="Observer处理器链"></a>Observer处理器链</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObserverZooKeeperServer.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// We might consider changing the processor behaviour of</span></span><br><span class="line">    <span class="comment">// Observers to, for example, remove the disk sync requirements.</span></span><br><span class="line">    <span class="comment">// Currently, they behave almost exactly the same as followers.</span></span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</span><br><span class="line">                                          Long.toString(getServerId()), <span class="keyword">true</span>);</span><br><span class="line">    commitProcessor.start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> ObserverRequestProcessor(<span class="keyword">this</span>, commitProcessor);</span><br><span class="line">    ((ObserverRequestProcessor) firstProcessor).start();</span><br><span class="line">    syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            <span class="keyword">new</span> SendAckRequestProcessor(getObserver()));</span><br><span class="line">    syncProcessor.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从observer处理器链建立过程可以看到，observer处理器链和follower相似，也是分为两条，<code>ObserverRequestProcessor -&gt; CommitProcessor -&gt; FinalRequestProcessor</code>，<code>SyncRequestProcessor -&gt; SendAckRequestProcessor</code>。</p><h2 id="ObserverRequestProcessor"><a href="#ObserverRequestProcessor" class="headerlink" title="ObserverRequestProcessor"></a>ObserverRequestProcessor</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (!finished) {</span><br><span class="line">            Request request = queuedRequests.take();</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK,</span><br><span class="line">                                    <span class="string">'F'</span>, request, <span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (request == Request.requestOfDeath) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// We want to queue the request to be processed before we submit</span></span><br><span class="line">            <span class="comment">// the request to the leader so that we are ready to receive</span></span><br><span class="line">            <span class="comment">// the response</span></span><br><span class="line">            nextProcessor.processRequest(request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We now ship the request to the leader. As with all</span></span><br><span class="line">            <span class="comment">// other quorum operations, sync also follows this code</span></span><br><span class="line">            <span class="comment">// path, but different from others, we need to keep track</span></span><br><span class="line">            <span class="comment">// of the sync operations this Observer has pending, so we</span></span><br><span class="line">            <span class="comment">// add it to pendingSyncs.</span></span><br><span class="line">            <span class="keyword">switch</span> (request.type) {</span><br><span class="line">            <span class="keyword">case</span> OpCode.sync:</span><br><span class="line">                zks.pendingSyncs.add(request);</span><br><span class="line">                zks.getObserver().request(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OpCode.create:</span><br><span class="line">            <span class="keyword">case</span> OpCode.delete:</span><br><span class="line">            <span class="keyword">case</span> OpCode.setData:</span><br><span class="line">            <span class="keyword">case</span> OpCode.setACL:</span><br><span class="line">            <span class="keyword">case</span> OpCode.createSession:</span><br><span class="line">            <span class="keyword">case</span> OpCode.closeSession:</span><br><span class="line">            <span class="keyword">case</span> OpCode.multi:</span><br><span class="line">                zks.getObserver().request(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing exit"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    LOG.info(<span class="string">"ObserverRequestProcessor exited loop!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处理器功能也是将事务请求转发给leader，只处理非事务请求。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>非事务消息处理流程：leader/follower/observer直接处理返回。<br>事务消息处理流程：</p><ul><li>(follower/observer将请求转发到leader)</li><li>leader记录请求，写proposal日志，发送proposal到所有follower，给自己投一票</li><li>leader收到过半follower ACK，发送COMMIT消息到follower</li><li>leader处理commit请求，检查是否是按照请求顺序commit</li><li>leader+收到COMMIT消息的follwer提交操作到内存数据库</li><li>发送响应给客户端</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇session处理过程中我们略过了touchSession之后的消息处理过程，本篇将继续分析消息处理器链对消息的处理过程。&lt;/p&gt;
&lt;h1 id=&quot;Leader处理器链&quot;&gt;&lt;a href=&quot;#Leader处理器链&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】Session管理机制</title>
    <link href="https://haifuns.com/2022/03/09/zookeeper-06/"/>
    <id>https://haifuns.com/2022/03/09/zookeeper-06/</id>
    <published>2022-03-09T12:05:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>从前篇中我们已经了解了客户端与ZK服务端底层socket连接的建立过程，此时服务端还不能直接处理客户端发送过来的业务操作消息，因为会话还没有建立。在连接建立完成时客户端立即发送一条ConnectRequest请求，服务端收到消息后首先会建立会话，接下来我们将深入分析ZK中的session管理机制。</p><h1 id="Session建立"><a href="#Session建立" class="headerlink" title="Session建立"></a>Session建立</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIOServerCnxnFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!ss.socket().isClosed()) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 阻塞等待, 监听客户端网络连接</span></span><br><span class="line">            selector.select(<span class="number">1000</span>);</span><br><span class="line">            Set&lt;SelectionKey&gt; selected;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                selected = selector.selectedKeys();</span><br><span class="line">            }</span><br><span class="line">            ArrayList&lt;SelectionKey&gt; selectedList = <span class="keyword">new</span> ArrayList&lt;SelectionKey&gt;(</span><br><span class="line">                selected);</span><br><span class="line">            <span class="comment">// 保证不同客户端请求是随机处理的</span></span><br><span class="line">            Collections.shuffle(selectedList);</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : selectedList) {</span><br><span class="line">                <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 处理客户端连接请求</span></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 处理客户端读写请求</span></span><br><span class="line">                    NIOServerCnxn c = (NIOServerCnxn) k.attachment();</span><br><span class="line">                    c.doIO(k);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                        LOG.debug(<span class="string">"Unexpected ops in select "</span></span><br><span class="line">                                  + k.readyOps());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            selected.clear();</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Ignoring unexpected runtime exception"</span>, e);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Ignoring exception"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    closeAll();</span><br><span class="line">    LOG.info(<span class="string">"NIOServerCnxn factory exited run method"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NIOServerCnxn.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIO</span><span class="params">(SelectionKey k)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (sock == <span class="keyword">null</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"trying to do i/o on a null socket for session:0x"</span></span><br><span class="line">                     + Long.toHexString(sessionId));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k.isReadable()) {</span><br><span class="line">            <span class="comment">// 首先读取4个字节</span></span><br><span class="line">            <span class="keyword">int</span> rc = sock.read(incomingBuffer);</span><br><span class="line">            <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</span><br><span class="line">                    <span class="string">"Unable to read additional data from client sessionid 0x"</span></span><br><span class="line">                    + Long.toHexString(sessionId)</span><br><span class="line">                    + <span class="string">", likely client has closed socket"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果读取到4个字节, 当前请求长度</span></span><br><span class="line">            <span class="keyword">if</span> (incomingBuffer.remaining() == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">boolean</span> isPayload;</span><br><span class="line">                <span class="keyword">if</span> (incomingBuffer == lenBuffer) { <span class="comment">// start of next request</span></span><br><span class="line">                    incomingBuffer.flip();</span><br><span class="line">                    isPayload = readLength(k); <span class="comment">// 根据请求长度创建Buffer</span></span><br><span class="line">                    incomingBuffer.clear();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// continuation</span></span><br><span class="line">                    isPayload = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (isPayload) { <span class="comment">// not the case for 4letterword</span></span><br><span class="line">                    <span class="comment">// 开始正式从socket中读取数据</span></span><br><span class="line">                    readPayload();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// four letter words take care</span></span><br><span class="line">                    <span class="comment">// need not do anything else</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k.isWritable()) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readPayload</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 每个连接都对应一个incomingBuffer, 如果一个请求出现拆包, 在下次OP_READ事件时继续读取到incomingBuffer中</span></span><br><span class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() != <span class="number">0</span>) { <span class="comment">// have we read length bytes?</span></span><br><span class="line">        <span class="keyword">int</span> rc = sock.read(incomingBuffer); <span class="comment">// sock is non-blocking, so ok</span></span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</span><br><span class="line">                <span class="string">"Unable to read additional data from client sessionid 0x"</span></span><br><span class="line">                + Long.toHexString(sessionId)</span><br><span class="line">                + <span class="string">", likely client has closed socket"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读取完毕</span></span><br><span class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() == <span class="number">0</span>) { <span class="comment">// have we read length bytes?</span></span><br><span class="line">        packetReceived();</span><br><span class="line">        incomingBuffer.flip();</span><br><span class="line">        <span class="keyword">if</span> (!initialized) {</span><br><span class="line">            <span class="comment">// 如果没有完成session初始化, 此时读取到的第一个请求一定是ConnectRequest</span></span><br><span class="line">            readConnectRequest();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            readRequest();</span><br><span class="line">        }</span><br><span class="line">        lenBuffer.clear();</span><br><span class="line">        incomingBuffer = lenBuffer;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConnectRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (zkServer == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"ZooKeeperServer not running"</span>);</span><br><span class="line">    }</span><br><span class="line">    zkServer.processConnectRequest(<span class="keyword">this</span>, incomingBuffer);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZooKeeperServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConnectRequest</span><span class="params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    BinaryInputArchive bia = BinaryInputArchive.getArchive(<span class="keyword">new</span> ByteBufferInputStream(incomingBuffer));</span><br><span class="line">    <span class="comment">// Jute协议反序列化连接请求</span></span><br><span class="line">    ConnectRequest connReq = <span class="keyword">new</span> ConnectRequest();</span><br><span class="line">    connReq.deserialize(bia, <span class="string">"connect"</span>);</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">        LOG.debug(<span class="string">"Session establishment request from client "</span></span><br><span class="line">                  + cnxn.getRemoteSocketAddress()</span><br><span class="line">                  + <span class="string">" client's lastZxid is 0x"</span></span><br><span class="line">                  + Long.toHexString(connReq.getLastZxidSeen()));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> readOnly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        readOnly = bia.readBool(<span class="string">"readOnly"</span>);</span><br><span class="line">        cnxn.isOldClient = <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="comment">// this is ok -- just a packet from an old client which</span></span><br><span class="line">        <span class="comment">// doesn't contain readOnly field</span></span><br><span class="line">        LOG.warn(<span class="string">"Connection request from old client "</span></span><br><span class="line">                 + cnxn.getRemoteSocketAddress()</span><br><span class="line">                 + <span class="string">"; will be dropped if server is in r-o mode"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (readOnly == <span class="keyword">false</span> &amp;&amp; <span class="keyword">this</span> <span class="keyword">instanceof</span> ReadOnlyZooKeeperServer) {</span><br><span class="line">        String msg = <span class="string">"Refusing session request for not-read-only client "</span></span><br><span class="line">                     + cnxn.getRemoteSocketAddress();</span><br><span class="line">        LOG.info(msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloseRequestException(msg);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (connReq.getLastZxidSeen() &gt; zkDb.dataTree.lastProcessedZxid) {</span><br><span class="line">        String msg = <span class="string">"Refusing session request for client "</span></span><br><span class="line">                     + cnxn.getRemoteSocketAddress()</span><br><span class="line">                     + <span class="string">" as it has seen zxid 0x"</span></span><br><span class="line">                     + Long.toHexString(connReq.getLastZxidSeen())</span><br><span class="line">                     + <span class="string">" our last zxid is 0x"</span></span><br><span class="line">                     + Long.toHexString(getZKDatabase().getDataTreeLastProcessedZxid())</span><br><span class="line">                     + <span class="string">" client must try another server"</span>;</span><br><span class="line"></span><br><span class="line">        LOG.info(msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloseRequestException(msg);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> sessionTimeout = connReq.getTimeOut();</span><br><span class="line">    <span class="keyword">byte</span> passwd[] = connReq.getPasswd();</span><br><span class="line">    <span class="keyword">int</span> minSessionTimeout = getMinSessionTimeout();</span><br><span class="line">    <span class="keyword">if</span> (sessionTimeout &lt; minSessionTimeout) {</span><br><span class="line">        sessionTimeout = minSessionTimeout;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> maxSessionTimeout = getMaxSessionTimeout();</span><br><span class="line">    <span class="keyword">if</span> (sessionTimeout &gt; maxSessionTimeout) {</span><br><span class="line">        sessionTimeout = maxSessionTimeout;</span><br><span class="line">    }</span><br><span class="line">    cnxn.setSessionTimeout(sessionTimeout);</span><br><span class="line">    <span class="comment">// We don't want to receive any packets until we are sure that the</span></span><br><span class="line">    <span class="comment">// session is setup</span></span><br><span class="line">    cnxn.disableRecv();</span><br><span class="line">    <span class="keyword">long</span> sessionId = connReq.getSessionId();</span><br><span class="line">    <span class="keyword">if</span> (sessionId != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">long</span> clientSessionId = connReq.getSessionId();</span><br><span class="line">        LOG.info(<span class="string">"Client attempting to renew session 0x"</span></span><br><span class="line">                 + Long.toHexString(clientSessionId)</span><br><span class="line">                 + <span class="string">" at "</span> + cnxn.getRemoteSocketAddress());</span><br><span class="line">        serverCnxnFactory.closeSession(sessionId);</span><br><span class="line">        cnxn.setSessionId(sessionId);</span><br><span class="line">        reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.info(<span class="string">"Client attempting to establish new session at "</span></span><br><span class="line">                 + cnxn.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次创建请求时sessionId为空, 开始创建session</span></span><br><span class="line">        createSession(cnxn, passwd, sessionTimeout);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">createSession</span><span class="params">(ServerCnxn cnxn, <span class="keyword">byte</span> passwd[], <span class="keyword">int</span> timeout)</span> </span>{</span><br><span class="line">    <span class="comment">// 生成sessionId</span></span><br><span class="line">    <span class="keyword">long</span> sessionId = sessionTracker.createSession(timeout);</span><br><span class="line">    <span class="comment">// 生成密码</span></span><br><span class="line">    Random r = <span class="keyword">new</span> Random(sessionId ^ superSecret);</span><br><span class="line">    r.nextBytes(passwd);</span><br><span class="line">    ByteBuffer to = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    to.putInt(timeout);</span><br><span class="line">    cnxn.setSessionId(sessionId);</span><br><span class="line">    submitRequest(cnxn, sessionId, OpCode.createSession, <span class="number">0</span>, to, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> sessionId;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(ServerCnxn cnxn, <span class="keyword">long</span> sessionId, <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">int</span> xid, ByteBuffer bb, List&lt;Id&gt; authInfo)</span> </span>{</span><br><span class="line">    Request si = <span class="keyword">new</span> Request(cnxn, sessionId, xid, type, bb, authInfo);</span><br><span class="line">    submitRequest(si);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">while</span> (!running) {</span><br><span class="line">                    wait(<span class="number">1000</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not started"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 更新session过期时间, 重新分桶</span></span><br><span class="line">        touch(si.cnxn);</span><br><span class="line">        <span class="keyword">boolean</span> validpacket = Request.isValid(si.type);</span><br><span class="line">        <span class="keyword">if</span> (validpacket) {</span><br><span class="line">            firstProcessor.processRequest(si);</span><br><span class="line">            <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) {</span><br><span class="line">                incInProcess();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            LOG.warn(<span class="string">"Dropping packet at server of type "</span> + si.type);</span><br><span class="line">            <span class="comment">// if invalid packet drop the packet.</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (MissingSessionException e) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Dropping request: "</span> + e.getMessage());</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (RequestProcessorException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unable to process request:"</span> + e.getMessage(), e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch</span><span class="params">(ServerCnxn cnxn)</span> <span class="keyword">throws</span> MissingSessionException </span>{</span><br><span class="line">    <span class="keyword">if</span> (cnxn == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> id = cnxn.getSessionId();</span><br><span class="line">    <span class="keyword">int</span> to = cnxn.getSessionTimeout();</span><br><span class="line">    <span class="keyword">if</span> (!sessionTracker.touchSession(id, to)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MissingSessionException(</span><br><span class="line">            <span class="string">"No session with sessionid 0x"</span> + Long.toHexString(id)</span><br><span class="line">            + <span class="string">" exists, probably expired and removed"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionTrackerImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">createSession</span><span class="params">(<span class="keyword">int</span> sessionTimeout)</span> </span>{</span><br><span class="line">    addSession(nextSessionId, sessionTimeout);</span><br><span class="line">    <span class="keyword">return</span> nextSessionId++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSession</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> sessionTimeout)</span> </span>{</span><br><span class="line">    sessionsWithTimeout.put(id, sessionTimeout);</span><br><span class="line">    <span class="keyword">if</span> (sessionsById.get(id) == <span class="keyword">null</span>) {</span><br><span class="line">        SessionImpl s = <span class="keyword">new</span> SessionImpl(id, sessionTimeout, <span class="number">0</span>);</span><br><span class="line">        sessionsById.put(id, s);</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,</span><br><span class="line">                                     <span class="string">"SessionTrackerImpl --- Adding session 0x"</span></span><br><span class="line">                                     + Long.toHexString(id) + <span class="string">" "</span> + sessionTimeout);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK,</span><br><span class="line">                                     <span class="string">"SessionTrackerImpl --- Existing session 0x"</span></span><br><span class="line">                                     + Long.toHexString(id) + <span class="string">" "</span> + sessionTimeout);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    touchSession(id, sessionTimeout);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，服务端在接收到读事件时，首先会从消息中读取前4个字节，前4个字节表示消息长度，然后读取相应长度的字节。读取完字节消息后，判断当前连接是否已经完成初始化，如果没有完成初始化，那么当前消息是客户端发送过来的第一条请求ConnecReauest。接着把消息反序列化为ConnecRequest对象，从中取出sessionId，如果为空或者是0，就新建一个session，然后保存。</p><p>这里session的创建可以看到是为sessionId创建了一个对应的SessionImpl结构存放在map中，把sessionId返回了。另外可以看到在后续消息处理时，都会进行touchSession操作，然后把消息交给处理器链。</p><p>对于sessionId是如何生成的以及touchSession操作是在干什么本篇下文将继续分析，对于处理器链处理消息本篇暂时不涉及。</p><h1 id="SessionId生成"><a href="#SessionId生成" class="headerlink" title="SessionId生成"></a>SessionId生成</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeperServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) {</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 启动session管理组件</span></span><br><span class="line">    startSessionTracker();</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createSessionTracker</span><span class="params">()</span> </span>{</span><br><span class="line">    sessionTracker = <span class="keyword">new</span> SessionTrackerImpl(<span class="keyword">this</span>, zkDb.getSessionWithTimeOuts(),</span><br><span class="line">                                            tickTime, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SessionTrackerImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SessionTrackerImpl</span><span class="params">(SessionExpirer expirer,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ConcurrentHashMap&lt;Long, Integer&gt; sessionsWithTimeout, <span class="keyword">int</span> tickTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> sid)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"SessionTracker"</span>);</span><br><span class="line">    <span class="keyword">this</span>.expirer = expirer;</span><br><span class="line">    <span class="keyword">this</span>.expirationInterval = tickTime;</span><br><span class="line">    <span class="keyword">this</span>.sessionsWithTimeout = sessionsWithTimeout;</span><br><span class="line">    nextExpirationTime = roundToInterval(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">this</span>.nextSessionId = initializeNextSession(sid);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Long, Integer&gt; e : sessionsWithTimeout.entrySet()) {</span><br><span class="line">        addSession(e.getKey(), e.getValue());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initializeNextSession</span><span class="params">(<span class="keyword">long</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> nextSid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 时间戳41位, 左移24位后, **由于long最大63位**, 所以低24位是0, 高39位表示时间戳, 前两位丢失</span></span><br><span class="line">    <span class="comment">// 右移8位后, 高8位是0, 中间39位是时间戳, 低16位是0</span></span><br><span class="line">    nextSid = (System.currentTimeMillis() &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 高7位表示serverId, 低56是0</span></span><br><span class="line">    <span class="comment">// 或操作之后, 高7位表示serverId, 固定1位0, 中间39位是时间戳, 低16位是0</span></span><br><span class="line">    nextSid =  nextSid | (id &lt;&lt; <span class="number">56</span>);</span><br><span class="line">    <span class="keyword">return</span> nextSid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，当ZooKeeperServer启动时会创建一个会话跟踪器sessionTracker，初始化好nextSessionId（高7位表示serverId, 固定1位0, 中间39位是时间戳, 低16位是0），在需要创建session时直接使用nextSessionId，然后让其加1，下次需要创建session时就可以直接使用。</p><h1 id="Session分桶"><a href="#Session分桶" class="headerlink" title="Session分桶"></a>Session分桶</h1><p>接下来分析一下touchSession操作，相关代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SessionTrackerImpl.java</span></span><br><span class="line">HashMap&lt;Long, SessionImpl&gt; sessionsById = <span class="keyword">new</span> HashMap&lt;Long, SessionImpl&gt;();</span><br><span class="line"></span><br><span class="line">HashMap&lt;Long, SessionSet&gt; sessionSets = <span class="keyword">new</span> HashMap&lt;Long, SessionSet&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionSet</span> </span>{</span><br><span class="line">    HashSet&lt;SessionImpl&gt; sessions = <span class="keyword">new</span> HashSet&lt;SessionImpl&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">roundToInterval</span><span class="params">(<span class="keyword">long</span> time)</span> </span>{</span><br><span class="line">    <span class="comment">// We give a one interval grace period</span></span><br><span class="line">    <span class="comment">// 过期时间是expirationInterval的倍数</span></span><br><span class="line">    <span class="keyword">return</span> (time / expirationInterval + <span class="number">1</span>) * expirationInterval;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">touchSession</span><span class="params">(<span class="keyword">long</span> sessionId, <span class="keyword">int</span> timeout)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">        ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                                 ZooTrace.CLIENT_PING_TRACE_MASK,</span><br><span class="line">                                 <span class="string">"SessionTrackerImpl --- Touch session: 0x"</span></span><br><span class="line">                                 + Long.toHexString(sessionId) + <span class="string">" with timeout "</span> + timeout);</span><br><span class="line">    }</span><br><span class="line">    SessionImpl s = sessionsById.get(sessionId);</span><br><span class="line">    <span class="comment">// Return false, if the session doesn't exists or marked as closing</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isClosing()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// session下一次的过期时间</span></span><br><span class="line">    <span class="keyword">long</span> expireTime = roundToInterval(System.currentTimeMillis() + timeout);</span><br><span class="line">    <span class="keyword">if</span> (s.tickTime &gt;= expireTime) {</span><br><span class="line">        <span class="comment">// Nothing needs to be done</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// session分桶处理, expireTime -&gt; SessionSet</span></span><br><span class="line">    SessionSet set = sessionSets.get(s.tickTime);</span><br><span class="line">    <span class="keyword">if</span> (set != <span class="keyword">null</span>) {</span><br><span class="line">        set.sessions.remove(s);</span><br><span class="line">    }</span><br><span class="line">    s.tickTime = expireTime;</span><br><span class="line">    set = sessionSets.get(s.tickTime);</span><br><span class="line">    <span class="keyword">if</span> (set == <span class="keyword">null</span>) {</span><br><span class="line">        set = <span class="keyword">new</span> SessionSet();</span><br><span class="line">        sessionSets.put(expireTime, set);</span><br><span class="line">    }</span><br><span class="line">    set.sessions.add(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，在服务端session是分桶存储的，每个轮次的过期时间对应着这个时间过期的session集合，当每次接收到客户端消息时，都会更新一下session在桶中的位置。</p><h1 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h1><p>在连接正常建立之后，客户端会每隔一段时间向服务端发送Ping消息，相关代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnnx.SendThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    clientCnxnSocket.introduce(<span class="keyword">this</span>, sessionId);</span><br><span class="line">    clientCnxnSocket.updateNow();</span><br><span class="line">    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">long</span> lastPingRwServer = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span> (state.isAlive()) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) {</span><br><span class="line">                <span class="keyword">if</span> (!isFirstConnect) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// don't re-establish connection if we are closing</span></span><br><span class="line">                <span class="keyword">if</span> (closing || !state.isAlive()) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 与zk服务端建立长连接</span></span><br><span class="line">                startConnect();</span><br><span class="line">                clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state.isConnected()) {</span><br><span class="line">                <span class="comment">// readTimeout - (当前时间 - 上次发送消息时间)</span></span><br><span class="line">                <span class="keyword">int</span> timeToNextPing = readTimeout / <span class="number">2</span></span><br><span class="line">                                     - clientCnxnSocket.getIdleSend();</span><br><span class="line">                <span class="keyword">if</span> (timeToNextPing &lt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 发送ping消息</span></span><br><span class="line">                    sendPing();</span><br><span class="line">                    clientCnxnSocket.updateLastSend();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (timeToNextPing &lt; to) {</span><br><span class="line">                        to = timeToNextPing;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.<span class="keyword">this</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cleanup();</span><br><span class="line">    clientCnxnSocket.close();</span><br><span class="line">    <span class="keyword">if</span> (state.isAlive()) {</span><br><span class="line">        eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(Event.EventType.None,</span><br><span class="line">                                                Event.KeeperState.Disconnected, <span class="keyword">null</span>));</span><br><span class="line">    }</span><br><span class="line">    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(),</span><br><span class="line">                             <span class="string">"SendThread exitedloop."</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPing</span><span class="params">()</span> </span>{</span><br><span class="line">    lastPingSentNs = System.nanoTime();</span><br><span class="line">    RequestHeader h = <span class="keyword">new</span> RequestHeader(-<span class="number">2</span>, OpCode.ping);</span><br><span class="line">    queuePacket(h, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可知，客户端每隔固定时间都会向服务端发送一条Ping消息，而从前面分析可知，服务端在收到Ping消息会进行touchSession操作刷新session过期时间。</p><h1 id="定时清理"><a href="#定时清理" class="headerlink" title="定时清理"></a>定时清理</h1><p>当客户端超过过期时间没有过心跳，服务端会删除session断开连接，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SessionTrackerImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (running) {</span><br><span class="line">            currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (nextExpirationTime &gt; currentTime) {</span><br><span class="line">                <span class="keyword">this</span>.wait(nextExpirationTime - currentTime);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            SessionSet set;</span><br><span class="line">            <span class="comment">// 移除已经过期的session分桶</span></span><br><span class="line">            set = sessionSets.remove(nextExpirationTime);</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (SessionImpl s : set.sessions) {</span><br><span class="line">                    setSessionClosing(s.sessionId);</span><br><span class="line">                    expirer.expire(s);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 更新下次过期时间</span></span><br><span class="line">            nextExpirationTime += expirationInterval;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    LOG.info(<span class="string">"SessionTrackerImpl exited loop!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(Session session)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> sessionId = session.getSessionId();</span><br><span class="line">    LOG.info(<span class="string">"Expiring session 0x"</span> + Long.toHexString(sessionId)</span><br><span class="line">             + <span class="string">", timeout of "</span> + session.getTimeout() + <span class="string">"ms exceeded"</span>);</span><br><span class="line">    close(sessionId);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在客户端与服务端的底层socket连接建立成功后，客户端会立即发送一条ConnectRequest消息，服务端收到这条消息后会为其创建session，其中sessionId包含serverId、时间戳、计数器三部分保证唯一性。session在服务端按照过期时间分桶存储，每当客户端发送过来消息，服务端都会判断session过期时间是否进入下一轮，如果已经进入下一轮就更新session在桶中的位置，即更新session过期时间。客户端会定期向服务端发送Ping消息，同时服务端会定期清理达到过期时间的session桶。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从前篇中我们已经了解了客户端与ZK服务端底层socket连接的建立过程，此时服务端还不能直接处理客户端发送过来的业务操作消息，因为会话还没有建立。在连接建立完成时客户端立即发送一条ConnectRequest请求，服务端收到消息后首先会建立会话，接下来我们将深入分析ZK中的</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】客户端通信</title>
    <link href="https://haifuns.com/2022/02/28/zookeeper-05/"/>
    <id>https://haifuns.com/2022/02/28/zookeeper-05/</id>
    <published>2022-02-28T11:35:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>本篇用来分析客户端与服务端底层连接建立的过程，首先回忆一下ZKServer启动过程中已经开始监听客户端请求的server socket，然后分析一下客户端启动过程中client socket创建过程。</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>在前几篇分析中，我们已经看过了server socket启动的部分代码，QuorumPeer初始化过程创建了一个网络连接工厂ServerCnxnFactory，默认情况下是基于NIO的NIOServerCnxnFactory，在QuorumPeer start过程中cnxnFactory也伴随着start，也就是此时server socket开始监听处理客户端请求。相关代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeerMain.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 网络连接工厂, 默认使用NIO, NIOServerCnxnFactory</span></span><br><span class="line">    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">    cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                          config.getMaxClientCnxns());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quorumPeer代表一个zk节点</span></span><br><span class="line">    quorumPeer = <span class="keyword">new</span> QuorumPeer();</span><br><span class="line">    quorumPeer.setClientPortAddress(config.getClientPortAddress());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    quorumPeer.start();</span><br><span class="line">    quorumPeer.join();</span><br><span class="line">  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">    LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumPeer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 从磁盘加载快照和事务日志, 恢复数据到内存数据库</span></span><br><span class="line">  loadDataBase();</span><br><span class="line">  <span class="comment">// 建立网络通信</span></span><br><span class="line">  cnxnFactory.start();</span><br><span class="line">  <span class="comment">// 开始leader选举, 初始化相应组件(其实是在initLeaderElection)</span></span><br><span class="line">  startLeaderElection();</span><br><span class="line">  <span class="comment">// 启动当前线程</span></span><br><span class="line">  <span class="keyword">super</span>.start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServerCnxnFactory</span> <span class="keyword">extends</span> <span class="title">ServerCnxnFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">  ServerSocketChannel ss;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Selector selector = Selector.open(); <span class="comment">// 多路复用组件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Thread thread;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(InetSocketAddress addr, <span class="keyword">int</span> maxcc)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    configureSaslLogin();</span><br><span class="line"></span><br><span class="line">    thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">"NIOServerCxn.Factory:"</span> + addr);</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    maxClientCnxns = maxcc;</span><br><span class="line">    <span class="keyword">this</span>.ss = ServerSocketChannel.open();</span><br><span class="line">    ss.socket().setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">    LOG.info(<span class="string">"binding to port "</span> + addr);</span><br><span class="line">    ss.socket().bind(addr);</span><br><span class="line">    ss.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    ss.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!ss.socket().isClosed()) {</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 阻塞等待, 监听客户端网络连接</span></span><br><span class="line">        selector.select(<span class="number">1000</span>);</span><br><span class="line">        Set&lt;SelectionKey&gt; selected;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">          selected = selector.selectedKeys();</span><br><span class="line">        }</span><br><span class="line">        ArrayList&lt;SelectionKey&gt; selectedList = <span class="keyword">new</span> ArrayList&lt;SelectionKey&gt;(</span><br><span class="line">          selected);</span><br><span class="line">        <span class="comment">// 保证不同客户端请求是随机处理的</span></span><br><span class="line">        Collections.shuffle(selectedList);</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey k : selectedList) {</span><br><span class="line">          <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 处理客户端连接请求</span></span><br><span class="line">            SocketChannel sc = ((ServerSocketChannel) k</span><br><span class="line">                                .channel()).accept();</span><br><span class="line">            InetAddress ia = sc.socket().getInetAddress();</span><br><span class="line">            <span class="keyword">int</span> cnxncount = getClientCnxnCount(ia);</span><br><span class="line">            <span class="keyword">if</span> (maxClientCnxns &gt; <span class="number">0</span> &amp;&amp; cnxncount &gt;= maxClientCnxns) {</span><br><span class="line">              LOG.warn(<span class="string">"Too many connections from "</span> + ia</span><br><span class="line">                       + <span class="string">" - max is "</span> + maxClientCnxns );</span><br><span class="line">              sc.close();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">              LOG.info(<span class="string">"Accepted socket connection from "</span></span><br><span class="line">                       + sc.socket().getRemoteSocketAddress());</span><br><span class="line">              sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">              SelectionKey sk = sc.register(selector,</span><br><span class="line">                                            SelectionKey.OP_READ);</span><br><span class="line">              NIOServerCnxn cnxn = createConnection(sc, sk);</span><br><span class="line">              sk.attach(cnxn);</span><br><span class="line">              addCnxn(cnxn);</span><br><span class="line">            }</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 处理客户端读写请求</span></span><br><span class="line">            NIOServerCnxn c = (NIOServerCnxn) k.attachment();</span><br><span class="line">            c.doIO(k);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">              LOG.debug(<span class="string">"Unexpected ops in select "</span></span><br><span class="line">                        + k.readyOps());</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        selected.clear();</span><br><span class="line">      } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Ignoring unexpected runtime exception"</span>, e);</span><br><span class="line">      } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.warn(<span class="string">"Ignoring exception"</span>, e);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    closeAll();</span><br><span class="line">    LOG.info(<span class="string">"NIOServerCnxn factory exited run method"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>ZooKeeper类是客户端库的主类，是客户端的入口，这里从其常用的构造方法入手进行分析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZooKeeper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">this</span>(connectString, sessionTimeout, watcher, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">boolean</span> canBeReadOnly)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    LOG.info(<span class="string">"Initiating client connection, connectString="</span> + connectString</span><br><span class="line">             + <span class="string">" sessionTimeout="</span> + sessionTimeout + <span class="string">" watcher="</span> + watcher);</span><br><span class="line"></span><br><span class="line">    watchManager.defaultWatcher = watcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析zk机器列表</span></span><br><span class="line">    ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</span><br><span class="line">        connectString);</span><br><span class="line">    <span class="comment">// 可以循环随机选择一个zk机器返回</span></span><br><span class="line">    HostProvider hostProvider = <span class="keyword">new</span> StaticHostProvider(</span><br><span class="line">        connectStringParser.getServerAddresses());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心组件ClientCnxn, 与服务端通信</span></span><br><span class="line">    cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</span><br><span class="line">                          hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</span><br><span class="line">                          getClientCnxnSocket(), canBeReadOnly);</span><br><span class="line">    cnxn.start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCnxn.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    sendThread.start();</span><br><span class="line">    eventThread.start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendThread.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientCnxnSocket clientCnxnSocket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        clientCnxnSocket.introduce(<span class="keyword">this</span>, sessionId);</span><br><span class="line">        clientCnxnSocket.updateNow();</span><br><span class="line">        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">        <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">long</span> lastPingRwServer = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (state.isAlive()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) {</span><br><span class="line">                    <span class="keyword">if</span> (!isFirstConnect) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Thread.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// don't re-establish connection if we are closing</span></span><br><span class="line">                    <span class="keyword">if</span> (closing || !state.isAlive()) {</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 与zk服务端建立长连接</span></span><br><span class="line">                    startConnect();</span><br><span class="line">                    clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 后续操作暂时不看</span></span><br><span class="line">            } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        state = States.CONNECTING;</span><br><span class="line"></span><br><span class="line">        InetSocketAddress addr;</span><br><span class="line">        <span class="keyword">if</span> (rwServerAddress != <span class="keyword">null</span>) {</span><br><span class="line">            addr = rwServerAddress;</span><br><span class="line">            rwServerAddress = <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            addr = hostProvider.next(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        setName(getName().replaceAll(<span class="string">"\\(.*\\)"</span>,</span><br><span class="line">                                     <span class="string">"("</span> + addr.getHostName() + <span class="string">":"</span> + addr.getPort() + <span class="string">")"</span>));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            zooKeeperSaslClient = <span class="keyword">new</span> ZooKeeperSaslClient(<span class="string">"zookeeper/"</span> + addr.getHostName());</span><br><span class="line">        } <span class="keyword">catch</span> (LoginException e) {</span><br><span class="line">            <span class="comment">// An authentication error occurred when the SASL client tried to initialize:</span></span><br><span class="line">            <span class="comment">// for Kerberos this means that the client failed to authenticate with the KDC.</span></span><br><span class="line">            <span class="comment">// This is different from an authentication error that occurs during communication</span></span><br><span class="line">            <span class="comment">// with the Zookeeper server, which is handled below.</span></span><br><span class="line">            LOG.warn(<span class="string">"SASL configuration failed: "</span> + e + <span class="string">" Will continue connection to Zookeeper server without "</span></span><br><span class="line">                     + <span class="string">"SASL authentication, if Zookeeper server allows it."</span>);</span><br><span class="line">            eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</span><br><span class="line">                                       Watcher.Event.EventType.None,</span><br><span class="line">                                       Watcher.Event.KeeperState.AuthFailed, <span class="keyword">null</span>));</span><br><span class="line">            saslLoginFailed = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        logStartConnect(addr);</span><br><span class="line"></span><br><span class="line">        clientCnxnSocket.connect(addr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">primeConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        LOG.info(<span class="string">"Socket connection established to "</span></span><br><span class="line">                 + clientCnxnSocket.getRemoteSocketAddress()</span><br><span class="line">                 + <span class="string">", initiating session"</span>);</span><br><span class="line">        isFirstConnect = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> sessId = (seenRwServerBefore) ? sessionId : <span class="number">0</span>;</span><br><span class="line">        ConnectRequest conReq = <span class="keyword">new</span> ConnectRequest(<span class="number">0</span>, lastZxid,</span><br><span class="line">                sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">        <span class="keyword">synchronized</span> (outgoingQueue) {</span><br><span class="line">            <span class="comment">// We add backwards since we are pushing into the front</span></span><br><span class="line">            <span class="comment">// Only send if there's a pending watch</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> here we have the only remaining use of zooKeeper in</span></span><br><span class="line">            <span class="comment">// this class. It's to be eliminated!</span></span><br><span class="line">            <span class="keyword">if</span> (!disableAutoWatchReset) {</span><br><span class="line">                <span class="comment">// 监听znode数据变化</span></span><br><span class="line">                List&lt;String&gt; dataWatches = zooKeeper.getDataWatches();</span><br><span class="line">                <span class="comment">// 监听znode是否存在</span></span><br><span class="line">                List&lt;String&gt; existWatches = zooKeeper.getExistWatches();</span><br><span class="line">                <span class="comment">// 监听znode下子节点的变化</span></span><br><span class="line">                List&lt;String&gt; childWatches = zooKeeper.getChildWatches();</span><br><span class="line">                <span class="keyword">if</span> (!dataWatches.isEmpty()</span><br><span class="line">                        || !existWatches.isEmpty() || !childWatches.isEmpty()) {</span><br><span class="line">                    SetWatches sw = <span class="keyword">new</span> SetWatches(lastZxid,</span><br><span class="line">                                                   prependChroot(dataWatches),</span><br><span class="line">                                                   prependChroot(existWatches),</span><br><span class="line">                                                   prependChroot(childWatches));</span><br><span class="line">                    RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">                    h.setType(ZooDefs.OpCode.setWatches);</span><br><span class="line">                    h.setXid(-<span class="number">8</span>);</span><br><span class="line">                    Packet packet = <span class="keyword">new</span> Packet(h, <span class="keyword">new</span> ReplyHeader(), sw, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    outgoingQueue.addFirst(packet);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (AuthData id : authInfo) {</span><br><span class="line">                outgoingQueue.addFirst(<span class="keyword">new</span> Packet(<span class="keyword">new</span> RequestHeader(-<span class="number">4</span>,</span><br><span class="line">                                                  OpCode.auth), <span class="keyword">null</span>, <span class="keyword">new</span> AuthPacket(<span class="number">0</span>, id.scheme,</span><br><span class="line">                                                          id.data), <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送ConnectRequest</span></span><br><span class="line">            outgoingQueue.addFirst(<span class="keyword">new</span> Packet(<span class="keyword">null</span>, <span class="keyword">null</span>, conReq,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>, readOnly));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续对这个连接仅关注读写请求</span></span><br><span class="line">        clientCnxnSocket.enableReadWriteOnly();</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"Session establishment request sent on "</span></span><br><span class="line">                      + clientCnxnSocket.getRemoteSocketAddress());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCnxnSocketNIO.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    SocketChannel sock = createSock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        registerAndConnect(sock, addr);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unable to open socket to "</span> + addr);</span><br><span class="line">        sock.close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">    initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Reset incomingBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lenBuffer.clear();</span><br><span class="line">    incomingBuffer = lenBuffer;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">SocketChannel <span class="title">createSock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    SocketChannel sock;</span><br><span class="line">    sock = SocketChannel.open();</span><br><span class="line">    sock.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    sock.socket().setSoLinger(<span class="keyword">false</span>, -<span class="number">1</span>);</span><br><span class="line">    sock.socket().setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerAndConnect</span><span class="params">(SocketChannel sock, InetSocketAddress addr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    <span class="comment">// 建立底层物理连接</span></span><br><span class="line">    <span class="keyword">boolean</span> immediateConnect = sock.connect(addr);</span><br><span class="line">    <span class="keyword">if</span> (immediateConnect) {</span><br><span class="line">        sendThread.primeConnection();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码就可以看到，客户端启动过程会启动一个核心组件ClientCnxn，其中包含一个SendThread线程，线程启动时如果连接还没有建立会向随机一个服务端节点发起建立长连接，然后发送一个ConnectRequest消息注册会话。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>在服务端启动过程中会初始化好网络连接工厂（默认基于NIO）并启动，此时服务端会启动一个socket server服务监听客户端请求。需要注意的是这时候还不能处理客户端消息直到服务端完成初始化数据同步时，节点完成ZooKeeperServer启动。</li><li>在客户端启动过程中会启动客户端通信组件ClientCnxn，ClientCnxn中包含一个消息发送线程，如果此时连接还没有建立，就会立即向一个随机服务端节点发起建立底层长连接，然后发送一个ConnectRequest请求注册会话。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇用来分析客户端与服务端底层连接建立的过程，首先回忆一下ZKServer启动过程中已经开始监听客户端请求的server socket，然后分析一下客户端启动过程中client socket创建过程。&lt;/p&gt;
&lt;h1 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; clas</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】初始化数据同步</title>
    <link href="https://haifuns.com/2022/02/23/zookeeper-04/"/>
    <id>https://haifuns.com/2022/02/23/zookeeper-04/</id>
    <published>2022-02-23T12:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>在leader选举完成后，集群中的所有节点都确定好自己的角色，此时节点间数据有可能并未达到一致，接下来follower节点将从leader同步数据完成初始化。</p><h1 id="建立网络通信"><a href="#建立网络通信" class="headerlink" title="建立网络通信"></a>建立网络通信</h1><p>首先确定好各自角色的节点会执行对应的功能逻辑，leader节点会启动socket server监听所有learner的连接请求，而follower节点会向leader节点发起socket连接请求。</p><h2 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 主要逻辑</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) {</span><br><span class="line">            <span class="comment">// 根据当前节点的状态执行相应的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) {</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                LOG.info(<span class="string">"LEADING"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    setLeader(makeLeader(logFactory));</span><br><span class="line">                    leader.lead();</span><br><span class="line">                    setLeader(<span class="keyword">null</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>) {</span><br><span class="line">                        leader.shutdown(<span class="string">"Forcing shutdown"</span>);</span><br><span class="line">                        setLeader(<span class="keyword">null</span>);</span><br><span class="line">                    }</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Leader <span class="title">makeLeader</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Leader(<span class="keyword">this</span>, <span class="keyword">new</span> LeaderZooKeeperServer(logFactory,</span><br><span class="line">        <span class="keyword">this</span>,<span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">    self.end_fle = System.currentTimeMillis();</span><br><span class="line">    LOG.info(<span class="string">"LEADING - LEADER ELECTION TOOK - "</span> +</span><br><span class="line">             (self.end_fle - self.start_fle));</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    zk.registerJMX(<span class="keyword">new</span> LeaderBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        self.tick = <span class="number">0</span>;</span><br><span class="line">        zk.loadData();</span><br><span class="line"></span><br><span class="line">        leaderStateSummary = <span class="keyword">new</span> StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start thread that waits for connection requests from</span></span><br><span class="line">        <span class="comment">// new followers.</span></span><br><span class="line">        <span class="comment">// 监听follower连接请求</span></span><br><span class="line">        cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();</span><br><span class="line">        cnxAcceptor.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        zk.unregisterJMX(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LearnerCnxAcceptor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (!stop) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Socket s = ss.accept();</span><br><span class="line">                    <span class="comment">// start with the initLimit, once the ack is processed</span></span><br><span class="line">                    <span class="comment">// in LearnerHandler switch to the syncLimit</span></span><br><span class="line">                    s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">                    s.setTcpNoDelay(nodelay);</span><br><span class="line">                    <span class="comment">// learner处理器</span></span><br><span class="line">                    LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, Leader.<span class="keyword">this</span>);</span><br><span class="line">                    fh.start();</span><br><span class="line">                } <span class="keyword">catch</span> (SocketException e) {</span><br><span class="line">                    <span class="keyword">if</span> (stop) {</span><br><span class="line">                        LOG.info(<span class="string">"exception while shutting down acceptor: "</span></span><br><span class="line">                                 + e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// When Leader.shutdown() calls ss.close(),</span></span><br><span class="line">                        <span class="comment">// the call to accept throws an exception.</span></span><br><span class="line">                        <span class="comment">// We catch and set stop to true.</span></span><br><span class="line">                        stop = <span class="keyword">true</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Exception while accepting follower"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">halt</span><span class="params">()</span> </span>{</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码中可以看到，当节点状态为为LEADING时，会初始化一个Leader，并执行lead逻辑。Leader中包含一个LearnerCnxAcceptor接受处理所有从leader学习的请求，LearnerCnxAcceptor里会启动一个SocketServer然后监听客户端连接请求，当有连接时，为其创建一个LearnerHandler处理器并启动。</p><h2 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 主要逻辑</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) {</span><br><span class="line">            <span class="comment">// 根据当前节点的状态执行相应的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) {</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    LOG.info(<span class="string">"FOLLOWING"</span>);</span><br><span class="line">                    setFollower(makeFollower(logFactory));</span><br><span class="line">                    follower.followLeader();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    follower.shutdown();</span><br><span class="line">                    setFollower(<span class="keyword">null</span>);</span><br><span class="line">                    setPeerState(ServerState.LOOKING);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Follower <span class="title">makeFollower</span><span class="params">(FileTxnSnapLog logFactory)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Follower(<span class="keyword">this</span>, <span class="keyword">new</span> FollowerZooKeeperServer(logFactory, </span><br><span class="line">        <span class="keyword">this</span>,<span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(), <span class="keyword">this</span>.zkDb));</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Follower.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    self.end_fle = System.currentTimeMillis();</span><br><span class="line">    LOG.info(<span class="string">"FOLLOWING - LEADER ELECTION TOOK - "</span> +</span><br><span class="line">             (self.end_fle - self.start_fle));</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line">    fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 寻找leader地址</span></span><br><span class="line">        InetSocketAddress addr = findLeader();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 向leader发起连接</span></span><br><span class="line">            connectToLeader(addr);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Exception when following the leader"</span>, e);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sock.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e1) {</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clear pending revalidations</span></span><br><span class="line">            pendingRevalidations.clear();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        zk.unregisterJMX((Learner)<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Learner</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectToLeader</span><span class="params">(InetSocketAddress addr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ConnectException, InterruptedException </span>{</span><br><span class="line">    sock = <span class="keyword">new</span> Socket();</span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">    <span class="comment">// 尝试连接, 最多尝试5次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            sock.connect(addr, self.tickTime * self.syncLimit);</span><br><span class="line">            sock.setTcpNoDelay(nodelay);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">if</span> (tries == <span class="number">4</span>) {</span><br><span class="line">                LOG.error(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                LOG.warn(<span class="string">"Unexpected exception, tries="</span> + tries +</span><br><span class="line">                         <span class="string">", connecting to "</span> + addr, e);</span><br><span class="line">                sock = <span class="keyword">new</span> Socket();</span><br><span class="line">                sock.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// jute协议, archive缓冲输入流</span></span><br><span class="line">    leaderIs = BinaryInputArchive.getArchive(<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                   sock.getInputStream()));</span><br><span class="line">    bufferedOutput = <span class="keyword">new</span> BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">    <span class="comment">// jute协议, archive缓冲输出流</span></span><br><span class="line">    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当节点状态为为FOLLOWING时，会初始化一个Follwer，并执行followLeader逻辑。follwer找到leader地址后会发起建立一个socket连接。</p><h1 id="注册-amp-同步数据"><a href="#注册-amp-同步数据" class="headerlink" title="注册&amp;同步数据"></a>注册&amp;同步数据</h1><blockquote><p>在以后的通信过程中，ZooKeeper消息交换使用的序列化协议为Jute，Jute是ZK中自己实现的序列化协议。</p></blockquote><p>当follower向leader发起的连接成功建立后，立即会向leader发起注册，之后开始从leader同步数据。</p><h2 id="follower-1"><a href="#follower-1" class="headerlink" title="follower"></a>follower</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follower.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    self.end_fle = System.currentTimeMillis();</span><br><span class="line">    LOG.info(<span class="string">"FOLLOWING - LEADER ELECTION TOOK - "</span> +</span><br><span class="line">             (self.end_fle - self.start_fle));</span><br><span class="line">    self.start_fle = <span class="number">0</span>;</span><br><span class="line">    self.end_fle = <span class="number">0</span>;</span><br><span class="line">    fzk.registerJMX(<span class="keyword">new</span> FollowerBean(<span class="keyword">this</span>, zk), self.jmxLocalPeerBean);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 寻找leader地址</span></span><br><span class="line">        InetSocketAddress addr = findLeader();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 向leader发起连接</span></span><br><span class="line">            connectToLeader(addr);</span><br><span class="line">            <span class="comment">// 注册到leader</span></span><br><span class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//check to see if the leader zxid is lower than ours</span></span><br><span class="line">            <span class="comment">//this should never happen but is just a safety check</span></span><br><span class="line">            <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);</span><br><span class="line">            <span class="keyword">if</span> (newEpoch &lt; self.getAcceptedEpoch()) {</span><br><span class="line">                LOG.error(<span class="string">"Proposed leader epoch "</span> + ZxidUtils.zxidToString(newEpochZxid)</span><br><span class="line">                          + <span class="string">" is less than our accepted epoch "</span> + ZxidUtils.zxidToString(self.getAcceptedEpoch()));</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Error: Epoch of leader is lower"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 从leader同步数据</span></span><br><span class="line">            syncWithLeader(newEpochZxid);</span><br><span class="line">            QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">            <span class="keyword">while</span> (self.isRunning()) {</span><br><span class="line">                <span class="comment">// 读取从leader同步过来的数据</span></span><br><span class="line">                readPacket(qp);</span><br><span class="line">                <span class="comment">// 数据处理</span></span><br><span class="line">                processPacket(qp);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Exception when following the leader"</span>, e);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sock.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e1) {</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clear pending revalidations</span></span><br><span class="line">            pendingRevalidations.clear();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        zk.unregisterJMX((Learner)<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Learner.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">registerWithLeader</span><span class="params">(<span class="keyword">int</span> pktType)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Send follower info, including last zxid and sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> lastLoggedZxid = self.getLastLoggedZxid();</span><br><span class="line">    QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">    qp.setType(pktType);</span><br><span class="line">    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add sid to payload</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LearnerInfo li = <span class="keyword">new</span> LearnerInfo(self.getId(), <span class="number">0x10000</span>);</span><br><span class="line">    ByteArrayOutputStream bsid = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);</span><br><span class="line">    <span class="comment">// 使用Jute协议序列化</span></span><br><span class="line">    boa.writeRecord(li, <span class="string">"LearnerInfo"</span>);</span><br><span class="line">    qp.setData(bsid.toByteArray());</span><br><span class="line"></span><br><span class="line">    writePacket(qp, <span class="keyword">true</span>);</span><br><span class="line">    readPacket(qp);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line">    <span class="keyword">if</span> (qp.getType() == Leader.LEADERINFO) { <span class="comment">// leader收到请求后会返回一个LEADERINFO信息</span></span><br><span class="line">        <span class="comment">// we are connected to a 1.0 server so accept the new epoch and read the next packet</span></span><br><span class="line">        leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();</span><br><span class="line">        <span class="keyword">byte</span> epochBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">final</span> ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);</span><br><span class="line">        <span class="keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) {</span><br><span class="line">            wrappedEpochBytes.putInt((<span class="keyword">int</span>)self.getCurrentEpoch());</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (newEpoch == self.getAcceptedEpoch()) {</span><br><span class="line">            <span class="comment">// since we have already acked an epoch equal to the leaders, we cannot ack</span></span><br><span class="line">            <span class="comment">// again, but we still need to send our lastZxid to the leader so that we can</span></span><br><span class="line">            <span class="comment">// sync with it if it does assume leadership of the epoch.</span></span><br><span class="line">            <span class="comment">// the -1 indicates that this reply should not count as an ack for the new epoch</span></span><br><span class="line">            wrappedEpochBytes.putInt(-<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Leaders epoch, "</span> + newEpoch + <span class="string">" is less than accepted epoch, "</span> + self.getAcceptedEpoch());</span><br><span class="line">        }</span><br><span class="line">        QuorumPacket ackNewEpoch = <span class="keyword">new</span> QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, <span class="keyword">null</span>);</span><br><span class="line">        writePacket(ackNewEpoch, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (newEpoch &gt; self.getAcceptedEpoch()) {</span><br><span class="line">            self.setAcceptedEpoch(newEpoch);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (qp.getType() != Leader.NEWLEADER) {</span><br><span class="line">            LOG.error(<span class="string">"First packet should have been NEWLEADER"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"First packet should have been NEWLEADER"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> qp.getZxid();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Learner.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncWithLeader</span><span class="params">(<span class="keyword">long</span> newLeaderZxid)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">    QuorumPacket ack = <span class="keyword">new</span> QuorumPacket(Leader.ACK, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">    <span class="keyword">long</span> newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);</span><br><span class="line"></span><br><span class="line">    readPacket(qp);</span><br><span class="line">    LinkedList&lt;Long&gt; packetsCommitted = <span class="keyword">new</span> LinkedList&lt;Long&gt;();</span><br><span class="line">    LinkedList&lt;PacketInFlight&gt; packetsNotCommitted = <span class="keyword">new</span> LinkedList&lt;PacketInFlight&gt;();</span><br><span class="line">    <span class="keyword">synchronized</span> (zk) {</span><br><span class="line">        <span class="keyword">if</span> (qp.getType() == Leader.DIFF) { <span class="comment">// 合并</span></span><br><span class="line">            LOG.info(<span class="string">"Getting a diff from the leader 0x"</span> + Long.toHexString(qp.getZxid()));</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (qp.getType() == Leader.SNAP) { <span class="comment">// 同步快照</span></span><br><span class="line">            LOG.info(<span class="string">"Getting a snapshot from leader"</span>);</span><br><span class="line">            <span class="comment">// The leader is going to dump the database</span></span><br><span class="line">            <span class="comment">// clear our own database and read</span></span><br><span class="line">            zk.getZKDatabase().clear();</span><br><span class="line">            zk.getZKDatabase().deserializeSnapshot(leaderIs);</span><br><span class="line">            String signature = leaderIs.readString(<span class="string">"signature"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!signature.equals(<span class="string">"BenWasHere"</span>)) {</span><br><span class="line">                LOG.error(<span class="string">"Missing signature. Got "</span> + signature);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing signature"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (qp.getType() == Leader.TRUNC) { <span class="comment">// 回滚, 截断日志</span></span><br><span class="line">            <span class="comment">//we need to truncate the log to the lastzxid of the leader</span></span><br><span class="line">            LOG.warn(<span class="string">"Truncating log to get in sync with the leader 0x"</span></span><br><span class="line">                     + Long.toHexString(qp.getZxid()));</span><br><span class="line">            <span class="keyword">boolean</span> truncated = zk.getZKDatabase().truncateLog(qp.getZxid());</span><br><span class="line">            <span class="keyword">if</span> (!truncated) {</span><br><span class="line">                <span class="comment">// not able to truncate the log</span></span><br><span class="line">                LOG.error(<span class="string">"Not able to truncate the log "</span></span><br><span class="line">                          + Long.toHexString(qp.getZxid()));</span><br><span class="line">                System.exit(<span class="number">13</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            LOG.error(<span class="string">"Got unexpected packet from leader "</span></span><br><span class="line">                      + qp.getType() + <span class="string">" exiting ... "</span> );</span><br><span class="line">            System.exit(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());</span><br><span class="line">        zk.createSessionTracker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lastQueued = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in V1.0 we take a snapshot when we get the NEWLEADER message, but in pre V1.0</span></span><br><span class="line">        <span class="comment">// we take the snapshot at the UPDATE, since V1.0 also gets the UPDATE (after the NEWLEADER)</span></span><br><span class="line">        <span class="comment">// we need to make sure that we don't take the snapshot twice.</span></span><br><span class="line">        <span class="keyword">boolean</span> snapshotTaken = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// we are now going to start getting transactions to apply followed by an UPTODATE</span></span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">while</span> (self.isRunning()) {</span><br><span class="line">            readPacket(qp);</span><br><span class="line">            <span class="keyword">switch</span> (qp.getType()) {</span><br><span class="line">            <span class="keyword">case</span> Leader.PROPOSAL:</span><br><span class="line">                PacketInFlight pif = <span class="keyword">new</span> PacketInFlight();</span><br><span class="line">                pif.hdr = <span class="keyword">new</span> TxnHeader();</span><br><span class="line">                pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);</span><br><span class="line">                <span class="keyword">if</span> (pif.hdr.getZxid() != lastQueued + <span class="number">1</span>) {</span><br><span class="line">                    LOG.warn(<span class="string">"Got zxid 0x"</span></span><br><span class="line">                             + Long.toHexString(pif.hdr.getZxid())</span><br><span class="line">                             + <span class="string">" expected 0x"</span></span><br><span class="line">                             + Long.toHexString(lastQueued + <span class="number">1</span>));</span><br><span class="line">                }</span><br><span class="line">                lastQueued = pif.hdr.getZxid();</span><br><span class="line">                packetsNotCommitted.add(pif);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Leader.COMMIT:</span><br><span class="line">                <span class="keyword">if</span> (!snapshotTaken) {</span><br><span class="line">                    pif = packetsNotCommitted.peekFirst();</span><br><span class="line">                    <span class="keyword">if</span> (pif.hdr.getZxid() != qp.getZxid()) {</span><br><span class="line">                        LOG.warn(<span class="string">"Committing "</span> + qp.getZxid() + <span class="string">", but next proposal is "</span> + pif.hdr.getZxid());</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        zk.processTxn(pif.hdr, pif.rec);</span><br><span class="line">                        packetsNotCommitted.remove();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    packetsCommitted.add(qp.getZxid());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Leader.INFORM:</span><br><span class="line">                TxnHeader hdr = <span class="keyword">new</span> TxnHeader();</span><br><span class="line">                Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);</span><br><span class="line">                zk.processTxn(hdr, txn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Leader.UPTODATE: <span class="comment">// 同步完成标识</span></span><br><span class="line">                <span class="keyword">if</span> (!snapshotTaken) { <span class="comment">// true for the pre v1.0 case</span></span><br><span class="line">                    zk.takeSnapshot();</span><br><span class="line">                    self.setCurrentEpoch(newEpoch);</span><br><span class="line">                }</span><br><span class="line">                self.cnxnFactory.setZooKeeperServer(zk);</span><br><span class="line">                <span class="keyword">break</span> outerLoop;</span><br><span class="line">            <span class="keyword">case</span> Leader.NEWLEADER: <span class="comment">// it will be NEWLEADER in v1.0</span></span><br><span class="line">                zk.takeSnapshot();</span><br><span class="line">                self.setCurrentEpoch(newEpoch);</span><br><span class="line">                snapshotTaken = <span class="keyword">true</span>;</span><br><span class="line">                writePacket(<span class="keyword">new</span> QuorumPacket(Leader.ACK, newLeaderZxid, <span class="keyword">null</span>, <span class="keyword">null</span>), <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ack.setZxid(ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>));</span><br><span class="line">    writePacket(ack, <span class="keyword">true</span>);</span><br><span class="line">    sock.setSoTimeout(self.tickTime * self.syncLimit);</span><br><span class="line">    zk.startup();</span><br><span class="line">    <span class="comment">// We need to log the stuff that came in between the snapshot and the uptodate</span></span><br><span class="line">    <span class="keyword">if</span> (zk <span class="keyword">instanceof</span> FollowerZooKeeperServer) {</span><br><span class="line">        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer)zk;</span><br><span class="line">        <span class="keyword">for</span> (PacketInFlight p : packetsNotCommitted) {</span><br><span class="line">            fzk.logRequest(p.hdr, p.rec);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Long zxid : packetsCommitted) {</span><br><span class="line">            fzk.commit(zxid);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从如上代码可以看到，当follower与leader连接建立后，follower会立即向leader发送注册请求，leader会响应一个LEADERINFO类型的消息，然后follower回复一个ACKEPOCH类型的消息，至此注册就完成了。</p><p>注册完成后follower开始同步leader数据，follower开始接收并处理leader发送过来的各种类型的消息。</p><p>消息类型和处理：</p><ul><li>FOLLOWERINFO：follower发送给leader协议版本</li><li>LEADERINFO：follower收到leader发送的第一条消息，包含协议版本和leader epoch</li><li>ACKEPOCH：follower回复leader LEADERINFO的消息，用来确认leader epoch</li><li>NEWLEADER：leader发送给follower zxid</li><li>DIFF：leader通知follower开始合并差异</li><li>TRUNC：leader通知follower截断日志</li><li>SNAP：leader通知follower开始传输快照</li><li>PROPOSAL：leader发送给follower的提案</li><li>ACK：follower响应leader PROPOSAL</li><li>COMMIT：leader通知follower提交proposal</li><li>UPTODATE：leader通知follower完成同步，可以开始响应客户端</li></ul><h2 id="leader-1"><a href="#leader-1" class="headerlink" title="leader"></a>leader</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LearnerHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ia = BinaryInputArchive.getArchive(<span class="keyword">new</span> BufferedInputStream(sock</span><br><span class="line">                                           .getInputStream()));</span><br><span class="line">        bufferedOutput = <span class="keyword">new</span> BufferedOutputStream(sock.getOutputStream());</span><br><span class="line">        oa = BinaryOutputArchive.getArchive(bufferedOutput);</span><br><span class="line"></span><br><span class="line">        QuorumPacket qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">        <span class="comment">// Jute反序列化消息</span></span><br><span class="line">        ia.readRecord(qp, <span class="string">"packet"</span>);</span><br><span class="line">        <span class="keyword">if</span> (qp.getType() != Leader.FOLLOWERINFO &amp;&amp; qp.getType() != Leader.OBSERVERINFO) {</span><br><span class="line">            LOG.error(<span class="string">"First packet "</span> + qp.toString()</span><br><span class="line">                      + <span class="string">" is not FOLLOWERINFO or OBSERVERINFO!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">byte</span> learnerInfoData[] = qp.getData();</span><br><span class="line">        <span class="keyword">if</span> (learnerInfoData != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (learnerInfoData.length == <span class="number">8</span>) {</span><br><span class="line">                ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);</span><br><span class="line">                <span class="keyword">this</span>.sid = bbsid.getLong();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                LearnerInfo li = <span class="keyword">new</span> LearnerInfo();</span><br><span class="line">                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(learnerInfoData), li);</span><br><span class="line">                <span class="keyword">this</span>.sid = li.getServerid();</span><br><span class="line">                <span class="keyword">this</span>.version = li.getProtocolVersion();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">this</span>.sid = leader.followerCounter.getAndDecrement();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">"Follower sid: "</span> + sid + <span class="string">" : info : "</span></span><br><span class="line">                 + leader.self.quorumPeers.get(sid));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qp.getType() == Leader.OBSERVERINFO) {</span><br><span class="line">            learnerType = LearnerType.OBSERVER;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> peerLastZxid;</span><br><span class="line">        StateSummary ss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> zxid = qp.getZxid();</span><br><span class="line">        <span class="keyword">long</span> newEpoch = leader.getEpochToPropose(<span class="keyword">this</span>.getSid(), lastAcceptedEpoch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getVersion() &lt; <span class="number">0x10000</span>) { <span class="comment">// peer未注册</span></span><br><span class="line">            <span class="comment">// we are going to have to extrapolate the epoch information</span></span><br><span class="line">            <span class="keyword">long</span> epoch = ZxidUtils.getEpochFromZxid(zxid);</span><br><span class="line">            ss = <span class="keyword">new</span> StateSummary(epoch, zxid);</span><br><span class="line">            <span class="comment">// fake the message</span></span><br><span class="line">            leader.waitForEpochAck(<span class="keyword">this</span>.getSid(), ss);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">byte</span> ver[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">            ByteBuffer.wrap(ver).putInt(<span class="number">0x10000</span>);</span><br><span class="line">            QuorumPacket newEpochPacket = <span class="keyword">new</span> QuorumPacket(Leader.LEADERINFO, ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>), ver, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 发送leader info消息</span></span><br><span class="line">            oa.writeRecord(newEpochPacket, <span class="string">"packet"</span>);</span><br><span class="line">            bufferedOutput.flush();</span><br><span class="line">            QuorumPacket ackEpochPacket = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">            <span class="comment">// 读取响应消息</span></span><br><span class="line">            ia.readRecord(ackEpochPacket, <span class="string">"packet"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ackEpochPacket.getType() != Leader.ACKEPOCH) {</span><br><span class="line">                LOG.error(ackEpochPacket.toString()</span><br><span class="line">                          + <span class="string">" is not ACKEPOCH"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());</span><br><span class="line">            ss = <span class="keyword">new</span> StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());</span><br><span class="line">            <span class="comment">// 等待多数节点ack消息</span></span><br><span class="line">            leader.waitForEpochAck(<span class="keyword">this</span>.getSid(), ss);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// peer最大的zxid</span></span><br><span class="line">        peerLastZxid = ss.getLastZxid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the default to send to the follower */</span></span><br><span class="line">        <span class="comment">// 默认情况下同步快照</span></span><br><span class="line">        <span class="keyword">int</span> packetToSend = Leader.SNAP;</span><br><span class="line">        <span class="keyword">long</span> zxidToSend = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> leaderLastZxid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/** the packets that the follower needs to get updates from **/</span></span><br><span class="line">        <span class="keyword">long</span> updates = peerLastZxid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* we are sending the diff check if we have proposals in memory to be able to</span></span><br><span class="line"><span class="comment">         * send a diff to the</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ReentrantReadWriteLock lock = leader.zk.getZKDatabase().getLogLock();</span><br><span class="line">        ReadLock rl = lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取zk commit日志读锁</span></span><br><span class="line">            rl.lock();</span><br><span class="line">            <span class="comment">// 最大commit日志</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();</span><br><span class="line">            <span class="comment">// 最小commit日志</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();</span><br><span class="line">            LOG.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</span><br><span class="line">                     + <span class="string">" maxCommittedLog=0x"</span> + Long.toHexString(maxCommittedLog)</span><br><span class="line">                     + <span class="string">" minCommittedLog=0x"</span> + Long.toHexString(minCommittedLog)</span><br><span class="line">                     + <span class="string">" peerLastZxid=0x"</span> + Long.toHexString(peerLastZxid));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// commit日志列表</span></span><br><span class="line">            LinkedList&lt;Proposal&gt; proposals = leader.zk.getZKDatabase().getCommittedLog();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (proposals.size() != <span class="number">0</span>) {</span><br><span class="line">                LOG.debug(<span class="string">"proposal size is {}"</span>, proposals.size());</span><br><span class="line">                <span class="comment">// 如果peer最大的zxid在leader最小commit日志和最大commit日志之间</span></span><br><span class="line">                <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</span><br><span class="line">                        &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) {</span><br><span class="line">                    LOG.debug(<span class="string">"Sending proposals to follower"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// as we look through proposals, this variable keeps track of previous</span></span><br><span class="line">                    <span class="comment">// proposal Id.</span></span><br><span class="line">                    <span class="keyword">long</span> prevProposalZxid = minCommittedLog;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Keep track of whether we are about to send the first packet.</span></span><br><span class="line">                    <span class="comment">// Before sending the first packet, we have to tell the learner</span></span><br><span class="line">                    <span class="comment">// whether to expect a trunc or a diff</span></span><br><span class="line">                    <span class="keyword">boolean</span> firstPacket = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If we are here, we can use committedLog to sync with</span></span><br><span class="line">                    <span class="comment">// follower. Then we only need to decide whether to</span></span><br><span class="line">                    <span class="comment">// send trunc or not</span></span><br><span class="line">                    packetToSend = Leader.DIFF;</span><br><span class="line">                    zxidToSend = maxCommittedLog;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (Proposal propose : proposals) {</span><br><span class="line">                        <span class="comment">// skip the proposals the peer already has</span></span><br><span class="line">                        <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) {</span><br><span class="line">                            prevProposalZxid = propose.packet.getZxid();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">// 要求follower从minCommittedLog截断, 之后的日志重新同步, 防止peer中有leader没有的事务日志</span></span><br><span class="line">                            <span class="comment">// If we are sending the first packet, figure out whether to trunc</span></span><br><span class="line">                            <span class="comment">// in case the follower has some proposals that the leader doesn't</span></span><br><span class="line">                            <span class="keyword">if</span> (firstPacket) {</span><br><span class="line">                                firstPacket = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="comment">// Does the peer have some proposals that the leader hasn't seen yet</span></span><br><span class="line">                                <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) {</span><br><span class="line">                                    <span class="comment">// send a trunc message before sending the diff</span></span><br><span class="line">                                    packetToSend = Leader.TRUNC;</span><br><span class="line">                                    zxidToSend = prevProposalZxid;</span><br><span class="line">                                    updates = zxidToSend;</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                            <span class="comment">// 把事务提交到发送队列中, 每条事务消息跟随一个commit消息</span></span><br><span class="line">                            queuePacket(propose.packet);</span><br><span class="line">                            QuorumPacket qcommit = <span class="keyword">new</span> QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),</span><br><span class="line">                                                                    <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            queuePacket(qcommit);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) {</span><br><span class="line">                    LOG.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x{} updates=0x{}"</span>,</span><br><span class="line">                              Long.toHexString(maxCommittedLog),</span><br><span class="line">                              Long.toHexString(updates));</span><br><span class="line"></span><br><span class="line">                    packetToSend = Leader.TRUNC;</span><br><span class="line">                    zxidToSend = maxCommittedLog;</span><br><span class="line">                    updates = zxidToSend;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    LOG.warn(<span class="string">"Unhandled proposal scenario"</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) {</span><br><span class="line">                <span class="comment">// The leader may recently take a snapshot, so the committedLog</span></span><br><span class="line">                <span class="comment">// is empty. We don't need to send snapshot if the follow</span></span><br><span class="line">                <span class="comment">// is already sync with in-memory db.</span></span><br><span class="line">                LOG.debug(<span class="string">"committedLog is empty but leader and follower "</span></span><br><span class="line">                          + <span class="string">"are in sync, zxid=0x{}"</span>,</span><br><span class="line">                          Long.toHexString(peerLastZxid));</span><br><span class="line">                packetToSend = Leader.DIFF;</span><br><span class="line">                zxidToSend = peerLastZxid;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// just let the state transfer happen</span></span><br><span class="line">                LOG.debug(<span class="string">"proposals is empty"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            LOG.info(<span class="string">"Sending "</span> + Leader.getPacketType(packetToSend));</span><br><span class="line">            <span class="comment">// 添加follower到leader forwarding follower列表</span></span><br><span class="line">            leaderLastZxid = leader.startForwarding(<span class="keyword">this</span>, updates);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// commit日志读锁解锁</span></span><br><span class="line">            rl.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        QuorumPacket newLeaderQP = <span class="keyword">new</span> QuorumPacket(Leader.NEWLEADER,</span><br><span class="line">                ZxidUtils.makeZxid(newEpoch, <span class="number">0</span>), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (getVersion() &lt; <span class="number">0x10000</span>) {</span><br><span class="line">            oa.writeRecord(newLeaderQP, <span class="string">"packet"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 最后添加一条NEWLEADER消息</span></span><br><span class="line">            queuedPackets.add(newLeaderQP);</span><br><span class="line">        }</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line">        <span class="comment">//Need to set the zxidToSend to the latest zxid</span></span><br><span class="line">        <span class="keyword">if</span> (packetToSend == Leader.SNAP) {</span><br><span class="line">            zxidToSend = leader.zk.getZKDatabase().getDataTreeLastProcessedZxid();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 发送一条消息通知learner开始同步数据</span></span><br><span class="line">        oa.writeRecord(<span class="keyword">new</span> QuorumPacket(packetToSend, zxidToSend, <span class="keyword">null</span>, <span class="keyword">null</span>), <span class="string">"packet"</span>);</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if we are not truncating or sending a diff just send a snapshot */</span></span><br><span class="line">        <span class="keyword">if</span> (packetToSend == Leader.SNAP) {</span><br><span class="line">            LOG.info(<span class="string">"Sending snapshot last zxid of peer is 0x"</span></span><br><span class="line">                     + Long.toHexString(peerLastZxid) + <span class="string">" "</span></span><br><span class="line">                     + <span class="string">" zxid of leader is 0x"</span></span><br><span class="line">                     + Long.toHexString(leaderLastZxid)</span><br><span class="line">                     + <span class="string">"sent zxid of db as 0x"</span></span><br><span class="line">                     + Long.toHexString(zxidToSend));</span><br><span class="line">            <span class="comment">// Dump data to peer</span></span><br><span class="line">            <span class="comment">// 如果需要同步快照就把整个db序列化</span></span><br><span class="line">            leader.zk.getZKDatabase().serializeSnapshot(oa);</span><br><span class="line">            oa.writeString(<span class="string">"BenWasHere"</span>, <span class="string">"signature"</span>);</span><br><span class="line">        }</span><br><span class="line">        bufferedOutput.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start sending packets</span></span><br><span class="line">        <span class="keyword">new</span> Thread() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                Thread.currentThread().setName(</span><br><span class="line">                    <span class="string">"Sender-"</span> + sock.getRemoteSocketAddress());</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    sendPackets();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } .start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Have to wait for the first ACK, wait until</span></span><br><span class="line"><span class="comment">         * the leader is ready, and only then we can</span></span><br><span class="line"><span class="comment">         * start processing messages.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 等待同步之后peer响应的ACK消息</span></span><br><span class="line">        qp = <span class="keyword">new</span> QuorumPacket();</span><br><span class="line">        ia.readRecord(qp, <span class="string">"packet"</span>);</span><br><span class="line">        <span class="keyword">if</span> (qp.getType() != Leader.ACK) {</span><br><span class="line">            LOG.error(<span class="string">"Next packet was supposed to be an ACK"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 处理ACK消息</span></span><br><span class="line">        leader.processAck(<span class="keyword">this</span>.sid, qp.getZxid(), sock.getLocalSocketAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now that the ack has been processed expect the syncLimit</span></span><br><span class="line">        sock.setSoTimeout(leader.self.tickTime * leader.self.syncLimit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Wait until leader starts up</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 等待leader启动</span></span><br><span class="line">        <span class="keyword">synchronized</span> (leader.zk) {</span><br><span class="line">            <span class="keyword">while</span> (!leader.zk.isRunning() &amp;&amp; !<span class="keyword">this</span>.isInterrupted()) {</span><br><span class="line">                leader.zk.wait(<span class="number">20</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Mutation packets will be queued during the serialize,</span></span><br><span class="line">        <span class="comment">// so we need to mark when the peer can actually start</span></span><br><span class="line">        <span class="comment">// using the data</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 发送一条UPTODATE消息, 表明follower目前消息时最新的, 可以开始处理客户端请求</span></span><br><span class="line">        queuedPackets.add(<span class="keyword">new</span> QuorumPacket(Leader.UPTODATE, -<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来循环处理正常消息</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">if</span> (sock != <span class="keyword">null</span> &amp;&amp; !sock.isClosed()) {</span><br><span class="line">            LOG.error(<span class="string">"Unexpected exception causing shutdown while sock "</span></span><br><span class="line">                      + <span class="string">"still open"</span>, e);</span><br><span class="line">            <span class="comment">//close the socket to make sure the</span></span><br><span class="line">            <span class="comment">//other side can see it being close</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                sock.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException ie) {</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        LOG.error(<span class="string">"Unexpected exception causing shutdown"</span>, e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        LOG.warn(<span class="string">"******* GOODBYE "</span></span><br><span class="line">                 + (sock != <span class="keyword">null</span> ? sock.getRemoteSocketAddress() : <span class="string">"&lt;null&gt;"</span>)</span><br><span class="line">                 + <span class="string">" ********"</span>);</span><br><span class="line">        shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForEpochAck</span><span class="params">(<span class="keyword">long</span> id, StateSummary ss)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (electingFollowers) {</span><br><span class="line">        <span class="keyword">if</span> (electionFinished) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (ss.getCurrentEpoch() != -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ss.isMoreRecentThan(leaderStateSummary)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Follower is ahead of the leader, leader summary: "</span></span><br><span class="line">                                      + leaderStateSummary.getCurrentEpoch()</span><br><span class="line">                                      + <span class="string">" (current epoch), "</span></span><br><span class="line">                                      + leaderStateSummary.getLastZxid()</span><br><span class="line">                                      + <span class="string">" (last zxid)"</span>);</span><br><span class="line">            }</span><br><span class="line">            electingFollowers.add(id);</span><br><span class="line">        }</span><br><span class="line">        QuorumVerifier verifier = self.getQuorumVerifier();</span><br><span class="line">        <span class="keyword">if</span> (electingFollowers.contains(self.getId()) &amp;&amp; verifier.containsQuorum(electingFollowers)) {</span><br><span class="line">            electionFinished = <span class="keyword">true</span>;</span><br><span class="line">            electingFollowers.notifyAll();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> cur = start;</span><br><span class="line">            <span class="keyword">long</span> end = start + self.getInitLimit() * self.getTickTime();</span><br><span class="line">            <span class="keyword">while</span> (!electionFinished &amp;&amp; cur &lt; end) {</span><br><span class="line">                electingFollowers.wait(end - cur);</span><br><span class="line">                cur = System.currentTimeMillis();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!electionFinished) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">"Timeout while waiting for epoch to be acked by quorum"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leader.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAck</span><span class="params">(<span class="keyword">long</span> sid, <span class="keyword">long</span> zxid, SocketAddress followerAddr)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">        LOG.trace(<span class="string">"Ack zxid: 0x{}"</span>, Long.toHexString(zxid));</span><br><span class="line">        <span class="keyword">for</span> (Proposal p : outstandingProposals.values()) {</span><br><span class="line">            <span class="keyword">long</span> packetZxid = p.packet.getZxid();</span><br><span class="line">            LOG.trace(<span class="string">"outstanding proposal: 0x{}"</span>,</span><br><span class="line">                      Long.toHexString(packetZxid));</span><br><span class="line">        }</span><br><span class="line">        LOG.trace(<span class="string">"outstanding proposals all"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有处理中的事务</span></span><br><span class="line">    <span class="keyword">if</span> (outstandingProposals.size() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"outstanding is 0"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断当前zxid是否已经被commit</span></span><br><span class="line">    <span class="keyword">if</span> (lastCommitted &gt;= zxid) {</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">            LOG.debug(<span class="string">"proposal has already been committed, pzxid: 0x{} zxid: 0x{}"</span>,</span><br><span class="line">                      Long.toHexString(lastCommitted), Long.toHexString(zxid));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// The proposal has already been committed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Proposal p = outstandingProposals.get(zxid);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) {</span><br><span class="line">        LOG.warn(<span class="string">"Trying to commit future proposal: zxid 0x{} from {}"</span>,</span><br><span class="line">                 Long.toHexString(zxid), followerAddr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录peer proposal ack</span></span><br><span class="line">    p.ackSet.add(sid);</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">        LOG.debug(<span class="string">"Count for zxid: 0x{} is {}"</span>,</span><br><span class="line">                  Long.toHexString(zxid), p.ackSet.size());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 是否满足大多数节点ACK</span></span><br><span class="line">    <span class="keyword">if</span> (self.getQuorumVerifier().containsQuorum(p.ackSet)) {</span><br><span class="line">        <span class="keyword">if</span> (zxid != lastCommitted + <span class="number">1</span>) {</span><br><span class="line">            LOG.warn(<span class="string">"Commiting zxid 0x{} from {} not first!"</span>,</span><br><span class="line">                     Long.toHexString(zxid), followerAddr);</span><br><span class="line">            LOG.warn(<span class="string">"First is 0x{}"</span>, Long.toHexString(lastCommitted + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        outstandingProposals.remove(zxid);</span><br><span class="line">        <span class="keyword">if</span> (p.request != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 保存已经完成投票被commit的proposal</span></span><br><span class="line">            toBeApplied.add(p);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// We don't commit the new leader proposal</span></span><br><span class="line">        <span class="keyword">if</span> ((zxid &amp; <span class="number">0xffffffffL</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.request == <span class="keyword">null</span>) {</span><br><span class="line">                LOG.warn(<span class="string">"Going to commmit null request for proposal: {}"</span>, p);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 发送给所有follower commit消息</span></span><br><span class="line">            commit(zxid);</span><br><span class="line">            <span class="comment">// 同步给所有observer</span></span><br><span class="line">            inform(p);</span><br><span class="line">            <span class="comment">// commit proposal</span></span><br><span class="line">            zk.commitProcessor.commit(p.request);</span><br><span class="line">            <span class="keyword">if</span> (pendingSyncs.containsKey(zxid)) {</span><br><span class="line">                <span class="keyword">for</span> (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {</span><br><span class="line">                    sendSync(r);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// NEWLEADER消息</span></span><br><span class="line">            lastCommitted = zxid;</span><br><span class="line">            LOG.info(<span class="string">"Have quorum of supporters; starting up and setting last processed zxid: 0x{}"</span>,</span><br><span class="line">                     Long.toHexString(zk.getZxid()));</span><br><span class="line">            <span class="comment">// 启动leader zk服务</span></span><br><span class="line">            zk.startup();</span><br><span class="line">            zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，leader侧在与follower建立连接后，首先会读取follower发送过来的FOLLOWERINFO消息，然后回复给follower一条LEADERINFO消息，等待follower响应ACKPOCH其中包含peerLastZxid。所有LeaderHandler都会阻塞等待ACKPOCH，直到集群中大多数follower都响应ACKPOCH后就开始初始数据同步。</p><p>接下来在开始同步数据之前，首先需要获取commit日志的读锁，读取完成后释放，数据同步分为三种情况：</p><ol><li>如果peerLastZxid大于leader的最小zxid并且小于最大zxid，那么就发送一条TRUNC消息通知follower在leader最小zxid处截断防止follower中有leader没有的事务日志，然后再发送一条DIFF消息通知follower开始合并，之后开始从最小zxid到最大zxid发送PROPOSAL消息，每条PROPOSAL伴随一条COMMIT消息。</li><li>如果peerLastZxid大于leader的最大zxid，那么就发送一条TRUNC消息通知follower在leader最大zxid处截断。</li><li>其他情况直接发送一条SNAP消息通知follower接收快照，然后leader序列化db数据发送到follower。</li></ol><p>在数据同步消息的最后，leader会发送一条NEWLEADER消息，当收到follower响应NEWLEADER的ACK消息，表明当前节点数据同步已经完成了。此时如果大多数节点都响应了这条消息，leader会启动自身服务开始接收客户端请求，并且发送给follower一条UPTODATE消息通知follwer数据已经是最新的可以开始响应客户端。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>初始化数据同步过程：</p><ol><li>follower发起与leader建立socket通信。</li><li>follower向leader发送FOLLOWERINFO消息，包含节点的epoch和协议版本消息，向leader发起注册。</li><li>leader收到FOLLOWERINFO消息后，响应一个LEADERINFO消息，等待满足大多数follwer ACKPOCH。</li><li>follower收到leader 发送过来的LEADERINFO消息后，响应ACKPOCH其中包含peerLastZxid。</li><li>当满足大多数follwer ACKPOCH，leader开始向所有已经ACKPOCH的follower同步初始化数据。<ul><li>如果peerLastZxid大于leader的最小zxid并且小于最大zxid，那么就发送一条TRUNC消息通知follower在leader最小zxid处截断防止follower中有leader没有的事务日志，然后再发送一条DIFF消息通知follower开始合并，之后开始从最小zxid到最大zxid发送PROPOSAL消息，每条PROPOSAL伴随一条COMMIT消息。</li><li>如果peerLastZxid大于leader的最大zxid，那么就发送一条TRUNC消息通知follower在leader最大zxid处截断。</li><li>其他情况直接发送一条SNAP消息通知follower接收快照，然后leader序列化db数据发送到follower。</li></ul></li><li>在数据同步消息的最后，leader会发送一条NEWLEADER消息。</li><li>follower收到leader 发送的NEWLEADER消息，响应一条ACK消息。</li><li>当满足大多数节点响应响应了ACK消息，leader会启动自身服务开始接收客户端请求，并且发送给follower一条UPTODATE消息通知follwer数据已经是最新的可以开始响应客户端。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在leader选举完成后，集群中的所有节点都确定好自己的角色，此时节点间数据有可能并未达到一致，接下来follower节点将从leader同步数据完成初始化。&lt;/p&gt;
&lt;h1 id=&quot;建立网络通信&quot;&gt;&lt;a href=&quot;#建立网络通信&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】选举期间网络通信</title>
    <link href="https://haifuns.com/2022/02/20/zookeeper-03/"/>
    <id>https://haifuns.com/2022/02/20/zookeeper-03/</id>
    <published>2022-02-20T09:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们分析了leader选举过程，但是对于期间节点间的连接是何时建立的、消息如何交换并不了解，本篇中我们将对leader选举过程中集群节点间的网络通信细节进行分析。</p><h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>节点间的网络连接建立分为主动建立和被动建立两个部分。</p><h2 id="主动建立"><a href="#主动建立" class="headerlink" title="主动建立"></a>主动建立</h2><p>在leader选举过程中，发送给自己投票的通知后，会循环交换通知直到选举出leader，过程中会收取消息，如果拉取不到消息并且还是通知没有发送出去就跟所有其他节点建立连接，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FastLeaderElection.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            logicalclock++;</span><br><span class="line">            <span class="comment">// 更新提案</span></span><br><span class="line">            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</span><br><span class="line">                 <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</span><br><span class="line">        <span class="comment">// 向所有其他节点发送提案通知</span></span><br><span class="line">        sendNotifications();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 循环交换通知直到投票出leader</span></span><br><span class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop)) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Remove next notification from queue, times out after 2 times</span></span><br><span class="line"><span class="comment">             * the termination time</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 拉取其他节点发送来的消息</span></span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                                            TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment">             * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 如果所有通知已经发出去了, 但是没有回复就重新通知</span></span><br><span class="line">                <span class="keyword">if</span> (manager.haveDelivered()) {</span><br><span class="line">                    sendNotifications();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 主动与其他节点建立连接</span></span><br><span class="line">                    manager.connectAll();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumCnxManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectAll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> sid;</span><br><span class="line">    <span class="keyword">for</span> (Enumeration&lt;Long&gt; en = queueSendMap.keys();</span><br><span class="line">            en.hasMoreElements();) {</span><br><span class="line">        sid = en.nextElement();</span><br><span class="line">        connectOne(sid);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectOne</span><span class="params">(<span class="keyword">long</span> sid)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (senderWorkerMap.get(sid) == <span class="keyword">null</span>) {</span><br><span class="line">        InetSocketAddress electionAddr;</span><br><span class="line">        <span class="keyword">if</span> (self.quorumPeers.containsKey(sid)) {</span><br><span class="line">            electionAddr = self.quorumPeers.get(sid).electionAddr;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            LOG.warn(<span class="string">"Invalid server id: "</span> + sid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                LOG.debug(<span class="string">"Opening channel to server "</span> + sid);</span><br><span class="line">            }</span><br><span class="line">            Socket sock = <span class="keyword">new</span> Socket();</span><br><span class="line">            setSockOpts(sock);</span><br><span class="line">            <span class="comment">// 建立socket连接</span></span><br><span class="line">            sock.connect(self.getView().get(sid).electionAddr, cnxTO);</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                LOG.debug(<span class="string">"Connected to server "</span> + sid);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 初始化连接</span></span><br><span class="line">            initiateConnection(sock, sid);</span><br><span class="line">        } <span class="keyword">catch</span> (UnresolvedAddressException e) {</span><br><span class="line">            <span class="comment">// Sun doesn't include the address that causes this</span></span><br><span class="line">            <span class="comment">// exception to be thrown, also UAE cannot be wrapped cleanly</span></span><br><span class="line">            <span class="comment">// so we log the exception in order to capture this critical</span></span><br><span class="line">            <span class="comment">// detail.</span></span><br><span class="line">            LOG.warn(<span class="string">"Cannot open channel to "</span> + sid</span><br><span class="line">                     + <span class="string">" at election address "</span> + electionAddr, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.warn(<span class="string">"Cannot open channel to "</span> + sid</span><br><span class="line">                     + <span class="string">" at election address "</span> + electionAddr,</span><br><span class="line">                     e);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.debug(<span class="string">"There is a connection already for server "</span> + sid);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initiateConnection</span><span class="params">(Socket sock, Long sid)</span> </span>{</span><br><span class="line">    DataOutputStream dout = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Sending id and challenge</span></span><br><span class="line">        <span class="comment">// 连接建立后发送当前节点serverId</span></span><br><span class="line">        dout = <span class="keyword">new</span> DataOutputStream(sock.getOutputStream());</span><br><span class="line">        dout.writeLong(self.getId());</span><br><span class="line">        dout.flush();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Ignoring exception reading or writing challenge: "</span>, e);</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对方的serverId比当前节点serverId大就关闭连接</span></span><br><span class="line">    <span class="comment">// 只能serverId大的节点向serverId小的节点发起连接建立</span></span><br><span class="line">    <span class="comment">// If lost the challenge, then drop the new connection</span></span><br><span class="line">    <span class="keyword">if</span> (sid &gt; self.getId()) {</span><br><span class="line">        LOG.info(<span class="string">"Have smaller server identifier, so dropping the "</span> +</span><br><span class="line">                 <span class="string">"connection: ("</span> + sid + <span class="string">", "</span> + self.getId() + <span class="string">")"</span>);</span><br><span class="line">        closeSocket(sock);</span><br><span class="line">        <span class="comment">// Otherwise proceed with the connection</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 启动消息发送线程和接收线程</span></span><br><span class="line">        SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</span><br><span class="line">        RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, sid, sw);</span><br><span class="line">        sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">        SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vsw != <span class="keyword">null</span>)</span><br><span class="line">            vsw.finish();</span><br><span class="line"></span><br><span class="line">        senderWorkerMap.put(sid, sw);</span><br><span class="line">        <span class="keyword">if</span> (!queueSendMap.containsKey(sid)) {</span><br><span class="line">            queueSendMap.put(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">                                 SEND_CAPACITY));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sw.start();</span><br><span class="line">        rw.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从如上代码可以看到，首次主动建立连接时，当前节点会循环与所有其他节点尝试建立socket连接，连接建立之后立即向对方发送自己的serverId，如果对方serverId比自己的serverId大就关闭连接，否则连接建立成功，启动消息发送线程和消息接收线程。</p><h2 id="被动建立"><a href="#被动建立" class="headerlink" title="被动建立"></a>被动建立</h2><p>主动发起连接建立只有在当前serverId比对方节点serverId时才会建立，否则需要等待对方发起连接建立。</p><p>当前节点socket连接监听在ZKServer启动流程过程中就已经准备好了，在初始化leader选举算法时也初始化了集群网络通信组件，开始监听socket连接。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>{</span><br><span class="line">    Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 集群间通信组件</span></span><br><span class="line">        qcm = <span class="keyword">new</span> QuorumCnxManager(<span class="keyword">this</span>);</span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 监听socket连接</span></span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">// 默认选举算法</span></span><br><span class="line">            le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumCnxManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sleeps on accept().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> numRetries = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                ss = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">                ss.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">int</span> port = self.quorumPeers.get(self.getId()).electionAddr</span><br><span class="line">                           .getPort();</span><br><span class="line">                InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">                LOG.info(<span class="string">"My election bind port: "</span> + addr.toString());</span><br><span class="line">                setName(self.quorumPeers.get(self.getId()).electionAddr</span><br><span class="line">                        .toString());</span><br><span class="line">                ss.bind(addr);</span><br><span class="line">                <span class="keyword">while</span> (!shutdown) {</span><br><span class="line">                    Socket client = ss.accept();</span><br><span class="line">                    setSockOpts(client);</span><br><span class="line">                    LOG.info(<span class="string">"Received connection request "</span></span><br><span class="line">                             + client.getRemoteSocketAddress());</span><br><span class="line">                    <span class="comment">// 收到其他节点连接请求</span></span><br><span class="line">                    receiveConnection(client);</span><br><span class="line">                    numRetries = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                LOG.error(<span class="string">"Exception while listening"</span>, e);</span><br><span class="line">                numRetries++;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ss.close();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (IOException ie) {</span><br><span class="line">                    LOG.error(<span class="string">"Error closing server socket"</span>, ie);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException ie) {</span><br><span class="line">                    LOG.error(<span class="string">"Interrupted while sleeping. "</span> +</span><br><span class="line">                              <span class="string">"Ignoring exception"</span>, ie);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        LOG.info(<span class="string">"Leaving listener"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!shutdown) {</span><br><span class="line">            LOG.error(<span class="string">"As I'm leaving the listener thread, "</span></span><br><span class="line">                      + <span class="string">"I won't be able to participate in leader "</span></span><br><span class="line">                      + <span class="string">"election any longer: "</span></span><br><span class="line">                      + self.quorumPeers.get(self.getId()).electionAddr);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">receiveConnection</span><span class="params">(Socket sock)</span> </span>{</span><br><span class="line">        Long sid = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// Read server id</span></span><br><span class="line">            DataInputStream din = <span class="keyword">new</span> DataInputStream(sock.getInputStream());</span><br><span class="line">            <span class="comment">// 连接建立后client会发送自己的serverId</span></span><br><span class="line">            sid = din.readLong();</span><br><span class="line">            <span class="keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Choose identifier at random. We need a value to identify</span></span><br><span class="line"><span class="comment">                 * the connection.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                </span><br><span class="line">                sid = observerCounter--;</span><br><span class="line">                LOG.info(<span class="string">"Setting arbitrary identifier to observer: "</span> + sid);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            closeSocket(sock);</span><br><span class="line">            LOG.warn(<span class="string">"Exception reading or writing challenge: "</span> + e.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//If wins the challenge, then close the new connection.</span></span><br><span class="line">        <span class="comment">// 只允许serverId更大的节点发起建立连接</span></span><br><span class="line">        <span class="keyword">if</span> (sid &lt; self.getId()) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This replica might still believe that the connection to sid is</span></span><br><span class="line"><span class="comment">             * up, so we have to shut down the workers before trying to open a</span></span><br><span class="line"><span class="comment">             * new connection.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SendWorker sw = senderWorkerMap.get(sid);</span><br><span class="line">            <span class="keyword">if</span> (sw != <span class="keyword">null</span>) {</span><br><span class="line">                sw.finish();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Now we start a new connection</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            LOG.debug(<span class="string">"Create new connection to server: "</span> + sid);</span><br><span class="line">            closeSocket(sock);</span><br><span class="line">            connectOne(sid);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Otherwise start worker threads to receive data.</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</span><br><span class="line">            RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, sid, sw);</span><br><span class="line">            sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">            SendWorker vsw = senderWorkerMap.get(sid);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vsw != <span class="keyword">null</span>)</span><br><span class="line">                vsw.finish();</span><br><span class="line">            </span><br><span class="line">            senderWorkerMap.put(sid, sw);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!queueSendMap.containsKey(sid)) {</span><br><span class="line">                queueSendMap.put(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">                        SEND_CAPACITY));</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            sw.start();</span><br><span class="line">            rw.start();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>被动建立连接也是对方节点主动建立的过程，当收到连接建立请求，首先会接受对方发过来的serverId，然后进行比较，确保只有serverId大的一方才能主动建立请求。</p><h1 id="消息交换"><a href="#消息交换" class="headerlink" title="消息交换"></a>消息交换</h1><p>每个连接都对应着一个消息发送工作线程SendWorker和一个消息接收工作线程RecvWorker，另外每个SendWorker对应着一个消息发送队列，所有的RecvWorker对应着同一个消息接收队列。</p><p>接下来分别分析一下消息发送和一个消息接收过程。</p><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastLeaderElection</span> <span class="keyword">implements</span> <span class="title">Election</span> </span>{</span><br><span class="line"></span><br><span class="line">    LinkedBlockingQueue&lt;ToSend&gt; sendqueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (QuorumServer server : self.getVotingView().values()) {</span><br><span class="line">            <span class="keyword">long</span> sid = server.id;</span><br><span class="line"></span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                                       proposedLeader,<span class="comment">// serverId</span></span><br><span class="line">                                       proposedZxid, <span class="comment">// 最大zxid</span></span><br><span class="line">                                       logicalclock, <span class="comment">// 计数器</span></span><br><span class="line">                                       QuorumPeer.ServerState.LOOKING, <span class="comment">// 选举中</span></span><br><span class="line">                                       sid, <span class="comment">// 要发送到的节点serverId</span></span><br><span class="line">                                       proposedEpoch); <span class="comment">// 节点epoch值</span></span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                LOG.debug(<span class="string">"Sending Notification: "</span> + proposedLeader + <span class="string">" (n.leader), 0x"</span>  +</span><br><span class="line">                          Long.toHexString(proposedZxid) + <span class="string">" (n.zxid), 0x"</span> + Long.toHexString(logicalclock)  +</span><br><span class="line">                          <span class="string">" (n.round), "</span> + sid + <span class="string">" (recipient), "</span> + self.getId() +</span><br><span class="line">                          <span class="string">" (myid), 0x"</span> + Long.toHexString(proposedEpoch) + <span class="string">" (n.peerEpoch)"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 添加到消息发送队列</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkerSender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line">        QuorumCnxManager manager;</span><br><span class="line"></span><br><span class="line">        WorkerSender(QuorumCnxManager manager) {</span><br><span class="line">            <span class="keyword">this</span>.stop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.manager = manager;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (!stop) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ToSend m = sendqueue.poll(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    process(m);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            LOG.info(<span class="string">"WorkerSender is down"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called by run() once there is a new message to send.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> m     message to send</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ToSend m)</span> </span>{</span><br><span class="line">            <span class="keyword">byte</span> requestBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">36</span>];</span><br><span class="line">            ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Building notification packet to send</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            requestBuffer.clear();</span><br><span class="line">            requestBuffer.putInt(m.state.ordinal());</span><br><span class="line">            requestBuffer.putLong(m.leader);</span><br><span class="line">            requestBuffer.putLong(m.zxid);</span><br><span class="line">            requestBuffer.putLong(m.electionEpoch);</span><br><span class="line">            requestBuffer.putLong(m.peerEpoch);</span><br><span class="line"></span><br><span class="line">            manager.toSend(m.sid, requestBuffer);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumCnxManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSend</span><span class="params">(Long sid, ByteBuffer b)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If sending message to myself, then simply enqueue it (loopback).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (self.getId() == sid) {</span><br><span class="line">        b.position(<span class="number">0</span>);</span><br><span class="line">        addToRecvQueue(<span class="keyword">new</span> Message(b.duplicate(), sid));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Otherwise send to the corresponding thread to send.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Start a new connection if doesn't have one already.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 把消息放到serverId对应的发送队列里</span></span><br><span class="line">        <span class="keyword">if</span> (!queueSendMap.containsKey(sid)) {</span><br><span class="line">            ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">                SEND_CAPACITY);</span><br><span class="line">            queueSendMap.put(sid, bq);</span><br><span class="line">            addToSendQueue(bq, b);</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">            <span class="keyword">if</span> (bq != <span class="keyword">null</span>) {</span><br><span class="line">                addToSendQueue(bq, b);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                LOG.error(<span class="string">"No queue for server "</span> + sid);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        connectOne(sid);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToSendQueue</span><span class="params">(ArrayBlockingQueue&lt;ByteBuffer&gt; queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ByteBuffer buffer)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (queue.remainingCapacity() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            queue.remove();</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchElementException ne) {</span><br><span class="line">            <span class="comment">// element could be removed by poll()</span></span><br><span class="line">            LOG.debug(<span class="string">"Trying to remove from an empty "</span> +</span><br><span class="line">                      <span class="string">"Queue. Ignoring exception "</span> + ne);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        queue.add(buffer);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalStateException ie) {</span><br><span class="line">        <span class="comment">// This should never happen</span></span><br><span class="line">        LOG.error(<span class="string">"Unable to insert an element in the queue "</span> + ie);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ByteBuffer b)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] msgBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[b.capacity()];</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            b.position(<span class="number">0</span>);</span><br><span class="line">            b.get(msgBytes);</span><br><span class="line">        } <span class="keyword">catch</span> (BufferUnderflowException be) {</span><br><span class="line">            LOG.error(<span class="string">"BufferUnderflowException "</span>, be);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        dout.writeInt(b.capacity());</span><br><span class="line">        dout.write(b.array());</span><br><span class="line">        dout.flush();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        threadCnt.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * If there is nothing in the queue to send, then we</span></span><br><span class="line"><span class="comment">             * send the lastMessage to ensure that the last message</span></span><br><span class="line"><span class="comment">             * was received by the peer. The message could be dropped</span></span><br><span class="line"><span class="comment">             * in case self or the peer shutdown their connection</span></span><br><span class="line"><span class="comment">             * (and exit the thread) prior to reading/processing</span></span><br><span class="line"><span class="comment">             * the last message. Duplicate messages are handled correctly</span></span><br><span class="line"><span class="comment">             * by the peer.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * If the send queue is non-empty, then we have a recent</span></span><br><span class="line"><span class="comment">             * message than that stored in lastMessage. To avoid sending</span></span><br><span class="line"><span class="comment">             * stale message, we should send the message in the send queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">            <span class="keyword">if</span> (bq == <span class="keyword">null</span> || isSendQueueEmpty(bq)) {</span><br><span class="line">                ByteBuffer b = lastMessageSent.get(sid);</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                    LOG.debug(<span class="string">"Attempting to send lastMessage to sid="</span> + sid);</span><br><span class="line">                    send(b);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            LOG.error(<span class="string">"Failed to send last message. Shutting down thread."</span>, e);</span><br><span class="line">            <span class="keyword">this</span>.finish();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">                ByteBuffer b = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap</span><br><span class="line">                                                        .get(sid);</span><br><span class="line">                    <span class="keyword">if</span> (bq != <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="comment">// 从发送队列里取一条消息</span></span><br><span class="line">                        b = pollSendQueue(bq, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        LOG.error(<span class="string">"No queue of incoming messages for "</span> +</span><br><span class="line">                                  <span class="string">"server "</span> + sid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (b != <span class="keyword">null</span>) {</span><br><span class="line">                        <span class="comment">// 记录最后一条发送的消息</span></span><br><span class="line">                        lastMessageSent.put(sid, b);</span><br><span class="line">                        <span class="comment">// 发送消息</span></span><br><span class="line">                        send(b);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    LOG.warn(<span class="string">"Interrupted while waiting for message on queue"</span>,</span><br><span class="line">                             e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Exception when using channel: for id "</span> + sid + <span class="string">" my id = "</span> +</span><br><span class="line">                     self.getId() + <span class="string">" error = "</span> + e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.finish();</span><br><span class="line">        LOG.warn(<span class="string">"Send worker leaving thread"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastLeaderElection</span> <span class="keyword">implements</span> <span class="title">Election</span> </span>{</span><br><span class="line"></span><br><span class="line">    LinkedBlockingQueue&lt;Notification&gt; recvqueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环交换通知直到投票出leader</span></span><br><span class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop)) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拉取其他节点发送来的消息</span></span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                                            TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkerReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">            Message response;</span><br><span class="line">            <span class="keyword">while</span> (!stop) {</span><br><span class="line">                <span class="comment">// Sleeps on receive</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 拉取消息</span></span><br><span class="line">                    response = manager.pollRecvQueue(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (response == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * If it is from an observer, respond right away.</span></span><br><span class="line"><span class="comment">                     * Note that the following predicate assumes that</span></span><br><span class="line"><span class="comment">                     * if a server is not a follower, then it must be</span></span><br><span class="line"><span class="comment">                     * an observer. If we ever have any other type of</span></span><br><span class="line"><span class="comment">                     * learner in the future, we'll have to change the</span></span><br><span class="line"><span class="comment">                     * way we check for observers.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (!self.getVotingView().containsKey(response.sid)) {</span><br><span class="line">                        Vote current = self.getCurrentVote();</span><br><span class="line">                        ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                                                   current.getId(),</span><br><span class="line">                                                   current.getZxid(),</span><br><span class="line">                                                   logicalclock,</span><br><span class="line">                                                   self.getPeerState(),</span><br><span class="line">                                                   response.sid,</span><br><span class="line">                                                   current.getPeerEpoch());</span><br><span class="line"></span><br><span class="line">                        sendqueue.offer(notmsg);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * If this server is looking, then send proposed leader</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {</span><br><span class="line">                            recvqueue.offer(n);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * Send a notification back if the peer that sent this</span></span><br><span class="line"><span class="comment">                             * message is also looking and its logical clock is</span></span><br><span class="line"><span class="comment">                             * lagging behind.</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">if</span> ((ackstate == QuorumPeer.ServerState.LOOKING)</span><br><span class="line">                                    &amp;&amp; (n.electionEpoch &lt; logicalclock)) {</span><br><span class="line">                                Vote v = getVote();</span><br><span class="line">                                ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                                                           v.getId(),</span><br><span class="line">                                                           v.getZxid(),</span><br><span class="line">                                                           logicalclock,</span><br><span class="line">                                                           self.getPeerState(),</span><br><span class="line">                                                           response.sid,</span><br><span class="line">                                                           v.getPeerEpoch());</span><br><span class="line">                                sendqueue.offer(notmsg);</span><br><span class="line">                            }</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * If this server is not looking, but the one that sent the ack</span></span><br><span class="line"><span class="comment">                             * is looking, then send back what it believes to be the leader.</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            Vote current = self.getCurrentVote();</span><br><span class="line">                            <span class="keyword">if</span> (ackstate == QuorumPeer.ServerState.LOOKING) {</span><br><span class="line">                                <span class="comment">// ...</span></span><br><span class="line">                                ToSend notmsg = <span class="keyword">new</span> ToSend(</span><br><span class="line">                                    ToSend.mType.notification,</span><br><span class="line">                                    current.getId(),</span><br><span class="line">                                    current.getZxid(),</span><br><span class="line">                                    logicalclock,</span><br><span class="line">                                    self.getPeerState(),</span><br><span class="line">                                    response.sid,</span><br><span class="line">                                    current.getPeerEpoch());</span><br><span class="line">                                sendqueue.offer(notmsg);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted Exception while waiting for new message"</span> +</span><br><span class="line">                                       e.toString());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            LOG.info(<span class="string">"WorkerReceiver is down"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumCnxManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">pollRecvQueue</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">return</span> recvQueue.poll(timeout, unit);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecvWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        threadCnt.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Reads the first int to determine the length of the</span></span><br><span class="line"><span class="comment">                 * message</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> length = din.readInt();</span><br><span class="line">                <span class="keyword">if</span> (length &lt;= <span class="number">0</span> || length &gt; PACKETMAXSIZE) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                        <span class="string">"Received packet with invalid packet: "</span></span><br><span class="line">                        + length);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Allocates a new ByteBuffer to receive the message</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">byte</span>[] msgArray = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">                din.readFully(msgArray, <span class="number">0</span>, length);</span><br><span class="line">                ByteBuffer message = ByteBuffer.wrap(msgArray);</span><br><span class="line">                addToRecvQueue(<span class="keyword">new</span> Message(message.duplicate(), sid));</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Connection broken for id "</span> + sid + <span class="string">", my id = "</span> +</span><br><span class="line">                     self.getId() + <span class="string">", error = "</span> , e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            LOG.warn(<span class="string">"Interrupting SendWorker"</span>);</span><br><span class="line">            sw.finish();</span><br><span class="line">            <span class="keyword">if</span> (sock != <span class="keyword">null</span>) {</span><br><span class="line">                closeSocket(sock);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToRecvQueue</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (recvQLock) {</span><br><span class="line">        <span class="keyword">if</span> (recvQueue.remainingCapacity() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                recvQueue.remove();</span><br><span class="line">            } <span class="keyword">catch</span> (NoSuchElementException ne) {</span><br><span class="line">                <span class="comment">// element could be removed by poll()</span></span><br><span class="line">                LOG.debug(<span class="string">"Trying to remove from an empty "</span> +</span><br><span class="line">                          <span class="string">"recvQueue. Ignoring exception "</span> + ne);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 添加到消息接收队列</span></span><br><span class="line">            recvQueue.add(msg);</span><br><span class="line">        } <span class="keyword">catch</span> (IllegalStateException ie) {</span><br><span class="line">            <span class="comment">// This should never happen</span></span><br><span class="line">            LOG.error(<span class="string">"Unable to insert element in the recvQueue "</span> + ie);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在ZKServer启动初始化leader选举算法的同时也会初始化好集群间网络通信管理器，同时启动监听客户端连接请求。在选举过程中会主动与比自己serverId小的其他节点建立连接，连接建立后立即发送自己的serverId用于对方校验，当校验通过时会为这个连接初始化一个消息发送工作线程SendWorker以及一个消息接收工作线程RecvWorker。每个SendWorker对应一个消息发送队列，所有的RecvWorker对应同一个消息接收队列。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇我们分析了leader选举过程，但是对于期间节点间的连接是何时建立的、消息如何交换并不了解，本篇中我们将对leader选举过程中集群节点间的网络通信细节进行分析。&lt;/p&gt;
&lt;h1 id=&quot;连接建立&quot;&gt;&lt;a href=&quot;#连接建立&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】Leader选举</title>
    <link href="https://haifuns.com/2022/02/17/zookeeper-02/"/>
    <id>https://haifuns.com/2022/02/17/zookeeper-02/</id>
    <published>2022-02-17T04:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>在前篇ZKServer启动流程分析的最后，QuorumPeer线程被启动，下面我们对线程执行过程中leader选举流程进行详细分析。</p><h1 id="QuorumPeer-run"><a href="#QuorumPeer-run" class="headerlink" title="QuorumPeer#run"></a>QuorumPeer#run</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    setName(<span class="string">"QuorumPeer"</span> + <span class="string">"[myid="</span> + getId() + <span class="string">"]"</span> +</span><br><span class="line">            cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">    LOG.debug(<span class="string">"Starting quorum peer"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 注册jmx bean</span></span><br><span class="line">        jmxQuorumBean = <span class="keyword">new</span> QuorumBean(<span class="keyword">this</span>);</span><br><span class="line">        MBeanRegistry.getInstance().register(jmxQuorumBean, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.warn(<span class="string">"Failed to register with JMX"</span>, e);</span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 主要逻辑</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) {</span><br><span class="line">            <span class="comment">// 根据当前节点的状态执行相应的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) {</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                <span class="comment">// 选举中状态</span></span><br><span class="line">                LOG.info(<span class="string">"LOOKING"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"readonlymode.enabled"</span>)) {</span><br><span class="line">                    LOG.info(<span class="string">"Attempting to start ReadOnlyZooKeeperServer"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create read-only server but don't start it immediately</span></span><br><span class="line">                    <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk = <span class="keyword">new</span> ReadOnlyZooKeeperServer(</span><br><span class="line">                        logFactory, <span class="keyword">this</span>,</span><br><span class="line">                        <span class="keyword">new</span> ZooKeeperServer.BasicDataTreeBuilder(),</span><br><span class="line">                        <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                    <span class="comment">// period before we decide we're partitioned.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                    <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                    <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                    Thread roZkMgr = <span class="keyword">new</span> Thread() {</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) {</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                }</span><br><span class="line">                            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                LOG.info(<span class="string">"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started"</span>);</span><br><span class="line">                            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                                LOG.error(<span class="string">"FAILED to start ReadOnlyZooKeeperServer"</span>, e);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    };</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        <span class="comment">// 发起leader选举</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                        <span class="comment">// to come out of waiting.</span></span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        LOG.warn(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到在服务启动后，当节点是LOOKING即选举中状态时，会使用之前初始化好的leader选举算法（FastLeaderElection）发起一轮leader选举。</p><h1 id="FastLeaderElection-lookForLeader"><a href="#FastLeaderElection-lookForLeader" class="headerlink" title="FastLeaderElection#lookForLeader"></a>FastLeaderElection#lookForLeader</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FastLeaderElection.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起一轮leader选举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Starts a new round of leader election. Whenever our QuorumPeer</span></span><br><span class="line"><span class="comment"> * changes its state to LOOKING, this method is invoked, and it</span></span><br><span class="line"><span class="comment"> * sends notifications to all other peers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        self.jmxLeaderElectionBean = <span class="keyword">new</span> LeaderElectionBean();</span><br><span class="line">        MBeanRegistry.getInstance().register(</span><br><span class="line">            self.jmxLeaderElectionBean, self.jmxLocalPeerBean);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        LOG.warn(<span class="string">"Failed to register with JMX"</span>, e);</span><br><span class="line">        self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (self.start_fle == <span class="number">0</span>) {</span><br><span class="line">        self.start_fle = System.currentTimeMillis();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 投票消息列表</span></span><br><span class="line">        HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> notTimeout = finalizeWait;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            logicalclock++;</span><br><span class="line">            <span class="comment">// 更新提案</span></span><br><span class="line">            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</span><br><span class="line">                 <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</span><br><span class="line">        <span class="comment">// 向所有其他节点发送提案通知</span></span><br><span class="line">        sendNotifications();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Loop in which we exchange notifications until we find a leader</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 循环交换通知直到投票出leader</span></span><br><span class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                (!stop)) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Remove next notification from queue, times out after 2 times</span></span><br><span class="line"><span class="comment">             * the termination time</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 拉取其他节点发送来的消息</span></span><br><span class="line">            Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                                            TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Sends more notifications if haven't received enough.</span></span><br><span class="line"><span class="comment">             * Otherwise processes new notification.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 如果所有通知已经发出去了, 但是没有回复就重新通知</span></span><br><span class="line">                <span class="keyword">if</span> (manager.haveDelivered()) {</span><br><span class="line">                    sendNotifications();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    manager.connectAll();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Exponential backoff</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> tmpTimeOut = notTimeout * <span class="number">2</span>;</span><br><span class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval ?</span><br><span class="line">                              tmpTimeOut : maxNotificationInterval);</span><br><span class="line">                LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (self.getVotingView().containsKey(n.sid)) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Only proceed if the vote comes from a replica in the</span></span><br><span class="line"><span class="comment">                 * voting view.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">switch</span> (n.state) {</span><br><span class="line">                <span class="comment">// 其他节点发过来的选举中状态消息</span></span><br><span class="line">                <span class="keyword">case</span> LOOKING:</span><br><span class="line">                    <span class="comment">// If notification &gt; current, replace and send messages out</span></span><br><span class="line">                    <span class="comment">// 如果新消息中的时间戳更大则已经开始新的一轮选举</span></span><br><span class="line">                    <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock) {</span><br><span class="line">                        <span class="comment">// 接受更大的时间戳</span></span><br><span class="line">                        logicalclock = n.electionEpoch;</span><br><span class="line">                        <span class="comment">// 清空上一轮的投票消息</span></span><br><span class="line">                        recvset.clear();</span><br><span class="line">                        <span class="comment">// 检查是否接受这条提案, 以下三种情况接受:</span></span><br><span class="line">                        <span class="comment">// 1. new epoch更大</span></span><br><span class="line">                        <span class="comment">// 2. epoch相等, new zxid更大</span></span><br><span class="line">                        <span class="comment">// 3. epoch相等, zxid相等, new serverId更大</span></span><br><span class="line">                        <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {</span><br><span class="line">                            <span class="comment">// 接受提案</span></span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            updateProposal(getInitId(),</span><br><span class="line">                                           getInitLastLoggedZxid(),</span><br><span class="line">                                           getPeerEpoch());</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 通知所有其他节点</span></span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock) {</span><br><span class="line">                        <span class="comment">// 如果消息中的时间戳更小, 说明消息已经过期了</span></span><br><span class="line">                        <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                            LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></span><br><span class="line">                                      + Long.toHexString(n.electionEpoch)</span><br><span class="line">                                      + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock));</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                                   proposedLeader, proposedZxid, proposedEpoch)) {</span><br><span class="line">                        updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) {</span><br><span class="line">                        LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</span><br><span class="line">                                  <span class="string">", proposed leader="</span> + n.leader +</span><br><span class="line">                                  <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</span><br><span class="line">                                  <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 保存所有投票消息</span></span><br><span class="line">                    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断是否满足过半节点投票</span></span><br><span class="line">                    <span class="keyword">if</span> (termPredicate(recvset,</span><br><span class="line">                                      <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                               logicalclock, proposedEpoch))) {</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Verify if there is any change in the proposed leader</span></span><br><span class="line">                        <span class="comment">// 检查其他消息leader提案是否有变化</span></span><br><span class="line">                        <span class="keyword">while</span> ((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                                   TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                                    proposedLeader, proposedZxid, proposedEpoch)) {</span><br><span class="line">                                recvqueue.put(n);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * This predicate is true once we don't read any new</span></span><br><span class="line"><span class="comment">                         * relevant message from the reception queue</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="comment">// 如果读不到其他消息了, 则选举已经完成</span></span><br><span class="line">                        <span class="keyword">if</span> (n == <span class="keyword">null</span>) {</span><br><span class="line">                            <span class="comment">// 设置当前节点leader状态</span></span><br><span class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                              ServerState.LEADING : learningState());</span><br><span class="line"></span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</span><br><span class="line">                                                    proposedZxid, proposedEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                    LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                <span class="keyword">case</span> LEADING:</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Consider all notifications from the same epoch</span></span><br><span class="line"><span class="comment">                     * together.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (n.electionEpoch == logicalclock) {</span><br><span class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                        <span class="keyword">if</span> (termPredicate(recvset, <span class="keyword">new</span> Vote(n.leader,</span><br><span class="line">                                                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                                &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) {</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                              ServerState.LEADING : learningState());</span><br><span class="line"></span><br><span class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            <span class="keyword">return</span> endVote;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Before joining an established ensemble, verify that</span></span><br><span class="line"><span class="comment">                     * a majority are following the same leader.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">// 如果集群中已经达成了共识, 在加入前需要验证leader满足大多数跟随</span></span><br><span class="line">                    outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid,</span><br><span class="line">                                                      n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                    <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.leader,</span><br><span class="line">                                      n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) {</span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                            logicalclock = n.electionEpoch;</span><br><span class="line">                            self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                              ServerState.LEADING : learningState());</span><br><span class="line">                        }</span><br><span class="line">                        Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                        leaveInstance(endVote);</span><br><span class="line">                        <span class="keyword">return</span> endVote;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</span><br><span class="line">                             + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                LOG.warn(<span class="string">"Ignoring notification from non-cluster member "</span> + n.sid);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (self.jmxLeaderElectionBean != <span class="keyword">null</span>) {</span><br><span class="line">                MBeanRegistry.getInstance().unregister(</span><br><span class="line">                    self.jmxLeaderElectionBean);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        self.jmxLeaderElectionBean = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码可以看到FastLeaderElection进行一轮leader选举的过程。如果当前节点可以参与选举，首先投自己一票(serverId, 最大zxid, 时间戳epoch)，然后通知所有其他节点。如果节点状态为LOOKING并且选举没有结束，则循环从接受消息的队列里获取消息，然后判断发送消息的节点状态：</p><p>如果发送消息的节点是LOOKING状态时，则选举依然在进行中，比较收到的投票时间戳与本地保存的时间戳：</p><ul><li>如果新的投票时间戳大，说明旧的选举轮次过期了，开始判断是否接受新的提案，当满足<code>(new epoch更大 || (epoch相等 &amp;&amp; new zxid更大) || (epoch相等 &amp;&amp; zxid相等 &amp;&amp; new serverId更大))</code>时，就接受新的提案，否则依然接受旧提案。重新接受提案之后再次通知所有其他节点。</li><li>如果新的投票时间戳小，则说明消息过期了，不作任何操作。</li><li>如果相等，说明是同一轮次选举，判断是否需要接受新的提案，如果接受依然需要通知其他所有节点。</li></ul><p>接下来保存所有投票消息，判断其他节点对当前节点的投票是否满足过半数，如果满足并且消息队列里的其他消息也不会导致当前接受其他节点的提案，则选举已经完成，更新当前节点的状态为LEADING。</p><p>如果发送消息的节点是FOLLOWING或者LEADING状态时，此时说明集群中已经达成了共识，在加入前需要验证leader是否满足大多数跟随，如果检查通过就接受已经存在的leader，根据leader serverId更新当前节点的状态为LEADING/FOWLLING。</p><p>至此，ZKServer启动后新一轮的选举已经完成了，接下来节点需要根据自己的状态(LEADING/FOWLLING/OBSERVING)执行后续的操作。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在新的ZK节点启动时，会发起一轮选举，如果可以参与竞选，把对自己的提案投票消息(serverId, 最大zxid, 时间戳epoch)发送给其他节点，并接受其他节点的投票消息。</p><ul><li>如果此时集群中已经有leader了，经过过半数节点投票检查后就直接作为follower加入。</li><li>如果集群中没有leader，那么满足<code>(new epoch更大 || (epoch相等 &amp;&amp; new zxid更大) || (epoch相等 &amp;&amp; zxid相等 &amp;&amp; new serverId更大))</code>条件的提案在满足过半数节点投票后即可竞选成功为leader。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前篇ZKServer启动流程分析的最后，QuorumPeer线程被启动，下面我们对线程执行过程中leader选举流程进行详细分析。&lt;/p&gt;
&lt;h1 id=&quot;QuorumPeer-run&quot;&gt;&lt;a href=&quot;#QuorumPeer-run&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【ZooKeeper源码】ZKServer启动流程</title>
    <link href="https://haifuns.com/2022/02/15/zookeeper-01/"/>
    <id>https://haifuns.com/2022/02/15/zookeeper-01/</id>
    <published>2022-02-15T14:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>从zkServer.sh启动脚本中我们可以看到zk启动入口类为QuorumPeerMain，接下来从其main方法入手开始分析zk启动流程。</p><h1 id="QuorumPeerMain-main"><a href="#QuorumPeerMain-main" class="headerlink" title="QuorumPeerMain#main"></a>QuorumPeerMain#main</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    QuorumPeerMain main = <span class="keyword">new</span> QuorumPeerMain();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        main.initializeAndRun(args);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ConfigException, IOException </span>{</span><br><span class="line">    <span class="comment">// 用来解析配置文件</span></span><br><span class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 如果只传了一个参数, 就认为是zoo.cfg文件地址</span></span><br><span class="line">        config.parse(args[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">    <span class="comment">// 启动后台线程，定期清理日志文件和快照文件</span></span><br><span class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">            .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">            .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.servers.size() &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 集群启动</span></span><br><span class="line">        runFromConfig(config);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.warn(<span class="string">"Either no config or no quorum defined in config, running "</span></span><br><span class="line">                 + <span class="string">" in standalone mode"</span>);</span><br><span class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">        <span class="comment">// 单机启动</span></span><br><span class="line">        ZooKeeperServerMain.main(args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，启动过程先对配置文件进行解析，然后启动后台线程定期清理日志和快照文件，接着判断是集群启动还是单机启动，这里我们直接分析集群启动过程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 注册jmx bean</span></span><br><span class="line">        ManagedUtil.registerLog4jMBeans();</span><br><span class="line">    } <span class="keyword">catch</span> (JMException e) {</span><br><span class="line">        LOG.warn(<span class="string">"Unable to register log4j JMX control"</span>, e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">"Starting quorum peer"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 网络连接工厂</span></span><br><span class="line">        ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">        cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                              config.getMaxClientCnxns());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// quorumPeer代表一个zk节点</span></span><br><span class="line">        quorumPeer = <span class="keyword">new</span> QuorumPeer();</span><br><span class="line">        quorumPeer.setClientPortAddress(config.getClientPortAddress());</span><br><span class="line">        <span class="comment">// 磁盘数据管理组件 FileTxnSnapLog</span></span><br><span class="line">        quorumPeer.setTxnFactory(<span class="keyword">new</span> FileTxnSnapLog(</span><br><span class="line">                                     <span class="keyword">new</span> File(config.getDataLogDir()),</span><br><span class="line">                                     <span class="keyword">new</span> File(config.getDataDir())));</span><br><span class="line">        quorumPeer.setQuorumPeers(config.getServers());</span><br><span class="line">        quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">        quorumPeer.setMyid(config.getServerId());</span><br><span class="line">        quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">        quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">        quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">        quorumPeer.setQuorumVerifier(config.getQuorumVerifier());</span><br><span class="line">        quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">        <span class="comment">// 内存数据库 ZKDatabase</span></span><br><span class="line">        quorumPeer.setZKDatabase(<span class="keyword">new</span> ZKDatabase(quorumPeer.getTxnFactory()));</span><br><span class="line">        quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line"></span><br><span class="line">        quorumPeer.start();</span><br><span class="line">        quorumPeer.join();</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">        LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码可以看到，集群启动过程先注册了jmx用于监控，然后配置网络连接工厂，最后创建了一个zk节点线程 QuorumPeer，配置完成后就启动它完成服务启动。</p><h1 id="QuorumPeer-start"><a href="#QuorumPeer-start" class="headerlink" title="QuorumPeer#start"></a>QuorumPeer#start</h1><p>QuorumPeer 详细启动过程如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 从磁盘加载快照和事务日志, 恢复数据到内存数据库</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    <span class="comment">// 建立网络通信</span></span><br><span class="line">    cnxnFactory.start();</span><br><span class="line">    <span class="comment">// 开始leader选举, 初始化相应组件(其实是在initLeaderElection)</span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="comment">// 启动当前线程</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDataBase</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从磁盘加载数据到内存数据库</span></span><br><span class="line">    zkDb.loadDataBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuorumPeer</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化选票</span></span><br><span class="line">    currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化选举算法</span></span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span> </span>{</span><br><span class="line">    Election le = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    qcm = <span class="keyword">new</span> QuorumCnxManager(<span class="keyword">this</span>);</span><br><span class="line">    QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) {</span><br><span class="line">        listener.start();</span><br><span class="line">        le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZKDatabase</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">loadDataBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    PlayBackListener listener = <span class="keyword">new</span> PlayBackListener() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTxnLoaded</span><span class="params">(TxnHeader hdr, Record txn)</span> </span>{</span><br><span class="line">            Request r = <span class="keyword">new</span> Request(<span class="keyword">null</span>, <span class="number">0</span>, hdr.getCxid(), hdr.getType(),</span><br><span class="line">                                    <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            r.txn = txn;</span><br><span class="line">            r.hdr = hdr;</span><br><span class="line">            r.zxid = hdr.getZxid();</span><br><span class="line">            addCommittedProposal(r);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取快照和事务日志后恢复服务器数据库</span></span><br><span class="line">    <span class="keyword">long</span> zxid = snapLog.restore(dataTree, sessionsWithTimeouts, listener);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> zxid;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileTxnSnapLog</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">restore</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span></span></span><br><span class="line"><span class="params"><span class="function">                    PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">// 从最后一个有效快照反序列化DataTree, 获得最后的zxid lastProcessedZxid</span></span><br><span class="line">    snapLog.deserialize(dt, sessions);</span><br><span class="line">    FileTxnLog txnLog = <span class="keyword">new</span> FileTxnLog(dataDir);</span><br><span class="line">    <span class="comment">// 获取大于有效快照zxid的所有事务</span></span><br><span class="line">    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> highestZxid = dt.lastProcessedZxid;</span><br><span class="line">    TxnHeader hdr;</span><br><span class="line">    <span class="comment">// 循环处理快照之后的事务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">// iterator points to</span></span><br><span class="line">        <span class="comment">// the first valid txn when initialized</span></span><br><span class="line">        hdr = itr.getHeader();</span><br><span class="line">        <span class="keyword">if</span> (hdr == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//empty logs</span></span><br><span class="line">            <span class="keyword">return</span> dt.lastProcessedZxid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != <span class="number">0</span>) {</span><br><span class="line">            LOG.error(highestZxid + <span class="string">"(higestZxid) &gt; "</span></span><br><span class="line">                      + hdr.getZxid() + <span class="string">"(next log) for type "</span></span><br><span class="line">                      + hdr.getType());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            highestZxid = hdr.getZxid();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 处理这条事务</span></span><br><span class="line">            processTransaction(hdr, dt, sessions, itr.getTxn());</span><br><span class="line">        } <span class="keyword">catch</span> (KeeperException.NoNodeException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to process transaction type: "</span> +</span><br><span class="line">                                  hdr.getType() + <span class="string">" error: "</span> + e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 增加一条事务提交日志</span></span><br><span class="line">        listener.onTxnLoaded(hdr, itr.getTxn());</span><br><span class="line">        <span class="keyword">if</span> (!itr.next())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> highestZxid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从以上代码可以看到，QuorumPeer的启动主要分为数据恢复、建立网络通信以及leader选举三个部分。</p><ul><li>数据恢复过程是利用快照和事务日志文件把数据恢复到内存DateTree中，zk会以最新的有效快照为基础，然后把之后的事务也恢复到内存中。</li><li>建立网络通信过程实际上就是创建了一个NIOServerSocket服务监听客户端请求。</li><li>leader选举这里只对准备工作分析，包含选票和选举算法两部分的初始化。具体选举过程将在下一篇详细分析。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ZooKeeper（集群）启动过程如下：</p><ol><li>解析zoo.cfg配置文件</li><li>启动后台线程定期清理快照和事务日志文件</li><li>根据快照和事务日志恢复数据到内存</li><li>建立网络通信</li><li>选举前的准备工作</li><li>leader选举（下篇分析）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从zkServer.sh启动脚本中我们可以看到zk启动入口类为QuorumPeerMain，接下来从其main方法入手开始分析zk启动流程。&lt;/p&gt;
&lt;h1 id=&quot;QuorumPeerMain-main&quot;&gt;&lt;a href=&quot;#QuorumPeerMain-main&quot; cl</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【字符串匹配】AC自动机</title>
    <link href="https://haifuns.com/2022/01/26/stringmatch-05/"/>
    <id>https://haifuns.com/2022/01/26/stringmatch-05/</id>
    <published>2022-01-26T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>在了解AC自动机前需要先简单了解一下Trie树：Trie树也称为字典树、前缀树，是一种常被用于词检索的树结构。其思想非常简单：利用词的共同前缀以达到节省空间的目的。基本实现有array和linked-list两种。</p><p>以bachelor, baby, badge, jar四个单词构成的Trie树为例，array实现需要为每一个字符开辟一个字母表大小的数据，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/trie-array.png" alt="trie array实现"></p><p>array实现的trie树查询时间复杂度为O(n)，但是存在大量的空间浪费。linked-list实现避免了空间浪费，却增加了查询时的复杂度（公共前缀需要回溯），如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/trie-linkedlist.png" alt="trie linked-list实现"></p><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>AC自动机通过将模式串预处理为确定有限状态自动机，扫描文本一遍就能结束，匹配复杂度为O(n)。</p><p>AC自动机包含三个核心函数：</p><ul><li>success，成功转移到另一个状态，也称为goto表或success表</li><li>failure，如果不能成功转移则跳转到一个特定的节点，也称为failure表</li><li>emits，命中一个模式串，也称为output表</li></ul><p>以文本“ushers”，模式串“he”、“she”、“his”、“hers”为例，构建的自动机如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/Aho-Corasick.png" alt="image"></p><p>匹配过程：</p><ol><li>接收到字符u，首先尝试按照success表转移（图中实线），没有相应路线，转移失败</li><li>按照failure表回去（图中虚线），继续接收到一个字符s，转移到状态3，然后继续按照success表转移</li><li>直到失败跳转重新跳转到步骤2，或者遇到output表中标明“可输出状态”输出匹配到的字符串，然后将此状态视作普通状态继续转移</li></ol><p>AC自动机高效之处在于在接受了“ushe”之后，再接受一个r导致无法按照success表继续转移，此时自动机按照failure表转移到2状态，然后再转移两次就能输出“hers”，整个匹配过程就好像没有失败过。</p><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><h3 id="goto表"><a href="#goto表" class="headerlink" title="goto表"></a>goto表</h3><p>goto表本质上就是一颗Trie树，其构建过程就是Trie树的构建过程。</p><h3 id="failure表"><a href="#failure表" class="headerlink" title="failure表"></a>failure表</h3><p>failure表是状态与状态的一对一关系，如示例中的虚线部分，构造方法如下：</p><ol><li>首先规定与状态0距离为1的所有fail值为0</li><li>假设当前状态是S1，S1前一个状态是S2，S2转换到S1接受字符为C即S1 = goto(S2, C)。fail(S1)求值方法为：测试goto(fail(S2)，C)<ul><li>如果成功，fail(S1) = goto(fail(S2), C)</li><li>如果失败，继续测试goto(fail(fail(S2))，C)，如此重复直到测试成功后赋值给fail(S1)</li></ul></li></ol><h3 id="output表"><a href="#output表" class="headerlink" title="output表"></a>output表</h3><p>output表在构建goto表和failure表的同时创建，例如示例中5 {she, he}，在创建goto表时类似Trie树里表示是否是单词结尾的结构，构建failure表时进行拓展。</p><h1 id="双数组Trie树"><a href="#双数组Trie树" class="headerlink" title="双数组Trie树"></a>双数组Trie树</h1><p>双数组trie树是一种空间复杂度低的Trie树，应用于字符区间大的语言（中文、日文等）分词领域，其本身并不保存树，而是在构建树过程维护base、check双数组，双数组信息足以表示整棵树。</p><p>base数组是goto表的array实现，check数组验证转移的有效性。以状态t接受字符c转移到状态tc为例，双数组满足以下转移方程：</p><ul><li>base[t] + c = tc</li><li>check[tc] = t</li></ul><h2 id="构建过程（darts-java实现）"><a href="#构建过程（darts-java实现）" class="headerlink" title="构建过程（darts-java实现）"></a>构建过程（<a href="https://github.com/komiya-atsushi/darts-java">darts-java实现</a>）</h2><ol><li>初始化root节点base[0] = 1; check[0] = 0</li><li>对于每一群兄弟节点，寻找一个begin值使得check[begin+a1]、check[begin+a2]、…、check[begin+an]都等于0，也就是找到n个空闲空间</li><li>设置check[begin+an]=begin</li><li>对于每个兄弟节点，如果没有子节点（即叶子节点），令其base为负值。否则设置base为begin，同时插入子节点，执行步骤2</li></ol><h2 id="前缀查询"><a href="#前缀查询" class="headerlink" title="前缀查询"></a>前缀查询</h2><p>定义当前状态p = base[0] = 1，依次读取字符串，如果base[p] = check[base[p]] &amp;&amp; base[base[p]] &lt; 0则查到一个词。</p><p>然后状态转移，增加一个字符，p = base[char[i-1]] + char[i] + 1</p><h1 id="AC自动机（双数组Trie树实现）"><a href="#AC自动机（双数组Trie树实现）" class="headerlink" title="AC自动机（双数组Trie树实现）"></a>AC自动机（双数组Trie树实现）</h1><p>AC自动机能够高速完成多模式匹配，其最终性能高低取决于具体实现，大部分实现都是使用一个Map&lt;Character,State&gt;，当字符区间大时其巨额空间复杂度与哈希函数性能消耗会降低整体性能。</p><p>双数组Trie树能在O(n)时间内完成单串匹配，并且内存消耗可控。然而如果要匹配多个模式串必须先实现前缀查询，然后频繁截取文本后缀才可以多匹配，文本需要回退扫描多遍，性能极低。</p><p>hankcs开源的<a href="https://github.com/hankcs/AhoCorasickDoubleArrayTrie">AhoCorasickDoubleArrayTrie</a>类库结合了双数组trie树和AC自动机的优点，得到了一种近乎完美的数据结构。</p><ul><li><a href="https://www.cnblogs.com/en-heng/p/6265256.html">双数组字典树</a></li><li><a href="http://www.hankcs.com/program/algorithm/implementation-and-analysis-of-aho-corasick-algorithm-in-java.html">Aho-Corasick算法的Java实现与分析</a></li><li><a href="http://www.hankcs.com/program/java/%e5%8f%8c%e6%95%b0%e7%bb%84trie%e6%a0%91doublearraytriejava%e5%ae%9e%e7%8e%b0.html">双数组Trie树(DoubleArrayTrie)Java实现</a></li><li><a href="http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html">Aho Corasick自动机结合DoubleArrayTrie极速多模式匹配</a></li><li><a href="https://github.com/komiya-atsushi/darts-java">双数组trie开源代码</a></li><li><a href="https://github.com/hankcs/aho-corasick">Aho-Corasick开源代码</a></li><li><a href="https://github.com/hankcs/AhoCorasickDoubleArrayTrie">双数组Trie树实现Aho-Corasick开源代码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Trie树&quot;&gt;&lt;a href=&quot;#Trie树&quot; class=&quot;headerlink&quot; title=&quot;Trie树&quot;&gt;&lt;/a&gt;Trie树&lt;/h1&gt;&lt;p&gt;在了解AC自动机前需要先简单了解一下Trie树：Trie树也称为字典树、前缀树，是一种常被用于词检索的树结构。其思想</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="文本匹配" scheme="https://haifuns.com/tags/%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【字符串匹配】KMP算法&amp;BM算法</title>
    <link href="https://haifuns.com/2022/01/10/stringmatch-04/"/>
    <id>https://haifuns.com/2022/01/10/stringmatch-04/</id>
    <published>2022-01-10T12:50:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法是由Knuth、Morris、Pratt三人设计的线性时间字符串匹配算法。这个算法不需要转移函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>，只需要用到辅助函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></svg></mjx-container>，根据模式预先计算并存储在数组中，数组中有m个值，而<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="3.62ex" height="1.57ex" role="img" focusable="false" viewBox="0 -683 1600 694"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container>个值，因而预处理时间减少了一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.633ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 722 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container>因子。</p><p>KMP算法预处理时间复杂度为O(m)，匹配时间复杂度为O(n)。</p><h2 id="前缀函数"><a href="#前缀函数" class="headerlink" title="前缀函数"></a>前缀函数</h2><p>模式的前缀函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></svg></mjx-container>包含模式与自身的偏移进行匹配的信息，这些信息可以用于暴力匹配算法中避免对无用偏移进行检测，也可以避免在字符串匹配机中对整个转移函数的预先计算。</p><p>对于一个已知的模式P[1..m]，模式P的前缀函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></svg></mjx-container>满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="3.588ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1586 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g><g data-mml-node="mo" transform="translate(570,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(848,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1308,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.65ex" xmlns="http://www.w3.org/2000/svg" width="2.376ex" height="2.195ex" role="img" focusable="false" viewBox="0 -683 1050.3 970.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></g></svg></mjx-container>的真后缀P的最长前缀长度。</p><p>例如对于模式ababaca的完整前缀函数如下图(a)所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/KMP-01.png" alt="image"></p><p>前缀函数computePrefixFunction(P)构建伪代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m = P.length</span><br><span class="line">let pi[m]</span><br><span class="line">pi[1] = 0</span><br><span class="line">k = 0</span><br><span class="line">for q = 2 to m</span><br><span class="line">    while k &gt; 0 &amp;&amp; P[k+1] != P[q]</span><br><span class="line">        k = pi[k]</span><br><span class="line">    if P[k+1] == P[q]</span><br><span class="line">        k = k + 1</span><br><span class="line">    pi[q] = k</span><br><span class="line">return pi</span><br></pre></td></tr></tbody></table></figure><h2 id="匹配伪代码"><a href="#匹配伪代码" class="headerlink" title="匹配伪代码"></a>匹配伪代码</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = T.length</span><br><span class="line">m = P.length</span><br><span class="line">pi = computePrefixFunction(P)</span><br><span class="line">q = 0</span><br><span class="line">for i = 1 to n // 扫描文本T</span><br><span class="line">    while q &gt; 0 &amp;&amp; P[q+1] != T[i]</span><br><span class="line">        q = pi[q] // 下一个文本不匹配</span><br><span class="line">    if P[q+1] == T[i]</span><br><span class="line">        q = q + 1 // 下一个文本匹配</span><br><span class="line">    if q == m</span><br><span class="line">        print i - m</span><br><span class="line">    q = pi[q] // 匹配失败直接跳到下一个位置</span><br></pre></td></tr></tbody></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPStringMatcher</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kmpSearch</span><span class="params">(String pat, String txt)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀函数</span></span><br><span class="line">        <span class="keyword">int</span>[] lps = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="comment">// 模式索引</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前缀函数</span></span><br><span class="line">        computeLPSArray(pat, m, lps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本索引</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) {</span><br><span class="line">            <span class="keyword">if</span> (pat.charAt(j) == txt.charAt(i)) {</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (j == m) {</span><br><span class="line">                System.out.println(<span class="string">"Found pattern at index "</span> + (i - j));</span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pat.charAt(j) != txt.charAt(i)) {</span><br><span class="line">                <span class="comment">// 匹配失败按照前缀函数移动模式指针</span></span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) {</span><br><span class="line">                    j = lps[j - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    i = i + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeLPSArray</span><span class="params">(String pat, <span class="keyword">int</span> m, <span class="keyword">int</span>[] lps)</span> </span>{</span><br><span class="line">        <span class="comment">// 前一个最长前缀的值</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一个字符固定0</span></span><br><span class="line">        lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 to m-1</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) {</span><br><span class="line">            <span class="keyword">if</span> (pat.charAt(i) == pat.charAt(len)) {</span><br><span class="line">                <span class="comment">// 匹配就加1</span></span><br><span class="line">                len++;</span><br><span class="line">                lps[i] = len;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// (pat[i] != pat[len])</span></span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) {</span><br><span class="line">                    len = lps[len - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// len == 0)</span></span><br><span class="line">                    lps[i] = len;</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">        String txt = <span class="string">"ABABDABACDABABCABAB"</span>;</span><br><span class="line">        String pat = <span class="string">"ABABCABAB"</span>;</span><br><span class="line">        <span class="keyword">new</span> KMPStringMatcher().kmpSearch(pat, txt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>Boyer和Moore提出的BM算法在匹配时从右向左扫描模式串，在最坏情况下的时间复杂度为O(n)，相对于KMP从左往右匹配模式串更高效。</p><p>当文本字符串与模式字符串不匹配时，将模式串向右移动的位数 = 当前位置 - 字符在模式中最右出现的位置（如果字符不在模式中则最右出现位置为-1）。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMStringMatcher</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> NO_OF_CHARS = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badCharHeuristic</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> size, <span class="keyword">int</span>[] badchar)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化所有位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NO_OF_CHARS; i++) {</span><br><span class="line">            badchar[i] = -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模式中存在的字符值为最右位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            badchar[str[i]] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] txt, <span class="keyword">char</span>[] pat)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length;</span><br><span class="line">        <span class="keyword">int</span> n = txt.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] badchar = <span class="keyword">new</span> <span class="keyword">int</span>[NO_OF_CHARS];</span><br><span class="line"></span><br><span class="line">        badCharHeuristic(pat, m, badchar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= (n - m)) {</span><br><span class="line">            <span class="keyword">int</span> j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; pat[j] == txt[s + j]) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) {</span><br><span class="line">                System.out.println(<span class="string">"Found pattern at index = "</span> + s);</span><br><span class="line">                s += (s + m &lt; n) ? m - badchar[txt[s + m]] : <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                s += Math.max(<span class="number">1</span>, j - badchar[txt[s + j]]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] txt = <span class="string">"ABABDABACDABABCABAB"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] pat = <span class="string">"ABABCABAB"</span>.toCharArray();</span><br><span class="line">        search(txt, pat);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>算法导论（第三版）</li><li>算法（第四版）</li><li><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a></li><li><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching">KMP Algorithm for Pattern Searching</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h1&gt;&lt;p&gt;KMP算法是由Knuth、Morris、Pratt三人设计的线性时间字符串匹配算法。这个算法不需要转移函数&lt;mjx-</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="文本匹配" scheme="https://haifuns.com/tags/%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【Curator源码】可重入读写锁源码解析</title>
    <link href="https://haifuns.com/2022/01/06/curator-03/"/>
    <id>https://haifuns.com/2022/01/06/curator-03/</id>
    <published>2022-01-06T11:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<p>curator提供的读写锁使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InterProcessReadWriteLock interProcessReadWriteLock = <span class="keyword">new</span> InterProcessReadWriteLock(client, <span class="string">""</span>);</span><br><span class="line">InterProcessMutex readLock = interProcessReadWriteLock.readLock();</span><br><span class="line">readLock.acquire();</span><br><span class="line">readLock.release();</span><br><span class="line"></span><br><span class="line">InterProcessMutex writeLock = interProcessReadWriteLock.writeLock();</span><br><span class="line">writeLock.acquire();</span><br><span class="line">writeLock.release();</span><br></pre></td></tr></tbody></table></figure><p>curator读写锁加锁情况分析：</p><ul><li>读锁 + 读锁，加锁成功</li><li>读锁 + 写锁，写锁加锁失败</li><li>写锁 + 读锁，同一个线程先加写锁后加读锁可以成功，否则加读锁失败</li><li>写锁 + 写锁，第二个写锁加锁失败</li></ul><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>在读锁加锁时，curator会在path下创建一个lockname为_READ_的顺序节点。如果当前线程加写锁成功，加读锁直接成功。否则，判断在所有子节点中，当前顺序节点前面有没有写锁，有就加锁失败开始等待，否则加锁成功。</p><p>在读锁解锁时，同可重入锁，直接删除顺序节点，此时在这个节点上注册watcher的线程会被唤醒，尝试加锁。</p><p>读锁相对于可重入锁重写了获取锁的方法，源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex readMutex = <span class="keyword">new</span> InternalInterProcessMutex</span><br><span class="line">(</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        READ_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 读锁最大加锁次数</span></span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        <span class="keyword">new</span> SortingLockInternalsDriver() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                        <span class="keyword">return</span> readLockPredicate(children, sequenceNodeName);</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PredicateResults <span class="title">readLockPredicate</span><span class="params">(List&lt;String&gt; children, String sequenceNodeName)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 如果是当前线程加的写锁，那么读锁可以加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> ( writeMutex.isOwnedByCurrentThread() ) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>         index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最前面的写锁位置</span></span><br><span class="line">        <span class="keyword">int</span>         firstWriteIndex = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 当前读锁的位置</span></span><br><span class="line">        <span class="keyword">int</span>         ourIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( String node : children ) {</span><br><span class="line">                <span class="keyword">if</span> ( node.contains(WRITE_LOCK_NAME) ) {</span><br><span class="line">                        firstWriteIndex = Math.min(index, firstWriteIndex);</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> ( node.startsWith(sequenceNodeName) ) {</span><br><span class="line">                        ourIndex = index;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                ++index;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前读锁前面有写锁则加锁失败，否则加锁成功</span></span><br><span class="line">        <span class="keyword">boolean</span>     getsTheLock = (ourIndex &lt; firstWriteIndex);</span><br><span class="line">        String      pathToWatch = getsTheLock ? <span class="keyword">null</span> : children.get(firstWriteIndex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch, getsTheLock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>在写锁加锁时，curator会在path下创建一个lockname为_WRITE_的顺序节点，然后判断当前节点是不是所有子节点中第一个，如果是第一个则加写锁成功，否则加锁失败开始等待。</p><p>在写锁解锁时，同读锁，直接删除顺序节点，此时在这个节点上注册watcher的线程会被唤醒，尝试加锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex writeMutex = <span class="keyword">new</span> InternalInterProcessMutex</span><br><span class="line">(</span><br><span class="line">        client,</span><br><span class="line">        basePath,</span><br><span class="line">        WRITE_LOCK_NAME,</span><br><span class="line">        lockData,</span><br><span class="line">        <span class="comment">// 写锁只能加一个</span></span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> SortingLockInternalsDriver() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> PredicateResults <span class="title">getsTheLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; children, String sequenceNodeName, <span class="keyword">int</span> maxLeases)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;curator提供的读写锁使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Curator" scheme="https://haifuns.com/tags/Curator/"/>
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Curator源码】信号量&amp;不可重入锁源码解析</title>
    <link href="https://haifuns.com/2022/01/05/curator-02/"/>
    <id>https://haifuns.com/2022/01/05/curator-02/</id>
    <published>2022-01-05T12:35:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<p>curator提供的信号量使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, <span class="string">"/semaphore/semaphore_01"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 获取信号</span></span><br><span class="line">Lease lease = semaphore.acquire();</span><br><span class="line"><span class="comment">// 返还信号</span></span><br><span class="line">semaphore.returnLease(lease);</span><br></pre></td></tr></tbody></table></figure><h1 id="获取信号"><a href="#获取信号" class="headerlink" title="获取信号"></a>获取信号</h1><p>curator信号量内部包含一个可重入锁，在获取信号时，首先会尝试获取内部可重入锁，在获取完成后，直接在path/leases路径下创建一个临时有序节点并创建一个watch监听器，然后获取到所有子节点，当且仅当当前的有序节点是子节点中第一个时认为获取信号成功，否则线程wait，直到其他线程返回信号时watcher收到状态变更notify后重新判断。当获取信号成功后释放内部可重入锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterProcessSemaphoreV2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    Collection&lt;Lease&gt; leases = acquire(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> leases.iterator().next();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">long</span> startMs = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">boolean</span> hasWait = (unit != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">long</span> waitMs = hasWait ? TimeUnit.MILLISECONDS.convert(time, unit) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    ImmutableList.Builder&lt;Lease&gt; builder = ImmutableList.builder();</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> ( qty-- &gt; <span class="number">0</span> ) {</span><br><span class="line">            <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> startMillis = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> ( !isDone ) {</span><br><span class="line">                <span class="keyword">switch</span> ( internalAcquire1Lease(builder, startMs, hasWait, waitMs) ) {</span><br><span class="line">                    <span class="keyword">case</span> CONTINUE: {</span><br><span class="line">                        isDone = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> ( !success ) {</span><br><span class="line">            returnAll(builder.build());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InternalAcquireResult <span class="title">internalAcquire1Lease</span><span class="params">(ImmutableList.Builder&lt;Lease&gt; builder, <span class="keyword">long</span> startMs, <span class="keyword">boolean</span> hasWait, <span class="keyword">long</span> waitMs)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> ( client.getState() != CuratorFrameworkState.STARTED ) {</span><br><span class="line">        <span class="keyword">return</span> InternalAcquireResult.RETURN_NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( hasWait ) {</span><br><span class="line">        <span class="keyword">long</span> thisWaitMs = getThisWaitMs(startMs, waitMs);</span><br><span class="line">        <span class="keyword">if</span> ( !lock.acquire(thisWaitMs, TimeUnit.MILLISECONDS) ) {</span><br><span class="line">            <span class="keyword">return</span> InternalAcquireResult.RETURN_NULL;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 内部可重入锁，尝试加锁</span></span><br><span class="line">        lock.acquire();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Lease lease = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        PathAndBytesable&lt;String&gt; createBuilder = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        <span class="comment">// 创建临时有序节点，path/leases</span></span><br><span class="line">        String path = (nodeData != <span class="keyword">null</span>) ? createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME), nodeData) : createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME));</span><br><span class="line">        String nodeName = ZKPaths.getNodeFromPath(path);</span><br><span class="line">        lease = makeLease(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( debugAcquireLatch != <span class="keyword">null</span> ) {</span><br><span class="line">            debugAcquireLatch.await();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                List&lt;String&gt; children;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 获取当前path/leases下所有子节点，注册watcher</span></span><br><span class="line">                    children = client.getChildren().usingWatcher(watcher).forPath(leasesPath);</span><br><span class="line">                } <span class="keyword">catch</span> ( Exception e ) {</span><br><span class="line">                    <span class="keyword">if</span> ( debugFailedGetChildrenLatch != <span class="keyword">null</span> ) {</span><br><span class="line">                        debugFailedGetChildrenLatch.countDown();</span><br><span class="line">                    }</span><br><span class="line">                    returnLease(lease); <span class="comment">// otherwise the just created ZNode will be orphaned causing a dead lock</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> ( !children.contains(nodeName) ) {</span><br><span class="line">                    log.error(<span class="string">"Sequential path not found: "</span> + path);</span><br><span class="line">                    returnLease(lease);</span><br><span class="line">                    <span class="keyword">return</span> InternalAcquireResult.RETRY_DUE_TO_MISSING_NODE;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果子节点数量小于最大值，那么获取成功</span></span><br><span class="line">                <span class="keyword">if</span> ( children.size() &lt;= maxLeases ) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> ( hasWait ) {</span><br><span class="line">                    <span class="keyword">long</span> thisWaitMs = getThisWaitMs(startMs, waitMs);</span><br><span class="line">                    <span class="keyword">if</span> ( thisWaitMs &lt;= <span class="number">0</span> ) {</span><br><span class="line">                        returnLease(lease);</span><br><span class="line">                        <span class="keyword">return</span> InternalAcquireResult.RETURN_NULL;</span><br><span class="line">                    }</span><br><span class="line">                    wait(thisWaitMs);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 失败阻塞</span></span><br><span class="line">                    wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 获取完毕释放内部锁</span></span><br><span class="line">        lock.release();</span><br><span class="line">    }</span><br><span class="line">    builder.add(Preconditions.checkNotNull(lease));</span><br><span class="line">    <span class="keyword">return</span> InternalAcquireResult.CONTINUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="释放信号"><a href="#释放信号" class="headerlink" title="释放信号"></a>释放信号</h1><p>在需要释放信号时，直接删除当前临时有序节点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 释放直接删除path/leases下的子节点</span></span><br><span class="line">        client.delete().guaranteed().forPath(path);</span><br><span class="line">    } <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) {</span><br><span class="line">        log.warn(<span class="string">"Lease already released"</span>, e);</span><br><span class="line">    } <span class="keyword">catch</span> ( Exception e ) {</span><br><span class="line">        ThreadUtils.checkInterrupted(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h1><p>非可重入锁内部包含一个信号量InterProcessSemaphoreV2，最大数量为1。加锁时获取信号，解锁时释放信号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;curator提供的信号量使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Curator" scheme="https://haifuns.com/tags/Curator/"/>
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Curator源码】可重入锁源码解析</title>
    <link href="https://haifuns.com/2022/01/04/curator-01/"/>
    <id>https://haifuns.com/2022/01/04/curator-01/</id>
    <published>2022-01-04T05:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<p>Curator提供可重入锁，使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/locks/lock_01"</span>);</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">interProcessMutex.acquire();</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">interProcessMutex.release();</span><br></pre></td></tr></tbody></table></figure><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>当需要加锁时，curator会直接为当前线程在当前锁路径下创建一个临时有序节点，如果这个节点是排在有序列表第一个元素即获取锁成功，否则需要注册一个watcher监听器，等待上一个临时有序节点被删除后重试尝试获取锁。由加锁逻辑可知，curator提供的可重入锁是公平的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// InterProcessMutex</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="keyword">null</span>) ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Lost connection while trying to acquire lock: "</span> + basePath);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    </span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="comment">// 如果重复加锁，计数器加1直接返回</span></span><br><span class="line">        <span class="comment">// re-entering</span></span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="comment">// 如果加锁成功，添加到线程锁map里</span></span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockInternals</span></span><br><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( !isDone ) {</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">        } <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( hasTheLock ) {</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockInternalsDriver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    String ourPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心加锁逻辑，创建一个临时顺序节点</span></span><br><span class="line">    <span class="comment">// creatingParentContainersIfNeeded 自动创建父目录</span></span><br><span class="line">    <span class="comment">// EPHEMERAL_SEQUENTIAL 临时顺序节点</span></span><br><span class="line">    <span class="comment">// path = /locks/lock_01</span></span><br><span class="line">    <span class="comment">// ourPath = /locks/lock_01/_c_4b565d11-c377-4e77-ab2d-81c2011f50a9-lock-0000000002</span></span><br><span class="line">    ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">boolean</span>     haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>     doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> ) {</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) {</span><br><span class="line">            <span class="comment">// 所有节点，从小到大排序</span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren();</span><br><span class="line">            <span class="comment">// 当前顺序节点序号</span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取锁，maxLeases默认等于1</span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) {</span><br><span class="line">                <span class="comment">// 如果获取到锁，直接返回</span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 前一个顺序节点path</span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="comment">// 设置zk watcher，然后当前线程睡眠等待watch收到更改事件唤醒</span></span><br><span class="line">                        <span class="comment">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> ) {</span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> ) {</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            wait();</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) {</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> ( Exception e ) {</span><br><span class="line">        ThreadUtils.checkInterrupted(e);</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> ( doDelete ) {</span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h1><p>当需要解锁时，curator会判断锁是否被重入，如果没有直接删除临时节点。此时在这个节点上注册watcher的线程收到删除事件后会被notify结束wait，然后判断是否获取到锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterProcessMutex</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData == <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock: "</span> + basePath);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁次数递减1，如果剩余的加锁次数大于0，直接返回</span></span><br><span class="line">    <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> ( newLockCount &gt; <span class="number">0</span> ) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( newLockCount &lt; <span class="number">0</span> ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gone negative for lock: "</span> + basePath);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果只重入了1次，删除锁</span></span><br><span class="line">        internals.releaseLock(lockData.lockPath);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 移除线程锁map</span></span><br><span class="line">        threadData.remove(currentThread);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockInternals</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockPath)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    revocable.set(<span class="keyword">null</span>);</span><br><span class="line">    deleteOurPath(lockPath);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOurPath</span><span class="params">(String ourPath)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        client.delete().guaranteed().forPath(ourPath);</span><br><span class="line">    } <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) {</span><br><span class="line">        <span class="comment">// ignore - already deleted (possibly expired session, etc.)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Curator提供可重入锁，使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Curator" scheme="https://haifuns.com/tags/Curator/"/>
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>【字符串匹配】DFA 算法（确定有限自动机）</title>
    <link href="https://haifuns.com/2021/12/21/stringmatch-03/"/>
    <id>https://haifuns.com/2021/12/21/stringmatch-03/</id>
    <published>2021-12-21T05:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>一个有限自动机M是一个5元组<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="13.905ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6146.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(1180,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1624.7,0)"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(479,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(2507.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2951.9,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(3701.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(4146.6,0)"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(4868.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(5313.2,0)"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g><g data-mml-node="mo" transform="translate(5757.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，其中：</p><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container>是状态的有限集合</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="6.552ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 2896.1 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(479,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1160.3,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2105.1,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container>是初始状态</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="6.504ex" height="2.059ex" role="img" focusable="false" viewBox="0 -716 2874.6 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(1027.8,0)"><path data-c="2286" d="M84 346Q84 468 166 546T360 635Q361 635 370 635T395 635T430 636T475 636T524 636H679Q694 628 694 616Q694 607 681 597L522 596H470H441Q366 596 338 592T266 568Q244 557 224 542T179 500T139 433T124 346V341Q124 253 185 185Q244 121 328 103Q348 98 366 98T522 96H681Q694 86 694 76Q694 64 679 56H526Q510 56 480 56T434 55Q350 55 289 71T172 141Q84 223 84 346ZM104 -131T104 -118T118 -98H679Q694 -106 694 -118T679 -138H118Q104 -131 104 -118Z"></path></g><g data-mml-node="mi" transform="translate(2083.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container>是一个特殊的接受状态集合</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.633ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 722 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container>是有限输入字母表</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>是一个从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="11.498ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 5082 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(1013.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(2013.4,0)"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(3013.2,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4291,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container>的函数，称为M的转移函数</li></ul><p>有限自动机开始于状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.997ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 882.6 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(479,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>，每次读入输入字符串的一个字符。如果有限自动机在状态q时读入了字符a，则它将从状态q转移为状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.008ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2655.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g><g data-mml-node="mo" transform="translate(444,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1293,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1737.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2266.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。每当其当前状态q属于A时，就认为自动机M接受了读入的所有字符串。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/dfa-01.png" alt="image"></p><p>如上图，一个拥有状态集Q={0,1}的简单状态自动机，开始状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.997ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 882.6 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(479,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>为0，字母表<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.633ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 722 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container> = {a, b}，图左用表格表示转移函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>，图右为等价的状态转换图。状态1是唯一的接受状态。这个自动机接收奇数个a结尾的字符串，例如对于输入abaaa，包含初始状态，这个自动机输入状态序列为{0,1,0,1,0,1}，因此它接收这个输入，如果输入是abbaa，自动机输入状态序列为{0,1,0,0,1,0}，因此它拒绝这个输入。</p><p>有限自动机M引入一个函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="1.348ex" height="2.034ex" role="img" focusable="false" viewBox="0 -694 596 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D719" d="M409 688Q413 694 421 694H429H442Q448 688 448 686Q448 679 418 563Q411 535 404 504T392 458L388 442Q388 441 397 441T429 435T477 418Q521 397 550 357T579 260T548 151T471 65T374 11T279 -10H275L251 -105Q245 -128 238 -160Q230 -192 227 -198T215 -205H209Q189 -205 189 -198Q189 -193 211 -103L234 -11Q234 -10 226 -10Q221 -10 206 -8T161 6T107 36T62 89T43 171Q43 231 76 284T157 370T254 422T342 441Q347 441 348 445L378 567Q409 686 409 688ZM122 150Q122 116 134 91T167 53T203 35T237 27H244L337 404Q333 404 326 403T297 395T255 379T211 350T170 304Q152 276 137 237Q122 191 122 150ZM500 282Q500 320 484 347T444 385T405 400T381 404H378L332 217L284 29Q284 27 285 27Q293 27 317 33T357 47Q400 66 431 100T475 170T494 234T500 282Z"></path></g></g></g></svg></mjx-container>，称为终态函数，它是从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="7.93ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 3505.1 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(755,363) scale(0.707)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g></g><g data-mml-node="mo" transform="translate(1436.3,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2714.1,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container>的函数，满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.516ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1996 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D719" d="M409 688Q413 694 421 694H429H442Q448 688 448 686Q448 679 418 563Q411 535 404 504T392 458L388 442Q388 441 397 441T429 435T477 418Q521 397 550 357T579 260T548 151T471 65T374 11T279 -10H275L251 -105Q245 -128 238 -160Q230 -192 227 -198T215 -205H209Q189 -205 189 -198Q189 -193 211 -103L234 -11Q234 -10 226 -10Q221 -10 206 -8T161 6T107 36T62 89T43 171Q43 231 76 284T157 370T254 422T342 441Q347 441 348 445L378 567Q409 686 409 688ZM122 150Q122 116 134 91T167 53T203 35T237 27H244L337 404Q333 404 326 403T297 395T255 379T211 350T170 304Q152 276 137 237Q122 191 122 150ZM500 282Q500 320 484 347T444 385T405 400T381 404H378L332 217L284 29Q284 27 285 27Q293 27 317 33T357 47Q400 66 431 100T475 170T494 234T500 282Z"></path></g><g data-mml-node="mo" transform="translate(596,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(985,0)"><path data-c="1D714" d="M495 384Q495 406 514 424T555 443Q574 443 589 425T604 364Q604 334 592 278T555 155T483 38T377 -11Q297 -11 267 66Q266 68 260 61Q201 -11 125 -11Q15 -11 15 139Q15 230 56 325T123 434Q135 441 147 436Q160 429 160 418Q160 406 140 379T94 306T62 208Q61 202 61 187Q61 124 85 100T143 76Q201 76 245 129L253 137V156Q258 297 317 297Q348 297 348 261Q348 243 338 213T318 158L308 135Q309 133 310 129T318 115T334 97T358 83T393 76Q456 76 501 148T546 274Q546 305 533 325T508 357T495 384Z"></path></g><g data-mml-node="mo" transform="translate(1607,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>是M在扫描字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.407ex" height="1.027ex" role="img" focusable="false" viewBox="0 -443 622 454"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D714" d="M495 384Q495 406 514 424T555 443Q574 443 589 425T604 364Q604 334 592 278T555 155T483 38T377 -11Q297 -11 267 66Q266 68 260 61Q201 -11 125 -11Q15 -11 15 139Q15 230 56 325T123 434Q135 441 147 436Q160 429 160 418Q160 406 140 379T94 306T62 208Q61 202 61 187Q61 124 85 100T143 76Q201 76 245 129L253 137V156Q258 297 317 297Q348 297 348 261Q348 243 338 213T318 158L308 135Q309 133 310 129T318 115T334 97T358 83T393 76Q456 76 501 148T546 274Q546 305 533 325T508 357T495 384Z"></path></g></g></g></svg></mjx-container>后终止时的状态。</p><h1 id="字符串匹配自动机"><a href="#字符串匹配自动机" class="headerlink" title="字符串匹配自动机"></a>字符串匹配自动机</h1><p>对于给定模式P[1…m]，其相应的字符串匹配自动机定义如下：</p><ul><li>状态集合Q为{0,1,…,m}，开始状态<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.997ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 882.6 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(479,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>是0状态，并且只有状态m是唯一被接受的状态。</li><li>对任意的状态q和字符a，转移函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>定义如下：</li></ul><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.65ex" xmlns="http://www.w3.org/2000/svg" width="15.65ex" height="2.347ex" role="img" focusable="false" viewBox="0 -750 6917.5 1037.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g><g data-mml-node="mo" transform="translate(444,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1293,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1737.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2266.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2933.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3989.2,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(4560.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(4949.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mi" transform="translate(5999.5,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(6528.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>为辅助函数，称为P的后缀函数，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.292ex" height="1ex" role="img" focusable="false" viewBox="0 -431 571 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g></g></g></svg></mjx-container>是一个从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.621ex" height="1.565ex" role="img" focusable="false" viewBox="0 -691.8 1158.6 691.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(755,363) scale(0.707)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g></g></g></g></svg></mjx-container>到{0,1,…,m}上的映射，满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.346ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1921 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(571,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(960,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1532,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>是x的后缀P的最长前缀的长度，例如，对模式P=ab，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="25.896ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11446.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(571,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(960,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1393,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1826,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2355,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(2788,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(3317,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3983.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5039.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(5539.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(6439.6,0)"><path data-c="1D70E" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path></g><g data-mml-node="mo" transform="translate(7010.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7399.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(7832.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(8265.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(8794.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(9223.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(9890.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(10946.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>。</p><p>对于给定模式P[1…m]，转移函数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>计算伪代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m = P.length</span><br><span class="line">for q = 0 to m</span><br><span class="line">    for each charater a ∈ Σ</span><br><span class="line">        k = min(m+1,q+2)</span><br><span class="line">        repeat</span><br><span class="line">            k = k - 1</span><br><span class="line">        until P[0:k]==(P[q]+a)[q+1-k:q+1] //P[0:k]=P[q]+a后缀(P[q]+a)[q+1-k:q+1]</span><br><span class="line">        δ(q,a) = k</span><br><span class="line">return δ</span><br></pre></td></tr></tbody></table></figure><p>由此可以得到自动机准备时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.094ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 3577.6 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(911,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mi" transform="translate(2466.6,0)"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(3188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>（通过改进转移函数可以使准备时间复杂度提升为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.106ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2030,0)"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="mo" transform="translate(2752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，这里暂时不探讨），运行时间复杂度为O(n)。</p><p>匹配示例：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/algorithm/stringmatch/dfa-02.png" alt="image"></p><p>上图中：</p><ul><li>(A)是字符串匹配自动机的状态转换图，它可以接受所有以字符串ababaca结尾的字符串。状态0是初始状态，状态7是仅有的接受状态</li><li>(B)为转移函数</li><li>(C)是自动机在文本abababacaba上的操作</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiniteAutomatonMatcher</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> NO_OF_CHARS = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextState</span><span class="params">(<span class="keyword">char</span>[] pat, <span class="keyword">int</span> m, <span class="keyword">int</span> state, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符与模式中下一个字符相同，则直接+1</span></span><br><span class="line">        <span class="keyword">if</span> (state &lt; m &amp;&amp; x == pat[state]) {</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ns是下一个状态</span></span><br><span class="line">        <span class="keyword">int</span> ns, i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历状态</span></span><br><span class="line">        <span class="keyword">for</span> (ns = state; ns &gt; <span class="number">0</span>; ns--) {</span><br><span class="line">            <span class="comment">// 如果模式中包含这个字符，ns-1是符号下标</span></span><br><span class="line">            <span class="keyword">if</span> (pat[ns - <span class="number">1</span>] == x) {</span><br><span class="line">                <span class="comment">// 遍历前缀所有字符</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ns - <span class="number">1</span>; i++) {</span><br><span class="line">                    <span class="comment">// 比较 pat[0..i] 前缀，pat[0..state-1]c 后缀</span></span><br><span class="line">                    <span class="comment">// ns-1是c的位置，i为前缀，state-(ns-1)-i为后缀</span></span><br><span class="line">                    <span class="keyword">if</span> (pat[i] != pat[state - ns + <span class="number">1</span> + i]) {</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 前缀=后缀</span></span><br><span class="line">                <span class="keyword">if</span> (i == ns - <span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">computeTransFun</span><span class="params">(<span class="keyword">char</span>[] pat, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] tf)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> state, x;</span><br><span class="line">        <span class="keyword">for</span> (state = <span class="number">0</span>; state &lt;= m; ++state) {</span><br><span class="line">            <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; NO_OF_CHARS; ++x) {</span><br><span class="line">                tf[state][x] = getNextState(pat, m, state, x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] pat, <span class="keyword">char</span>[] txt)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length;</span><br><span class="line">        <span class="keyword">int</span> n = txt.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] tf = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][NO_OF_CHARS];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建转换函数</span></span><br><span class="line">        computeTransFun(pat, m, tf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i, state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            state = tf[state][txt[i]];</span><br><span class="line">            <span class="keyword">if</span> (state == m) {</span><br><span class="line">                System.out.println(<span class="string">"Pattern found at index "</span> + (i - m + <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] txt = <span class="string">"我爱北京天安门，天安门在北京，北京城在北方"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] pat = <span class="string">"北京"</span>.toCharArray();</span><br><span class="line">        search(pat, txt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>算法导论</li><li>自动机代码：<a href="https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching">https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching</a></li><li>改进转移函数自动机代码：<a href="https://www.geeksforgeeks.org/pattern-searching-set-5-efficient-constructtion-of-finite-automata">https://www.geeksforgeeks.org/pattern-searching-set-5-efficient-constructtion-of-finite-automata</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有限自动机&quot;&gt;&lt;a href=&quot;#有限自动机&quot; class=&quot;headerlink&quot; title=&quot;有限自动机&quot;&gt;&lt;/a&gt;有限自动机&lt;/h1&gt;&lt;p&gt;一个有限自动机M是一个5元组&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;sv</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="文本匹配" scheme="https://haifuns.com/tags/%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【Redission源码】信号量&amp;闭锁源码解析</title>
    <link href="https://haifuns.com/2021/12/16/redission-05/"/>
    <id>https://haifuns.com/2021/12/16/redission-05/</id>
    <published>2021-12-15T16:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h1><p>Redisson提供分布式信号量，接口和用法与juc.Semaphore相似，使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore = redisson.getSemaphore(<span class="string">"semaphore"</span>);</span><br><span class="line">semaphore.addPermits(<span class="number">10</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(<span class="number">23</span>);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(<span class="number">10</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.releaseAsync();</span><br></pre></td></tr></tbody></table></figure><h2 id="新增凭证"><a href="#新增凭证" class="headerlink" title="新增凭证"></a>新增凭证</h2><p>添加凭证实际上就是给redis中的key设置一个值。核心方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">addPermitsAsync</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_VOID,</span><br><span class="line">            <span class="string">"local value = redis.call('get', KEYS[1]); "</span> +</span><br><span class="line">            <span class="string">"if (value == false) then "</span></span><br><span class="line">              + <span class="string">"value = 0;"</span></span><br><span class="line">          + <span class="string">"end;"</span></span><br><span class="line">          + <span class="string">"redis.call('set', KEYS[1], value + ARGV[1]); "</span></span><br><span class="line">          + <span class="string">"redis.call('publish', KEYS[2], value + ARGV[1]); "</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="获取凭证"><a href="#获取凭证" class="headerlink" title="获取凭证"></a>获取凭证</h2><p>获取凭证时，只需判断剩余凭证大于要申请的凭证数量即可申请成功，如果获取失败就订阅凭证释放消息，收到释放凭证消息后循环获取。获取凭证核心方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Permits amount can't be negative"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (permits == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> RedissonPromise.newSucceededFuture(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">              <span class="comment">// 查询信号量</span></span><br><span class="line">              <span class="string">"local value = redis.call('get', KEYS[1]); "</span> +</span><br><span class="line">              <span class="comment">// 如果存在，并且剩余数量大于申请的数量</span></span><br><span class="line">              <span class="string">"if (value ~= false and tonumber(value) &gt;= tonumber(ARGV[1])) then "</span> +</span><br><span class="line">                  <span class="comment">// 扣减申请的数量，返回成功</span></span><br><span class="line">                  <span class="string">"local val = redis.call('decrby', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                  <span class="string">"return 1; "</span> +</span><br><span class="line">              <span class="string">"end; "</span> +</span><br><span class="line">              <span class="comment">// 否则返回失败</span></span><br><span class="line">              <span class="string">"return 0;"</span>,</span><br><span class="line">              <span class="comment">// KEY[1] 信号量名称，KEY[2] 信号数量</span></span><br><span class="line">              Collections.&lt;Object&gt;singletonList(getRawName()), permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="释放凭证"><a href="#释放凭证" class="headerlink" title="释放凭证"></a>释放凭证</h2><p>释放凭证时直接给信号量增加相应数量的凭证，然后发布一条释放凭证的消息通知订阅的等待线程。释放凭证核心方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">releaseAsync</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Permits amount can't be negative"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (permits == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> RedissonPromise.newSucceededFuture(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RFuture&lt;Void&gt; future = commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,</span><br><span class="line">            <span class="comment">// 直接给信号量加释放的个数</span></span><br><span class="line">            <span class="string">"local value = redis.call('incrby', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="comment">// 发布一条释放信号消息给等待的线程</span></span><br><span class="line">                    <span class="string">"redis.call('publish', KEYS[2], value); "</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), permits);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">        future.onComplete((o, e) -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</span><br><span class="line">                log.debug(<span class="string">"released, permits: {}, name: {}"</span>, permits, getName());</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 CountDownLatch"></a>闭锁 CountDownLatch</h1><p>Redission提供闭锁功能，接口和用法与juc.CountDownLatch相似，使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCountDownLatch latch = redisson.getCountDownLatch(<span class="string">"anyCountDownLatch"</span>);</span><br><span class="line">latch.trySetCount(<span class="number">1</span>);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line">RCountDownLatch latch = redisson.getCountDownLatch(<span class="string">"anyCountDownLatch"</span>);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></tbody></table></figure><h2 id="设置计数器值"><a href="#设置计数器值" class="headerlink" title="设置计数器值"></a>设置计数器值</h2><p>CountDownLatch计数器值只有在未设置过才能设置成功，Redission提供的CountDownLatch设置计数器值核心方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">trySetCountAsync</span><span class="params">(<span class="keyword">long</span> count)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 如果CountDownLatch name不存在</span></span><br><span class="line">            <span class="string">"if redis.call('exists', KEYS[1]) == 0 then "</span></span><br><span class="line">                <span class="comment">// 新增CountDownLatch</span></span><br><span class="line">                + <span class="string">"redis.call('set', KEYS[1], ARGV[2]); "</span></span><br><span class="line">                <span class="comment">// 发布一条新增计数器的消息</span></span><br><span class="line">                + <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span></span><br><span class="line">                + <span class="string">"return 1 "</span></span><br><span class="line">            <span class="comment">// 存在直接返回失败</span></span><br><span class="line">            + <span class="string">"else "</span></span><br><span class="line">                + <span class="string">"return 0 "</span></span><br><span class="line">            + <span class="string">"end"</span>,</span><br><span class="line">            Arrays.&lt;Object&gt;asList(getRawName(), getChannelName()), CountDownLatchPubSub.NEW_COUNT_MESSAGE, count);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="减少计数器值"><a href="#减少计数器值" class="headerlink" title="减少计数器值"></a>减少计数器值</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">countDownAsync</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                    <span class="comment">// 减少CountDownLatch计数器数量</span></span><br><span class="line">                    <span class="string">"local v = redis.call('decr', KEYS[1]);"</span> +</span><br><span class="line">                    <span class="comment">// 如果剩余的计数器小于0就直接删除</span></span><br><span class="line">                    <span class="string">"if v &lt;= 0 then redis.call('del', KEYS[1]) end;"</span> +</span><br><span class="line">                    <span class="comment">// 如果剩余计数器等于0，就发布一条计数器为零的消息通知订阅的线程</span></span><br><span class="line">                    <span class="string">"if v == 0 then redis.call('publish', KEYS[2], ARGV[1]) end;"</span>,</span><br><span class="line">                Arrays.&lt;Object&gt;asList(getRawName(), getChannelName()), CountDownLatchPubSub.ZERO_COUNT_MESSAGE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="等待计数器值达到0"><a href="#等待计数器值达到0" class="headerlink" title="等待计数器值达到0"></a>等待计数器值达到0</h2><p>当某一个线程调用awite方法时，线程会阻塞直到CountDownLatch计数器被扣减为1，实际上就是不断循环查询计数器值，直到为0时返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 如果计数器为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (getCount() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    RFuture&lt;RedissonCountDownLatchEntry&gt; future = subscribe();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计数器大于0，就等待计数器为0的消息，循环判断直到计数器到0</span></span><br><span class="line">        <span class="keyword">while</span> (getCount() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// waiting for open state</span></span><br><span class="line">            future.getNow().getLatch().await();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unsubscribe(future);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信号量-Semaphore&quot;&gt;&lt;a href=&quot;#信号量-Semaphore&quot; class=&quot;headerlink&quot; title=&quot;信号量 Semaphore&quot;&gt;&lt;/a&gt;信号量 Semaphore&lt;/h1&gt;&lt;p&gt;Redisson提供分布式信号量，接口和用法与juc</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Redission" scheme="https://haifuns.com/tags/Redission/"/>
    
  </entry>
  
  <entry>
    <title>【字符串匹配】Rabin-Karp 算法</title>
    <link href="https://haifuns.com/2021/12/15/stringmatch-02/"/>
    <id>https://haifuns.com/2021/12/15/stringmatch-02/</id>
    <published>2021-12-15T15:05:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>与朴素字符串匹配算法相同，Rabin-Karp 算法也是通过滑动一个大小为m的窗口n-m+1次进行匹配判断，不同之处在于Rabin-Karp 算法把字符串转换为字符集长度进制的哈希值，由数值比较代替了字符串直接比较，并且在匹配过程中利用了上一次匹配的信息。</p><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><p>给定一个模式P[1…m]，假设p表示其对应的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container>进制（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container>为字符集长度）值，相应的，给定文本T[1…n]，假设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>表示长度为m的子字符串T[s+1…s+m]所对应的的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container>进制值，只有在T[s+1…s+m] = P[1…m]时，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container> = p。如果能在O(m)时间计算出p值，并且在总时间O(n-m+1)内计算出所有<code>$t_s$</code>值，那么通过比较p和每一个<code>$t_s$</code>值，就能在O(m) - O(n-m+1) = O(n) </p><p>对于模式P[1…m]数值计算公式为：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.819ex" xmlns="http://www.w3.org/2000/svg" width="30.828ex" height="6.712ex" role="img" focusable="false" viewBox="0 -1720.9 13626.1 2966.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2028,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2472.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(2884.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3551.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(4607.2,0)"><g data-mml-node="mo" transform="translate(40.3,0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(188.4,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(0,1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1656,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="msup" transform="translate(6298.4,0)"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="TeXAtom" transform="translate(673,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(1656,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2045,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2390,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3168,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3668,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g><g data-mml-node="mi" transform="translate(9890.1,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(10323.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(10899.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(11428.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11879.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(12268.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(13237.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><ul><li>P为模式字符串</li><li>m为P的长度</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container>为字符集长度也就是多少进制</li><li>char(*) 得到当前字符对应的进制数</li></ul><p>例如字符集[0,1,2…9]，为十进制，那么字符串“123”计算方式为：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.819ex" xmlns="http://www.w3.org/2000/svg" width="58.18ex" height="6.712ex" role="img" focusable="false" viewBox="0 -1720.9 25715.7 2966.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2028,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2472.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(2884.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3551.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(4607.2,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(148.2,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(545.2,1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="msup" transform="translate(6217.9,0)"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="TeXAtom" transform="translate(673,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(1278,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1667,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2012,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2790,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3290,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g><g data-mml-node="mi" transform="translate(9542.3,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(9975.3,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(10551.3,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(11080.3,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11531.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(11920.3,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(12889.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(13556.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(14611.8,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mn" transform="translate(1033,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(16270.6,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mn" transform="translate(16992.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(17715.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(18715.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(19937.5,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mn" transform="translate(20659.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(21382,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(22382.2,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(23160,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(24215.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container></p><p>当我们已经知道了上一个窗口的数值时，可以在此基础上计算当前窗口数值：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="55.32ex" height="2.666ex" role="img" focusable="false" viewBox="0 -883.9 24451.4 1178.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2028,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2472.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(3106.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4107.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4607.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5273.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(6329.7,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="mo" transform="translate(6969.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7358.7,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(8246.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(8635.7,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(9386.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(9831.3,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(10243.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(10854.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(11854.8,0)"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="TeXAtom" transform="translate(673,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1656,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mi" transform="translate(14102.3,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(14535.3,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(15111.3,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(15640.3,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(16091.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(16480.3,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(17496.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(17885.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(18496.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(19497.1,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(19930.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(20506.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(21035.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(21486.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(21875.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1190,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(24062.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>在不考虑p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>值很大的情况下，计算p复杂度为O(m)，计算所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>复杂度为O(n)。</p><p>当考虑到p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>值很大的情况下，在计算p时的每次算术计算所需时间不再为常数时间，此时，可以选取一个合适的模q来计算出p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>的模。可以在O(m)的时间计算出模q的p值，并且可以在O(n-m+1)时间内计算出模q的所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>值，此时hash计算函数调整为：</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.819ex" xmlns="http://www.w3.org/2000/svg" width="30.828ex" height="6.712ex" role="img" focusable="false" viewBox="0 -1720.9 13626.1 2966.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2028,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2472.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(2884.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3551.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(4607.2,0)"><g data-mml-node="mo" transform="translate(40.3,0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(188.4,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(0,1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1656,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="msup" transform="translate(6298.4,0)"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="TeXAtom" transform="translate(673,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(1656,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2045,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2390,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3168,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3668,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g><g data-mml-node="mi" transform="translate(9890.1,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(10323.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(10899.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(11428.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11879.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(12268.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(13237.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="57.08ex" height="2.666ex" role="img" focusable="false" viewBox="0 -883.9 25229.4 1178.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(2028,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2472.7,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(3106.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4107.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4607.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5273.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(6329.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6718.7,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="mo" transform="translate(7358.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7747.7,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(8635.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(9024.7,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(9775.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(10220.3,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(10632.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(11243.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(12243.8,0)"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="TeXAtom" transform="translate(673,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(878,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1656,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mi" transform="translate(14491.3,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(14924.3,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(15500.3,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(16029.3,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(16480.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(16869.3,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(17885.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(18274.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(18885.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(19886.1,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(20319.1,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(20895.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(21424.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(21875.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(22264.1,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(675,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1190,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mo" transform="translate(24451.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(24840.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>但是基于模q得到的结果并不完美，模q的p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>不相等可以断定p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>不相等，模q的p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>相等并不能说明p和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex" xmlns="http://www.w3.org/2000/svg" width="1.755ex" height="1.772ex" role="img" focusable="false" viewBox="0 -626 775.6 783.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container>相等，还需要进一步检测。在这种最终形态下，算法预处理时间复杂度为O(m)，最坏情况下，匹配时间复杂度为O((n-m+1)m)。</p><p>在许多实际应用中，我们希望有效偏移的个数少一些（如只有常数c个），此时加上处理未命中点所需时间，算法的期望匹配时间为 O((n-m+1) + cm) = O(n+m)。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarpStringMatcher</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定字符集字符数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String txt = <span class="string">"我爱北京天安门，天安门在北京，北京城在北方"</span>;</span><br><span class="line">        String pat = <span class="string">"北京"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash值对q取模</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        search(pat, txt, q);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(String pat, String txt, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">// 模式hash值</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 文本hash值</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进制数m-1次幂</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) {</span><br><span class="line">            h = (h * d) % q;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算第一个窗口hash值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            p = (d * p + pat.charAt(i)) % q;</span><br><span class="line">            t = (d * t + txt.charAt(i)) % q;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滑动窗口匹配</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查模式和当前窗口hash值</span></span><br><span class="line">            <span class="keyword">if</span> (p == t) {</span><br><span class="line">                <span class="comment">// 检查所有字符</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (txt.charAt(i + j) != pat.charAt(j))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// p == t and pat[0...m-1] = txt[i, i+1, ...i+m-1]</span></span><br><span class="line">                <span class="keyword">if</span> (j == m) {</span><br><span class="line">                    System.out.println(<span class="string">"有效偏移量："</span> + i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一个窗口hash值</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - m) {</span><br><span class="line">                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + m)) % q;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// hash为负处理为正</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; <span class="number">0</span>) {</span><br><span class="line">                    t = (t + q);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>算法导论</li><li><a href="https://www.cnblogs.com/christianl/p/13747580.html">Rabin-Karp算法概述</a></li><li>Rabin-Karp 算法数值计算的通俗理解参考这篇文章：<a href="https://www.cnblogs.com/golove/p/3234673.html">Rabin-Karp 算法（字符串快速查找）</a></li><li>代码参考：<a href="https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/">https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与朴素字符串匹配算法相同，Rabin-Karp 算法也是通过滑动一个大小为m的窗口n-m+1次进行匹配判断，不同之处在于Rabin-Karp 算法把字符串转换为字符集长度进制的哈希值，由数值比较代替了字符串直接比较，并且在匹配过程中利用了上一次匹配的信息。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="文本匹配" scheme="https://haifuns.com/tags/%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【字符串匹配】暴力匹配算法</title>
    <link href="https://haifuns.com/2021/12/15/stringmatch-01/"/>
    <id>https://haifuns.com/2021/12/15/stringmatch-01/</id>
    <published>2021-12-15T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>字符串匹配问题是指在一个大字符串T中查找另一个字符串S出现的所有位置，其中T、S都是定义在有限字符集合上的字符串。</p><p>字符串匹配的典型应用场景是在文本中查找特定关键字，用来有效解决这个问题的算法就是<em>字符串匹配算法</em>。在很多其他应用中字符串匹配算法也有所应用，例如：用来在DNA序列中查找特定序列；在网络搜索引擎中查找网页地址等。</p><p>进一步定义字符串匹配问题如下：假设文本是一个长度为n的数据T[1…n]，而模式是一个长度为m的数组P[1…m]，其中m &lt;= n，T和P中的元素都来自一个有限字符集<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.633ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 722 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container>，<br>当0 &lt;= s &lt;= n-m，并且T[s+1…s+m] = P[1…m]（即T[s+j] = P[j]，其中1 &lt;= j  &lt;= m），那么称模式P在文本T中出现，且偏移量为s。字符串匹配问题就是找到所有有效偏移。</p><p>常见的字符串匹配算法如下：</p><ul><li>暴力匹配算法</li><li>Rabin-Karp 算法</li><li>DFA 算法（确定性有穷自动机）</li><li>KMP 算法</li><li>AC 自动机</li></ul><p>符号约定：</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.621ex" height="1.565ex" role="img" focusable="false" viewBox="0 -691.8 1158.6 691.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(722,0)"><g data-mml-node="msup"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(33,363) scale(0.707)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g></g></g></g></g></svg></mjx-container>表示所有有限长度的字符串集合，该字符串由字母表<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.633ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 722 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="3A3" d="M666 247Q664 244 652 126T638 4V0H351Q131 0 95 0T57 5V6Q54 12 57 17L73 36Q89 54 121 90T182 159L305 299L56 644L55 658Q55 677 60 681Q63 683 351 683H638V679Q640 674 652 564T666 447V443H626V447Q618 505 604 543T559 605Q529 626 478 631T333 637H294H189L293 494Q314 465 345 422Q400 346 400 340Q400 338 399 337L154 57Q407 57 428 58Q476 60 508 68T551 83T575 103Q595 125 608 162T624 225L626 251H666V247Z"></path></g></g></g></svg></mjx-container>中的字符组成</p><h1 id="朴素字符串匹配"><a href="#朴素字符串匹配" class="headerlink" title="朴素字符串匹配"></a>朴素字符串匹配</h1><p>暴力匹配算法比较直接，就是在文本中模式可能出现的任何地方检查匹配是否存在。即在[0,n-m]范围内通过循环偏移量s，检测是否满足T[s+1…s+m] = P[1…m]，从而找到所有有效偏移。</p><p>在最坏情况下，朴素字符串匹配算法时间复杂度为O((n-m+1)m)。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeStringMatcher</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        String text = <span class="string">"我爱北京天安门，天安门在北京，北京城在北方"</span>;</span><br><span class="line">        String pattern = <span class="string">"北京"</span>;</span><br><span class="line"></span><br><span class="line">        search(pattern, text);</span><br><span class="line">        search2(pattern, text);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; n - m + <span class="number">1</span>; s++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">                <span class="keyword">if</span> (txt.charAt(s + i) != pat.charAt(i)) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"有效偏移量："</span> + s);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 另一种实现，显式回退</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search2</span><span class="params">(String pat, String txt)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里s不再是偏移量而是文本中已经匹配的最后一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>, i = <span class="number">0</span>; s &lt; n &amp;&amp; i &lt; m; s++) {</span><br><span class="line">            <span class="keyword">if</span> (txt.charAt(s) == pat.charAt(i)) {</span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"有效偏移量："</span> + (s - i));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                s = s - i;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字符串匹配问题是指在一个大字符串T中查找另一个字符串S出现的所有位置，其中T、S都是定义在有限字符集合上的字符串。&lt;/p&gt;
&lt;p&gt;字符串匹配的典型应用场景是在文本中查找特定关键字，用来有效解决这个问题的算法就是&lt;em&gt;字符串匹配算法&lt;/em&gt;。在很多其他应用中字符串匹配算法</summary>
      
    
    
    
    <category term="算法" scheme="https://haifuns.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="文本匹配" scheme="https://haifuns.com/tags/%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>【Redission源码】读写锁源码解析</title>
    <link href="https://haifuns.com/2021/12/15/redission-04/"/>
    <id>https://haifuns.com/2021/12/15/redission-04/</id>
    <published>2021-12-14T16:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Redission支持可重入读写锁RReadWriteLock，允许同时有多个读锁或者一个写锁处于加锁状态。RReadWriteLock实现了juc.lock.ReadWriteLock接口，其中读锁和写锁都继承了RLock接口。</p><p>RReadWriteLock使用方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RReadWriteLock rwlock = redisson.getReadWriteLock(<span class="string">"anyRWLock"</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br></pre></td></tr></tbody></table></figure><p>为了解决死锁问题，在读写锁中依然使用看门狗机制不断延长有效期，默认超时时间为30秒。</p><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h2><p>在Redission读写锁中，读锁在以下情况可以加锁成功：</p><ol><li>无锁或者其他线程只加过读锁</li><li>同一个线程重复加读锁</li><li><strong>同一线程先加写锁后加读锁</strong></li></ol><p>与可重入锁相比，读写锁锁结构有所不同，hash中存在一个标记锁模式的field以及多个标记加锁线程的field，所以在读锁加锁时，lua脚本存在差异：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">                            <span class="comment">// 读锁情况锁结构</span></span><br><span class="line">                            <span class="comment">// 1. 两个线程加读锁，"lock1": {"mode": "read", "uuid1:thread1": 1, "uuid1:thread1": 1}</span></span><br><span class="line">                            <span class="comment">// 2. 同一个线程重入加读锁，"lock1": {"mode": "read", "uuid1:thread1": 1, "uuid1:thread1": 2}</span></span><br><span class="line">                            <span class="comment">// 3. 同一个线程先加写锁后加读锁 **，"lock1": {"mode": "read", "uuid1:thread1": 1, "uuid1:thread1:write": 1}</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// hash key=lock name 锁名，field=mode 锁模式</span></span><br><span class="line">                            <span class="string">"local mode = redis.call('hget', KEYS[1], 'mode'); "</span> +</span><br><span class="line">                            <span class="comment">// 如果模式为空，说明没有加过读写锁</span></span><br><span class="line">                            <span class="string">"if (mode == false) then "</span> +</span><br><span class="line">                              <span class="comment">// 设置模式为读锁</span></span><br><span class="line">                              <span class="string">"redis.call('hset', KEYS[1], 'mode', 'read'); "</span> +</span><br><span class="line">                              <span class="comment">// 新增锁，hash key=lock name，field=uuid:threadId，value=1</span></span><br><span class="line">                              <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                              <span class="comment">// 新增一个读锁标记 key={lock name}:uuid:threadId:rwlock_timeout:1，value=1</span></span><br><span class="line">                              <span class="string">"redis.call('set', KEYS[2] .. ':1', 1); "</span> +</span><br><span class="line">                              <span class="comment">// 设置过期时间，默认30秒</span></span><br><span class="line">                              <span class="string">"redis.call('pexpire', KEYS[2] .. ':1', ARGV[1]); "</span> +</span><br><span class="line">                              <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                              <span class="string">"return nil; "</span> +</span><br><span class="line">                            <span class="string">"end; "</span> +</span><br><span class="line">                            <span class="comment">// 如果是读锁模式，或者是当前线程加的写锁</span></span><br><span class="line">                            <span class="string">"if (mode == 'read') or (mode == 'write' and redis.call('hexists', KEYS[1], ARGV[3]) == 1) then "</span> +</span><br><span class="line">                              <span class="comment">// 重入锁，field=uuid:threadId，值加1</span></span><br><span class="line">                              <span class="comment">// 这里hash key是可以设置多个lock field，也就是可以加多个读锁</span></span><br><span class="line">                              <span class="string">"local ind = redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                              <span class="comment">// {lock name}:uuid:threadId:rwlock_timeout:锁重入次数</span></span><br><span class="line">                              <span class="string">"local key = KEYS[2] .. ':' .. ind;"</span> +</span><br><span class="line">                              <span class="comment">// 设置重入标记 {lock name}:uuid:threadId:rwlock_timeout:当前重入次数</span></span><br><span class="line">                              <span class="string">"redis.call('set', key, 1); "</span> +</span><br><span class="line">                              <span class="string">"redis.call('pexpire', key, ARGV[1]); "</span> +</span><br><span class="line">                              <span class="string">"local remainTime = redis.call('pttl', KEYS[1]); "</span> +</span><br><span class="line">                              <span class="comment">// 更新过期时间</span></span><br><span class="line">                              <span class="string">"redis.call('pexpire', KEYS[1], math.max(remainTime, ARGV[1])); "</span> +</span><br><span class="line">                              <span class="string">"return nil; "</span> +</span><br><span class="line">                            <span class="string">"end;"</span> +</span><br><span class="line">                            <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                    <span class="comment">// KEY[1] lock name，KEY[2] {lock name}:uuid:threadId:rwlock_timeout</span></span><br><span class="line">                    Arrays.&lt;Object&gt;asList(getRawName(), getReadWriteTimeoutNamePrefix(threadId)),</span><br><span class="line">                    <span class="comment">// ARGV[1] 超时时间 默认30秒，ARGV[2] uuid:threadId，ARGV[3] uuid:threadId:write</span></span><br><span class="line">                    unit.toMillis(leaseTime), getLockName(threadId), getWriteLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="watchdog维持读锁"><a href="#watchdog维持读锁" class="headerlink" title="watchdog维持读锁"></a>watchdog维持读锁</h2><p>由于读写锁结构不同于一般可重入锁，所以watchdog维持锁的lua脚本也有所不同：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    String timeoutPrefix = getReadWriteTimeoutNamePrefix(threadId);</span><br><span class="line">    String keyPrefix = getKeyPrefix(threadId, timeoutPrefix);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 获取重入次数</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hget', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">            <span class="string">"if (counter ~= false) then "</span> +</span><br><span class="line">                <span class="comment">// 不为空说明正常加锁，更新锁过期时间</span></span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                </span><br><span class="line">                <span class="string">"if (redis.call('hlen', KEYS[1]) &gt; 1) then "</span> +</span><br><span class="line">                    <span class="string">"local keys = redis.call('hkeys', KEYS[1]); "</span> + </span><br><span class="line">                    <span class="string">"for n, key in ipairs(keys) do "</span> + </span><br><span class="line">                        <span class="comment">// 遍历锁hash所有field，找到uuid:threadId的值，也即重入次数</span></span><br><span class="line">                        <span class="string">"counter = tonumber(redis.call('hget', KEYS[1], key)); "</span> + </span><br><span class="line">                        <span class="string">"if type(counter) == 'number' then "</span> + </span><br><span class="line">                            <span class="string">"for i=counter, 1, -1 do "</span> + </span><br><span class="line">                                <span class="comment">// 重置所有重入标记过期时间</span></span><br><span class="line">                                <span class="string">"redis.call('pexpire', KEYS[2] .. ':' .. key .. ':rwlock_timeout:' .. i, ARGV[1]); "</span> + </span><br><span class="line">                            <span class="string">"end; "</span> + </span><br><span class="line">                        <span class="string">"end; "</span> + </span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                </span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return 0;"</span>,</span><br><span class="line">        <span class="comment">// KEY[1] lock name，KEY[2] {lock name}:uuid:threadId</span></span><br><span class="line">        Arrays.&lt;Object&gt;asList(getRawName(), keyPrefix),</span><br><span class="line">        <span class="comment">// ARGV[1] 默认超时时间30秒，ARGV[2] uuid:threadId</span></span><br><span class="line">        internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="解锁读锁"><a href="#解锁读锁" class="headerlink" title="解锁读锁"></a>解锁读锁</h2><p>在读锁进行解锁时，需要删除或者减少当前线程读锁重入次数，并且更新过期时间：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    String timeoutPrefix = getReadWriteTimeoutNamePrefix(threadId);</span><br><span class="line">    String keyPrefix = getKeyPrefix(threadId, timeoutPrefix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 获取锁模式</span></span><br><span class="line">            <span class="string">"local mode = redis.call('hget', KEYS[1], 'mode'); "</span> +</span><br><span class="line">            <span class="string">"if (mode == false) then "</span> +</span><br><span class="line">                <span class="comment">// 模式不存在说明锁不存在，直接发布解锁消息，返回成功</span></span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 获取当前线程持有锁重入次数</span></span><br><span class="line">            <span class="string">"local lockExists = redis.call('hexists', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">            <span class="string">"if (lockExists == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 重入次数 - 1</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[2], -1); "</span> + </span><br><span class="line">            <span class="string">"if (counter == 0) then "</span> +</span><br><span class="line">                <span class="comment">// 如果解锁前只重入了一次，说明可以解锁了，直接删除field</span></span><br><span class="line">                <span class="string">"redis.call('hdel', KEYS[1], ARGV[2]); "</span> + </span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="comment">// 删除标记 {lock name}:uuid:threadId:rwlock_timeout:最后一次重入</span></span><br><span class="line">            <span class="string">"redis.call('del', KEYS[3] .. ':' .. (counter+1)); "</span> +</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果hash中的字段数量大于1</span></span><br><span class="line">            <span class="string">"if (redis.call('hlen', KEYS[1]) &gt; 1) then "</span> +</span><br><span class="line">                <span class="string">"local maxRemainTime = -3; "</span> + </span><br><span class="line">                <span class="comment">// 获得hash key = lock name所有field</span></span><br><span class="line">                <span class="string">"local keys = redis.call('hkeys', KEYS[1]); "</span> + </span><br><span class="line">                <span class="string">"for n, key in ipairs(keys) do "</span> + </span><br><span class="line">                    <span class="comment">// 遍历field，就是在找field = uuid:threadId，得到重入次数</span></span><br><span class="line">                    <span class="string">"counter = tonumber(redis.call('hget', KEYS[1], key)); "</span> + </span><br><span class="line">                    <span class="string">"if type(counter) == 'number' then "</span> + </span><br><span class="line">                        <span class="string">"for i=counter, 1, -1 do "</span> + </span><br><span class="line">                            <span class="comment">// 从1开始遍历到重入次数，得到所有{lock name}:uuid:threadId:rwlock_timeout:x的过期时间</span></span><br><span class="line">                            <span class="string">"local remainTime = redis.call('pttl', KEYS[4] .. ':' .. key .. ':rwlock_timeout:' .. i); "</span> + </span><br><span class="line">                            <span class="comment">// 找到所有重入标记中ttl最大值</span></span><br><span class="line">                            <span class="string">"maxRemainTime = math.max(remainTime, maxRemainTime);"</span> + </span><br><span class="line">                        <span class="string">"end; "</span> + </span><br><span class="line">                    <span class="string">"end; "</span> + </span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// 如果所有重入标记最大超时时间大于0，说明锁还有重入次数</span></span><br><span class="line">                <span class="string">"if maxRemainTime &gt; 0 then "</span> +</span><br><span class="line">                    <span class="comment">// 把标记的最大过期时间设置给锁</span></span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], maxRemainTime); "</span> +</span><br><span class="line">                    <span class="string">"return 0; "</span> +</span><br><span class="line">                <span class="string">"end;"</span> + </span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 如果模式为写锁，直接返回失败</span></span><br><span class="line">                <span class="string">"if mode == 'write' then "</span> + </span><br><span class="line">                    <span class="string">"return 0;"</span> + </span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 否则，说明可以解锁，直接删除锁，发布一条解锁消息</span></span><br><span class="line">            <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">            <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">            <span class="string">"return 1; "</span>,</span><br><span class="line">            <span class="comment">// key[1] lock name，key[2] redisson_rwlock:{lock name}，key[3] {lock name}:uuid:threadId:rwlock_timeout，key[4] {lock name}:uuid:threadId</span></span><br><span class="line">            Arrays.&lt;Object&gt;asList(getRawName(), getChannelName(), timeoutPrefix, keyPrefix),</span><br><span class="line">            <span class="comment">// ARGV[1] 解锁消息通道，ARGV[2] uuid:threadId</span></span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>Redission的读写锁中，写锁只有在以下情况才能加锁成功：</p><ol><li>没有任何线程加过锁</li><li>同一个线程重复加写锁</li></ol><h2 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h2><p>加写锁时相对简单，只需要判断是否加过锁、是否是当前线程加过写锁：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">                        <span class="comment">// 写锁情况锁结构</span></span><br><span class="line">                        <span class="comment">// 1. 无锁加写锁，"lock1": {"mode": "write", "uuid1:thread1:write": 1}</span></span><br><span class="line">                        <span class="comment">// 2. 同一个线程重入加写锁，"lock1": {"mode": "write", "uuid1:thread1:write": 2}</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取锁的模式</span></span><br><span class="line">                        <span class="string">"local mode = redis.call('hget', KEYS[1], 'mode'); "</span> +</span><br><span class="line">                        <span class="comment">// 如果获取不到说明没加过锁，直接添加锁、设置写锁模式、设置过期时间</span></span><br><span class="line">                        <span class="string">"if (mode == false) then "</span> +</span><br><span class="line">                              <span class="string">"redis.call('hset', KEYS[1], 'mode', 'write'); "</span> +</span><br><span class="line">                              <span class="comment">// hash key = lock name，field = uuid:threadId:write</span></span><br><span class="line">                              <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                              <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                              <span class="string">"return nil; "</span> +</span><br><span class="line">                          <span class="string">"end; "</span> +</span><br><span class="line">                          <span class="comment">// 如果锁的模式是写锁</span></span><br><span class="line">                          <span class="string">"if (mode == 'write') then "</span> +</span><br><span class="line">                              <span class="comment">// 如果写锁是当前线程加的，那么就把重入次数加1，更新过期时间</span></span><br><span class="line">                              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                                  <span class="string">"local currentExpire = redis.call('pttl', KEYS[1]); "</span> +</span><br><span class="line">                                  <span class="string">"redis.call('pexpire', KEYS[1], currentExpire + ARGV[1]); "</span> +</span><br><span class="line">                                  <span class="string">"return nil; "</span> +</span><br><span class="line">                              <span class="string">"end; "</span> +</span><br><span class="line">                            <span class="string">"end;"</span> +</span><br><span class="line">                            <span class="comment">// 其他情况加锁失败，返回过期时间</span></span><br><span class="line">                            <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                    <span class="comment">// KEY[1] lock name</span></span><br><span class="line">                    Arrays.&lt;Object&gt;asList(getRawName()),</span><br><span class="line">                    <span class="comment">// ARGV[1] 过期时间，ARGV[2] uuid:threadId:write</span></span><br><span class="line">                    unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="watchdog维持写锁"><a href="#watchdog维持写锁" class="headerlink" title="watchdog维持写锁"></a>watchdog维持写锁</h2><p>写锁结构与普通可重入锁结构一致，watchdog机制同RedissonLock，不再复述。</p><h2 id="写锁解锁"><a href="#写锁解锁" class="headerlink" title="写锁解锁"></a>写锁解锁</h2><p>当只有写锁解锁时，要么直接删除锁，要么减少写锁重入次数并且更新过期时间。当既有写锁又有读锁时，锁模式为写锁模式，在需要删除写锁时，还需要把锁模式转变为读模式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 查询锁模式</span></span><br><span class="line">            <span class="string">"local mode = redis.call('hget', KEYS[1], 'mode'); "</span> +</span><br><span class="line">            <span class="string">"if (mode == false) then "</span> +</span><br><span class="line">                <span class="comment">// 如果锁不存在，直接发布解锁消息</span></span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="comment">// 如果模式是写锁</span></span><br><span class="line">            <span class="string">"if (mode == 'write') then "</span> +</span><br><span class="line">                <span class="comment">// 查看当前线程加的写锁重入次数</span></span><br><span class="line">                <span class="string">"local lockExists = redis.call('hexists', KEYS[1], ARGV[3]); "</span> +</span><br><span class="line">                <span class="comment">// 如果是空，直接返回</span></span><br><span class="line">                <span class="string">"if (lockExists == 0) then "</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                    <span class="comment">// 如果写锁重入次数不是空，直接减1</span></span><br><span class="line">                    <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">                    <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                        <span class="comment">// 如果可重入了多次，更新过期时间返回</span></span><br><span class="line">                        <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                        <span class="string">"return 0; "</span> +</span><br><span class="line">                    <span class="string">"else "</span> +</span><br><span class="line">                        <span class="comment">// 如果只加了一次读锁，当前解锁写锁后还有可能存在读锁，需要把加锁模式转换为读锁</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 直接删除写锁 </span></span><br><span class="line">                        <span class="string">"redis.call('hdel', KEYS[1], ARGV[3]); "</span> +</span><br><span class="line">                        <span class="comment">// 如果hash里只剩下field mode，直接删除锁</span></span><br><span class="line">                        <span class="string">"if (redis.call('hlen', KEYS[1]) == 1) then "</span> +</span><br><span class="line">                            <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                            <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> + </span><br><span class="line">                        <span class="string">"else "</span> +</span><br><span class="line">                            <span class="comment">// 如果hash里field大于1，把锁模式修改为读锁</span></span><br><span class="line">                            <span class="comment">// has unlocked read-locks</span></span><br><span class="line">                            <span class="string">"redis.call('hset', KEYS[1], 'mode', 'read'); "</span> +</span><br><span class="line">                        <span class="string">"end; "</span> +</span><br><span class="line">                        <span class="string">"return 1; "</span>+</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"end; "</span></span><br><span class="line">            + <span class="string">"return nil;"</span>,</span><br><span class="line">            <span class="comment">// KEY[1] lock name，KEY[2] redisson_rwlock:{lock name}</span></span><br><span class="line">    Arrays.&lt;Object&gt;asList(getRawName(), getChannelName()),</span><br><span class="line">    <span class="comment">// ARGV[1] 解锁标记，ARGV[2] 过期时间，ARGV[3] uuid:thread:write</span></span><br><span class="line">    LockPubSub.READ_UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redission支持可重入读写锁RReadWriteLock，允许同时有多个读锁或者一个写锁处于加锁状态。RReadWriteLock实现了juc.lock.ReadWriteLock接口，其中读锁和写锁都继承了RLock接口。&lt;/p&gt;
&lt;p&gt;RReadWriteLock</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Redission" scheme="https://haifuns.com/tags/Redission/"/>
    
  </entry>
  
  <entry>
    <title>【Redission源码】联锁&amp;红锁源码解析</title>
    <link href="https://haifuns.com/2021/12/14/redission-03/"/>
    <id>https://haifuns.com/2021/12/14/redission-03/</id>
    <published>2021-12-13T16:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联锁-MultiLock"><a href="#联锁-MultiLock" class="headerlink" title="联锁 MultiLock"></a>联锁 MultiLock</h1><p>Redisson提供分布式联锁RedissonMultiLock，可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 = redisson.getLock(<span class="string">"lock1"</span>);</span><br><span class="line">RLock lock2 = redisson.getLock(<span class="string">"lock2"</span>);</span><br><span class="line">RLock lock3 = redisson.getLock(<span class="string">"lock3"</span>);</span><br><span class="line"></span><br><span class="line">RedissonMultiLock lock = <span class="keyword">new</span> RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 所有的锁都上锁成功才算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></tbody></table></figure><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>RedissonMultiLock加锁时默认超时时间为锁个数 * 1.5秒，循环调用每个锁的加锁逻辑，如果加锁失败或者超时，就会把已经加锁成功的所有锁同步等待解锁。实际加锁处理逻辑如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lockInterruptibly();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    lockInterruptibly(-<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 默认等待时间为每个锁1.5秒</span></span><br><span class="line">    <span class="keyword">long</span> baseWaitTime = locks.size() * <span class="number">1500</span>;</span><br><span class="line">    <span class="keyword">long</span> waitTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime == -<span class="number">1</span>) {</span><br><span class="line">        waitTime = baseWaitTime;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) {</span><br><span class="line">            newLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) {</span><br><span class="line">        remainTime = unit.toMillis(waitTime);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span><br><span class="line">    <span class="comment">// 成功加锁集合</span></span><br><span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span><br><span class="line">    <span class="comment">// 遍历所有锁，挨个执行加锁</span></span><br><span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) {</span><br><span class="line">        RLock lock = iterator.next();</span><br><span class="line">        <span class="keyword">boolean</span> lockAcquired;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) {</span><br><span class="line">                lockAcquired = lock.tryLock();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 默认超时时间为锁个数 * 1.5秒，默认不过期</span></span><br><span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span><br><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (RedisResponseTimeoutException e) {</span><br><span class="line">            unlockInner(Arrays.asList(lock));</span><br><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lockAcquired) {</span><br><span class="line">            <span class="comment">// 加锁成功添加到成功集合</span></span><br><span class="line">            acquiredLocks.add(lock);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不允许失败，并且当前加锁失败了</span></span><br><span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 把所有加锁成功的锁解锁</span></span><br><span class="line">                unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                failedLocksLimit = failedLocksLimit();</span><br><span class="line">                acquiredLocks.clear();</span><br><span class="line">                <span class="comment">// reset iterator</span></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) {</span><br><span class="line">                    iterator.previous();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                failedLocksLimit--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 整个联锁超时时间 = 锁个数 * 1.5秒 - 当前加锁耗费时间</span></span><br><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果超时，解锁已经加成功的锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) {</span><br><span class="line">                unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) {</span><br><span class="line">        acquiredLocks.stream()</span><br><span class="line">                .map(l -&gt; (RedissonLock) l)</span><br><span class="line">                .map(l -&gt; l.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS))</span><br><span class="line">                .forEach(f -&gt; f.syncUninterruptibly());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>RedissonMultiLock释放锁逻辑非常简单，循环释放所有锁，同步等待所有锁释放完毕后结束。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    List&lt;RFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RLock lock : locks) {</span><br><span class="line">        futures.add(lock.unlockAsync());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RFuture&lt;Void&gt; future : futures) {</span><br><span class="line">        future.syncUninterruptibly();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="红锁-RedLock"><a href="#红锁-RedLock" class="headerlink" title="红锁 RedLock"></a>红锁 RedLock</h1><h2 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h2><p>由于在Redis主从同步架构中普通锁可能出现安全失效问题，异常场景如下：</p><ol><li>客户端A从master获取到了锁</li><li>在master将锁同步到slave之前，master宕机</li><li>slave节点晋升为master节点</li><li>客户端B获取同一把锁成功</li></ol><p>为了解决以上问题，Redis官方提供了一种RedLock算法。</p><p>RedLock算法假设有N个Redis master节点，这些节点完全独立，不存在主从复制或者其他集群协调机制。</p><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>获取锁步骤如下：</p><ol><li>获取当前时间戳，单位毫秒</li><li>轮流尝试在每个节点使用相同的key和随机值加锁，设定一个小于锁失效时间的超时时间（例如锁自动失效时间为10秒，则超时时间在5-50毫秒之间）</li><li>客户端使用当前时间 - 步骤1获得的时间得到获取锁的使用时间，当且仅当多数节点加锁成功，并且使用时间小于锁失效时间，则加锁成功</li><li>如果加锁成功，锁真正的有效时间 = 过期时间 - 获取锁的使用时间</li><li>如果获取锁失败，客户端应该在所有节点解锁</li></ol><h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>当客户端获取锁失败时，需要在一个随机延迟后重试，防止多个客户端同时抢夺同一资源的锁从而造成脑裂都无法获取锁。</p><p>理想情况下，客户端应该并发地向所有节点发送SET命令，以节省加锁耗费的时间，降低脑裂概率。同时，在获取锁失败时，应该尽快释放已经成功取到的锁。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>释放锁比较简单，客户端向所有节点发送释放锁命令，不需要关心节点是否已经加锁。</p><h2 id="RedissonRedLock"><a href="#RedissonRedLock" class="headerlink" title="RedissonRedLock"></a>RedissonRedLock</h2><p>RedissonRedLock继承自RedissonMultiLock，区别在于加锁逻辑中的两个变量：允许锁个数 / 2 - 1个锁加锁失败（也即要求多数加锁成功）；每个锁加锁超时时间为1.5秒。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">failedLocksLimit</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> locks.size() - minLocksAmount(locks);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">minLocksAmount</span><span class="params">(<span class="keyword">final</span> List&lt;RLock&gt; locks)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> locks.size()/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">calcLockWaitTime</span><span class="params">(<span class="keyword">long</span> remainTime)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Math.max(remainTime / locks.size(), <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;联锁-MultiLock&quot;&gt;&lt;a href=&quot;#联锁-MultiLock&quot; class=&quot;headerlink&quot; title=&quot;联锁 MultiLock&quot;&gt;&lt;/a&gt;联锁 MultiLock&lt;/h1&gt;&lt;p&gt;Redisson提供分布式联锁RedissonMultiLo</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Redission" scheme="https://haifuns.com/tags/Redission/"/>
    
  </entry>
  
  <entry>
    <title>【Redission源码】公平锁源码解析</title>
    <link href="https://haifuns.com/2021/12/13/redission-02/"/>
    <id>https://haifuns.com/2021/12/13/redission-02/</id>
    <published>2021-12-12T16:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Redission提供RedissonFairLock实现公平锁，使用方式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock fairLock = redisson.getFairLock(<span class="string">"anyLock"</span>);</span><br><span class="line">fairLock.lock();</span><br><span class="line">fairLock.unlock();</span><br></pre></td></tr></tbody></table></figure><p>RedissionFairLock可以保证当多个Residdion客户端线程同时请求加锁时，优先分配给先发起请求的线程。所有请求线程会在一个队列中排队，当某个线程宕机时，Redission会等待5秒后继续下一个线程。也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p><h1 id="排队加锁"><a href="#排队加锁" class="headerlink" title="排队加锁"></a>排队加锁</h1><p>RedissionFairLock继承自RedissionLock，加锁逻辑中重写了#tryLockInnerAsync方法，加锁lua有所不同，除了hash存放锁外，还存在一个list结构存在等待队列，一个zset结构存在等待队列timeout时间。详细处理如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> wait = threadWaitTime;</span><br><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) {</span><br><span class="line">        wait = unit.toMillis(waitTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (command == RedisCommands.EVAL_LONG) {</span><br><span class="line">        <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="comment">// remove stale threads</span></span><br><span class="line">                <span class="string">"while true do "</span> +</span><br><span class="line">                    <span class="comment">// 从等待队列redisson_lock_queue:{锁名}中获取第1个元素</span></span><br><span class="line">                    <span class="string">"local firstThreadId2 = redis.call('lindex', KEYS[2], 0);"</span> +</span><br><span class="line">                    <span class="comment">// 如果没有排队加锁的线程，就跳出循环执行加锁逻辑</span></span><br><span class="line">                    <span class="string">"if firstThreadId2 == false then "</span> +</span><br><span class="line">                        <span class="string">"break;"</span> +</span><br><span class="line">                    <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前线程剩余超时时间</span></span><br><span class="line">                    <span class="string">"local timeout = tonumber(redis.call('zscore', KEYS[3], firstThreadId2));"</span> +</span><br><span class="line">                    <span class="comment">// 如果超时时间小于当前时间，那么直接移除当前等待的线程</span></span><br><span class="line">                    <span class="string">"if timeout &lt;= tonumber(ARGV[4]) then "</span> +</span><br><span class="line">                        <span class="comment">// remove the item from the queue and timeout set</span></span><br><span class="line">                        <span class="comment">// NOTE we do not alter any other timeout</span></span><br><span class="line">                        <span class="string">"redis.call('zrem', KEYS[3], firstThreadId2);"</span> +</span><br><span class="line">                        <span class="string">"redis.call('lpop', KEYS[2]);"</span> +</span><br><span class="line">                    <span class="string">"else "</span> +</span><br><span class="line">                        <span class="string">"break;"</span> +</span><br><span class="line">                    <span class="string">"end;"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果锁不存在或者队列redisson_lock_queue:{锁名}不存在或者队列中第一个元素是uuid:threadId</span></span><br><span class="line">                <span class="comment">// check if the lock can be acquired now</span></span><br><span class="line">                <span class="string">"if (redis.call('exists', KEYS[1]) == 0) "</span> +</span><br><span class="line">                    <span class="string">"and ((redis.call('exists', KEYS[2]) == 0) "</span> +</span><br><span class="line">                        <span class="string">"or (redis.call('lindex', KEYS[2], 0) == ARGV[2])) then "</span> +</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// remove this thread from the queue and timeout set</span></span><br><span class="line">                    <span class="comment">// 从redisson_lock_queue:{锁名}中移除第一个元素</span></span><br><span class="line">                    <span class="string">"redis.call('lpop', KEYS[2]);"</span> +</span><br><span class="line">                    <span class="comment">// 从zset结构redisson_lock_timeout:{锁名}中弹出uuid:threadId</span></span><br><span class="line">                    <span class="string">"redis.call('zrem', KEYS[3], ARGV[2]);"</span> +</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历timeout zset，给每个元素减5秒</span></span><br><span class="line">                    <span class="comment">// decrease timeouts for all waiting in the queue</span></span><br><span class="line">                    <span class="string">"local keys = redis.call('zrange', KEYS[3], 0, -1);"</span> +</span><br><span class="line">                    <span class="string">"for i = 1, #keys, 1 do "</span> +</span><br><span class="line">                        <span class="string">"redis.call('zincrby', KEYS[3], -tonumber(ARGV[3]), keys[i]);"</span> +</span><br><span class="line">                    <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// add hash 锁名，field uuid:threadId，value 1</span></span><br><span class="line">                    <span class="comment">// 设置过期时间，默认30秒，返回空</span></span><br><span class="line">                    <span class="comment">// acquire the lock and set the TTL for the lease</span></span><br><span class="line">                    <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1);"</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]);"</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前线程已经加过锁了，就把value加1，更新过期时间，返回空</span></span><br><span class="line">                <span class="comment">// check if the lock is already held, and this is a re-entry</span></span><br><span class="line">                <span class="string">"if redis.call('hexists', KEYS[1], ARGV[2]) == 1 then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2],1);"</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]);"</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取当前线程等待超时时间，如果存在就返回剩余的超时时间</span></span><br><span class="line">                <span class="comment">// the lock cannot be acquired</span></span><br><span class="line">                <span class="comment">// check if the thread is already in the queue</span></span><br><span class="line">                <span class="string">"local timeout = redis.call('zscore', KEYS[3], ARGV[2]);"</span> +</span><br><span class="line">                <span class="string">"if timeout ~= false then "</span> +</span><br><span class="line">                    <span class="comment">// the real timeout is the timeout of the prior thread</span></span><br><span class="line">                    <span class="comment">// in the queue, but this is approximately correct, and</span></span><br><span class="line">                    <span class="comment">// avoids having to traverse the queue</span></span><br><span class="line">                    <span class="string">"return timeout - tonumber(ARGV[3]) - tonumber(ARGV[4]);"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add the thread to the queue at the end, and set its timeout in the timeout set to the timeout of</span></span><br><span class="line">                <span class="comment">// the prior thread in the queue (or the timeout of the lock if the queue is empty) plus the</span></span><br><span class="line">                <span class="comment">// threadWaitTime</span></span><br><span class="line">                <span class="comment">// 从等待队列里取出最后一个线程</span></span><br><span class="line">                <span class="string">"local lastThreadId = redis.call('lindex', KEYS[2], -1);"</span> +</span><br><span class="line">                <span class="string">"local ttl;"</span> +</span><br><span class="line">                <span class="string">"if lastThreadId ~= false and lastThreadId ~= ARGV[2] then "</span> +</span><br><span class="line">                    <span class="comment">// 最后一个线程等待ttl</span></span><br><span class="line">                    <span class="string">"ttl = tonumber(redis.call('zscore', KEYS[3], lastThreadId)) - tonumber(ARGV[4]);"</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                    <span class="comment">// 正在加锁的线程ttl</span></span><br><span class="line">                    <span class="string">"ttl = redis.call('pttl', KEYS[1]);"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line">                <span class="comment">// timeout = 上一个锁ttl + 30s + 当前时间</span></span><br><span class="line">                <span class="string">"local timeout = ttl + tonumber(ARGV[3]) + tonumber(ARGV[4]);"</span> +</span><br><span class="line">                <span class="comment">// 把当前线程添加到超时zset里，值为timeout</span></span><br><span class="line">                <span class="string">"if redis.call('zadd', KEYS[3], timeout, ARGV[2]) == 1 then "</span> +</span><br><span class="line">                    <span class="comment">// 把当前线程添加到等待队列</span></span><br><span class="line">                    <span class="string">"redis.call('rpush', KEYS[2], ARGV[2]);"</span> +</span><br><span class="line">                <span class="string">"end;"</span> +</span><br><span class="line">                <span class="string">"return ttl;"</span>,</span><br><span class="line">                <span class="comment">// key[1] 锁名；key[2] 等待队列 redisson_lock_queue:{锁名}；key[3] 超时zset redisson_lock_timeout:{锁名}</span></span><br><span class="line">                Arrays.asList(getRawName(), threadsQueueName, timeoutSetName),</span><br><span class="line">                <span class="comment">// ARGV[1] 超时时间；ARGV[2] field uuid:threadId；ARGV[3] 等待时间，默认5秒；ARGV[4] 当前时间</span></span><br><span class="line">                unit.toMillis(leaseTime), getLockName(threadId), wait, currentTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="可重入加锁"><a href="#可重入加锁" class="headerlink" title="可重入加锁"></a>可重入加锁</h1><p>RedissionFairLock公平锁可重入加锁逻辑同可重入锁RedissionFairLock，当加锁线程是当前线程，那么把lock key对应的field value值加1，然后更新lock key过期时间。</p><h1 id="超时重新入队"><a href="#超时重新入队" class="headerlink" title="超时重新入队"></a>超时重新入队</h1><p>如果当前线程已经加入等待队列开始排队，并且超过了等待时间（前面每个锁5秒），那么再次获取锁时，首先会移除当前线程（以及之前线程）在等待队列和超时集合中的值，然后尝试获取锁，如果获取锁失败会重新把当前线程添加到等待队列末尾，并且重新放到超时集合中，timeout为队列中最后一个线程超时时间 + 5秒。</p><h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>在解锁时，RedissionFairLock会先删除等待队列中已经超时的线程，然后开始处理解锁，如果被当前线程重入了多次就把value减1，否则直接删除锁，同时发布一条解锁消息通知订阅的等待线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// remove stale threads</span></span><br><span class="line">            <span class="string">"while true do "</span></span><br><span class="line">            + <span class="string">"local firstThreadId2 = redis.call('lindex', KEYS[2], 0);"</span></span><br><span class="line">            + <span class="string">"if firstThreadId2 == false then "</span></span><br><span class="line">                + <span class="string">"break;"</span></span><br><span class="line">            + <span class="string">"end; "</span></span><br><span class="line">            <span class="comment">// 删除等待队列中已经过期的线程</span></span><br><span class="line">            + <span class="string">"local timeout = tonumber(redis.call('zscore', KEYS[3], firstThreadId2));"</span></span><br><span class="line">            + <span class="string">"if timeout &lt;= tonumber(ARGV[4]) then "</span></span><br><span class="line">                + <span class="string">"redis.call('zrem', KEYS[3], firstThreadId2); "</span></span><br><span class="line">                + <span class="string">"redis.call('lpop', KEYS[2]); "</span></span><br><span class="line">            + <span class="string">"else "</span></span><br><span class="line">                + <span class="string">"break;"</span></span><br><span class="line">            + <span class="string">"end; "</span></span><br><span class="line">          + <span class="string">"end;"</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">// 如果锁不存在</span></span><br><span class="line">          + <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> + </span><br><span class="line">                <span class="string">"local nextThreadId = redis.call('lindex', KEYS[2], 0); "</span> + </span><br><span class="line">                <span class="string">"if nextThreadId ~= false then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('publish', KEYS[4] .. ':' .. nextThreadId, ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span> +</span><br><span class="line">            <span class="string">"end;"</span> +</span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 重入加锁处理</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 如果只重入了一次直接删除</span></span><br><span class="line">            <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">            <span class="string">"local nextThreadId = redis.call('lindex', KEYS[2], 0); "</span> + </span><br><span class="line">            <span class="string">"if nextThreadId ~= false then "</span> +</span><br><span class="line">                <span class="comment">// 发布一条解锁消息，通知等待加锁的线程</span></span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[4] .. ':' .. nextThreadId, ARGV[1]); "</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return 1; "</span>,</span><br><span class="line">            Arrays.asList(getRawName(), threadsQueueName, timeoutSetName, getChannelName()),</span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId), System.currentTimeMillis());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redission提供RedissonFairLock实现公平锁，使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Redission" scheme="https://haifuns.com/tags/Redission/"/>
    
  </entry>
  
  <entry>
    <title>【Redission源码】可重入锁源码解析</title>
    <link href="https://haifuns.com/2021/12/11/redission-01/"/>
    <id>https://haifuns.com/2021/12/11/redission-01/</id>
    <published>2021-12-11T15:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Redission提供的可重入锁RedissonLock实现了java.util.concurrent.locks.Lock接口，使用起来非常简单，示例如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>);</span><br><span class="line">lock.lock();</span><br></pre></td></tr></tbody></table></figure><p>同时，还支持指定锁超时时间、指定获取锁最大等待时间以及异步获取锁的方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁后10秒钟自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，加锁后10秒钟自动解锁</span></span><br><span class="line"><span class="keyword">boolean</span> res = lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加锁</span></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>);</span><br><span class="line">lock.lockAsync();</span><br><span class="line">lock.lockAsync(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res = lock.tryLockAsync(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></tbody></table></figure><p>接下来我们来探究一下RedissionLock可重入锁加锁原理。</p><h1 id="lua脚本加锁"><a href="#lua脚本加锁" class="headerlink" title="lua脚本加锁"></a>lua脚本加锁</h1><p>在调用#lock加锁时，redission会先尝试加锁，成功直接返回，失败就订阅锁状态变更消息，循环重试。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    Long ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 获取成功</span></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅解锁的消息</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">    <span class="keyword">if</span> (interruptibly) {</span><br><span class="line">        commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        commandExecutor.syncSubscription(future);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取锁失败就循环重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiting for message</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 等待解锁继续执行，超时时间为当前锁ttl</span></span><br><span class="line">                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) {</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    }</span><br><span class="line">                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (interruptibly) {</span><br><span class="line">                    future.getNow().getLatch().acquire();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    future.getNow().getLatch().acquireUninterruptibly();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 取消订阅锁状态消息</span></span><br><span class="line">        unsubscribe(future, threadId);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>核心加锁方法如下，使用lua加锁实现原子加锁，分布式缓存中的锁为hash结构，key为lock key，field 为 ConnectionManagerId:threadId（uuid:threadId），value为锁重入次数，过期时间默认为30s。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>{</span><br><span class="line">    <span class="comment">// 使用lua脚本加锁</span></span><br><span class="line">    <span class="comment">// KEYS[1] getLock指定的key，作为redis hash key</span></span><br><span class="line">    <span class="comment">// ARGV[1] LockWatchdogTimeout，默认过期时间，30s</span></span><br><span class="line">    <span class="comment">// ARGV[2] ConnectionManagerId:threadId uuid:threadId，作为redis field key</span></span><br><span class="line">    <span class="comment">// 如果hash key不存在，新增hash {key:{uuid:threadId:1}}，过期时间默认30s，返回空</span></span><br><span class="line">    <span class="comment">// 如果hash key.uuid:threadId存在，给field uuid:threadId的值加1，更新过期时间，返回空</span></span><br><span class="line">    <span class="comment">// 如果hash key存在，并且uuid:threadId不存在，说明已经被其他线程锁定，返回key过期时间</span></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                    <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                    <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在内部接下来的调用中可以看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T, R&gt; <span class="function">RFuture&lt;R&gt; <span class="title">evalWriteAsync</span><span class="params">(String key, Codec codec, RedisCommand&lt;T&gt; evalCommandType, String script, List&lt;Object&gt; keys, Object... params)</span> </span>{</span><br><span class="line">    <span class="comment">// 关键代码</span></span><br><span class="line">    NodeSource source = getNodeSource(key);</span><br><span class="line">    <span class="keyword">return</span> evalAsync(source, <span class="keyword">false</span>, codec, evalCommandType, script, keys, <span class="keyword">false</span>, params);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> NodeSource <span class="title">getNodeSource</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> slot = connectionManager.calcSlot(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NodeSource(slot);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterConnectionManager.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calcSlot</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = key.indexOf(<span class="string">'{'</span>);</span><br><span class="line">    <span class="keyword">if</span> (start != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">int</span> end = key.indexOf(<span class="string">'}'</span>);</span><br><span class="line">        <span class="keyword">if</span> (end != -<span class="number">1</span> &amp;&amp; start + <span class="number">1</span> &lt; end) {</span><br><span class="line">            key = key.substring(start + <span class="number">1</span>, end);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = CRC16.crc16(key.getBytes()) % MAX_SLOT;</span><br><span class="line">    log.debug(<span class="string">"slot {} for {}"</span>, result, key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从如上代码可以看到在发起请求之前Redission先基于key计算出了slot的位置（slot=CRC16(key)&amp;16383），在发起请求时，redission会从缓存中找到slot对应的redis节点直接向其发起请求，这样就可以节省一次重定向，这也是Redission作为smart client的体现。</p><h1 id="watchdog维持加锁"><a href="#watchdog维持加锁" class="headerlink" title="watchdog维持加锁"></a>watchdog维持加锁</h1><p>在加锁完成后，可以看到redission添加了一个更新锁过期时间的定时任务，每10秒钟过期一次，如果锁还在就更新过期时间。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// #lock加锁真实处理逻辑</span></span><br><span class="line">    ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line"></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁成功</span></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 加锁成功后维持锁定时任务</span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    ExpirationEntry entry = <span class="keyword">new</span> ExpirationEntry();</span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">     <span class="comment">// 如果当前锁没有续期任务就创建，如果已经存在就更新一下线程id</span></span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="keyword">null</span>) {</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            renewExpiration();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">                cancelExpirationRenewal(threadId);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 每10秒钟执行一次</span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 维持锁过期</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; {</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) {</span><br><span class="line">                    <span class="comment">// // 如果锁过期时间被更新了，就重新定义一个任务</span></span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 如果锁过期时间更新失败，说明锁已经释放了，释放任务</span></span><br><span class="line">                    cancelExpirationRenewal(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>维持锁过期时间也是使用了lua脚本，如果锁还在就更新过期时间为30秒。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 维持锁lua</span></span><br><span class="line">    <span class="comment">// 如果lock key存在managerId:threadId这个field，就更新锁过期时间</span></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return 1; "</span> +</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                    <span class="string">"return 0;"</span>,</span><br><span class="line">            Collections.singletonList(getRawName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>在需要释放锁时，redission会判断锁是否存在，锁重入次数是否小于等于1，满足条件就进行删除，然后向指定通道发送一条解锁消息，以通知获取锁的线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    get(unlockAsync(Thread.currentThread().getId()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果lock key.thread不存在，直接返回空</span></span><br><span class="line">    <span class="comment">// 如果lock key.thread存在，就把value先减1</span></span><br><span class="line">    <span class="comment">//      如果值大于0，说明不可以释放，重置过期时间返回0</span></span><br><span class="line">    <span class="comment">//      否则，说明可以解锁了，删除锁，向redisson_lock__channe:{lockkey}发布一条内容为0的消息，返回1</span></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span> +</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                    <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">                    <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                    <span class="string">"return 0; "</span> +</span><br><span class="line">                    <span class="string">"else "</span> +</span><br><span class="line">                    <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return 1; "</span> +</span><br><span class="line">                    <span class="string">"end; "</span> +</span><br><span class="line">                    <span class="string">"return nil;"</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="加锁超时与自动释放"><a href="#加锁超时与自动释放" class="headerlink" title="加锁超时与自动释放"></a>加锁超时与自动释放</h1><p>redission支持指定加锁超时时间以及锁过期时间，可以调用#tryLock(long waitTime, long leaseTime, TimeUnit unit)方法进行加锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 直接加锁，没有watchdog机制</span></span><br><span class="line">    Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果超时直接返回</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    current = System.currentTimeMillis();</span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大等待时间，如果指定时间没有收到解锁状态变更直接超时返回</span></span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {</span><br><span class="line">        <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) {</span><br><span class="line">            subscribeFuture.onComplete((res, e) -&gt; {</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) {</span><br><span class="line">                    unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果收到解锁消息就继续重试</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">            acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// waiting for message</span></span><br><span class="line">            currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) {</span><br><span class="line">                subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) {</span><br><span class="line">                acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        unsubscribe(subscribeFuture, threadId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结合不指定超时时间的加锁逻辑可以看到，在指定超时时间时redission不会设置watchdog机制进行锁续期，因为过期自动解锁时正常行为。此时解锁有锁过期自动删除和手动解锁两种情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redission提供的可重入锁RedissonLock实现了java.util.concurrent.locks.Lock接口，使用起来非常简单，示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="分布式锁" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
    <category term="Redission" scheme="https://haifuns.com/tags/Redission/"/>
    
  </entry>
  
  <entry>
    <title>分布式共识算法之Gossip协议</title>
    <link href="https://haifuns.com/2021/11/22/gossip/"/>
    <id>https://haifuns.com/2021/11/22/gossip/</id>
    <published>2021-11-22T12:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos、Raft、ZAB等分布式算法常被称为“强一致性”的分布式共识协议，其意思是尽管系统内部节点可以存在不一致的状态，但是从系统外部看，不一致情况不会被观测到，所以整体上看系统是强一致的。相对的，还有一类“最终一致”的分布式共识协议，表示系统中的不一致状态有可能会在一定时间内被外部观测到。</p><p>最终一致分布式共识协议的一个典型就是DNS协议，在各个节点缓存的ttl过期前是有可能与真实域名翻译结果不一致的情况。另一种具有代表性的则是在比特币网络和许多分布式系统中都有应用的Gossip协议。</p><p>Gossip协议源于施乐公司在论文中提出的一种用于分布式数据库在多节点间复制同步数据的算法，其特点是要同步的消息像流言一样传播、病毒一样扩散，因为也被称为“流言算法”、“瘟疫算法”等。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>Gossip算法的工作流程十分简单，如果有某一项信息需要在整个网络所有节点中传播可以看做是以下两个步骤的简单循环：</p><ul><li>从信息源开始，选择一个固定的传播周期（譬如1秒），随机选择与它相连的k个节点（称为Fan-Out）来传播消息。</li><li>每一个节点收到消息后，如果这个消息是它没收到过的，在下一个周期内，将在会在除发消息的节点外的其他相邻节点中选择k个发送相同的消息，直到最终网络中所有节点都收到了消息。</li></ul><p>尽管以上流程需要一定的时间，但是理论上最终网络中所有节点都会拥有相同的信息。</p><p>算法流程示意图如下所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/gossip.gif" alt="image"></p><p>从上图中我们可以看到Gossip协议对网络节点的连通性和稳定性几乎没有任何要求。Gossip将网络某些节点中能与部分节点连通而不是全网络节点连通作为前提，能够容忍网络上节点的随意增加或者减少、随意宕机或者重启，新增或者重启的节点最终会与其他节点同步达成一致。Gossip把网络中的节点平等看待，没有中心化或者主节点的概念，正因如此，Gossip具有极强的鲁棒性，非常适合在公众网络中使用。</p><p>Gossip的缺点也是显而易见的：</p><ul><li>消息是经过多个轮次的散播到达网络中所有节点的，必然存在各个节点状态不一致的情况。</li><li>由于随机选择发送消息的节点，所以尽管可以在整体上测算出统计学意义上的传播速率，但是对于个体消息而言，无法准确地预计需要多长时间才能达到全网一致。</li><li>由于随机选择发送消息的节点，不可避免的存在重复消息发送给同一个节点的情况，消息冗余带来的是网络传输的压力，也给消息节点带来额外的负载。</li></ul><p>达到一致性耗费的时间与网络传输中消息冗余这两个缺点对立，鱼与熊掌不能兼得，因此，Gossip设计了两种可能的消息传播模式：</p><ul><li>反熵模式，同步的所有数据以消除各个节点之间的差异，目标是整个网络各个节点完全一致，但是在节点本身就会发生变动的前提下，这个目标会使得整个网络中消息的数量非常庞大。</li><li>传谣模式，以传播消息为目标，仅仅发送新达到节点的数据，即只对外发送变更数据，此模式下消息数据量将会显著减少，网络开销也相对较小。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Paxos、Raft、ZAB等分布式算法常被称为“强一致性”的分布式共识协议，其意思是尽管系统内部节点可以存在不一致的状态，但是从系统外部看，不一致情况不会被观测到，所以整体上看系统是强一致的。相对的，还有一类“最终一致”的分布式共识协议，表示系统中的不一致状态有可能会在一</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式共识算法之ZAB协议</title>
    <link href="https://haifuns.com/2021/11/22/zab/"/>
    <id>https://haifuns.com/2021/11/22/zab/</id>
    <published>2021-11-22T12:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<p>ZAB协议，即ZooKeeper Atomic Broadcast，ZooKeeper原子消息广播协议，是分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。</p><p>ZAB协议与Paxos算法不完全相同，它不是一种通用的分布式一致性算法，而是一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法。</p><p>在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。</p><p>ZAB协议的核心是定义了对于那些会改变ZooKeeper服务器数据状态的事务请求的处理方式，即：所有事务请求必须由一个全局唯一的Leader服务器来协调，其他的服务器为Follower服务器。Leader服务器负责将客户端事务请求转换为一个事务Proposal（提议），并将此Proposal分发给集群中所有的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader服务器就会再次向所有的Follower服务器发送Commit消息，要求其将前一个Proposal进行提交。</p><h1 id="协议模式"><a href="#协议模式" class="headerlink" title="协议模式"></a>协议模式</h1><p>ZAB协议包含两种基本的模式，分别是崩溃恢复和消息广播。</p><p>当分布式系统启动，或者当Leader服务器网络中断、崩溃退出、重启等异常情况时，ZAB协议会进入恢复模式并选举产生新的Leader服务器。当Leader服务器被选出后，同时集群中超过半数的机器与Leader服务器完成状态同步后，ZAB协议就会退出恢复模式进入消息广播模式。当一台机器新加入集群时，这台服务器会进入数据恢复模式，从Leader服务器进行数据同步，同步完成后参与到消息广播流程中。</p><h2 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h2><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。</p><p>当客户端发起事务请求，Leader服务器会为其生成事务Proposal，对应一个全局唯一且单调递增的事务id（zxid，64位包含时间戳和计数器两部分），并按照zxid顺序将事务Proposal广播给其他所有Follower机器，如果收到超过半数的Follower的ACK响应，就广播事务提交消息。</p><p>ZAB协议中的二阶段提交过程是一种简化模型，Leader服务器在得到超过半数Follower服务器反馈ACK后就可以开始提交事务Proposal，而不需要等待集群中所有的Follower服务器都反馈响应。这种简化模型无法处理Leader服务器崩溃退出带来的数据不一致问题，因此ZAB协议中添加了崩溃恢复模式来解决这个问题。</p><h2 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h2><p>在进行故障恢复时，ZAB协议需要保证以下两个特性：</p><ul><li>确保已经在Leader服务器上提交的事务最终被所有服务器提交</li><li>确保丢弃只在Leader服务器上被提出的事务</li></ul><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>ZAB协议包含消息广播和故障恢复两个过程，进一步可以细分为三个阶段：</p><ul><li>发现（Discovery）</li><li>同步（Synchronization）</li><li>广播（Broadcast）</li></ul><h2 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h2><p>发现阶段主要就是Leader选举的过程，用于在多个分布式进程中选举出主进程，准Leader L和Follower F 的工作流程分别如下：</p><ul><li>F.1.1，Follower F将自己最后接受的事务Proposal的epoch值发送给准Leader L。</li><li>L.1.1，当接收到超过半数Follower的epoch消息后，准Leader L会生成一个新的epoch e’ （e’为最大的epoch+1）发送给这些过半的Follower。</li><li>F.1.2，当Follower收到L的新epoch后，如果当前自己的epoch小于收到的值，那么就接受新值，同时向L发送ACK消息，ACK消息中包含epoch值和当前Follower的历史事务Proposal集合。</li><li>L.1.2，当L收到过半Follower的ACK消息之后，会从Quorum中选择一个Follower，将其事务集合中作为初始化事务集合Ie’，被选择的Follower需要满足epoch大于等于其他Follower，并且事务集合需要满足zxid最大。</li></ul><h2 id="同步阶段"><a href="#同步阶段" class="headerlink" title="同步阶段"></a>同步阶段</h2><p>在发现阶段完成后，就进入了同步阶段，在这一阶段，Leader L和Follower F的工作流程如下所示：</p><ul><li>L.2.1，Leader L将e’和选择的初始化事务集合Ie’以NEWLEADER(e’,Ie’)的形式发送给所有Quorum中的Follower。</li><li>F.2.1，当Follower接收到来自L的NEWLEADER(e’,Ie’)消息后，<ul><li>如果epoch != e’，那么直接进入下一轮循环，因为此时Follower还在上一轮或者更上轮，无法参与此轮同步。</li><li>如果epoch = e’，那么Follower会执行事务操作。最后Follower会反馈给Leader，表明自己已经接受并处理了所有的Ie’中的事务。</li></ul></li><li>F.2.2，当Leader收到超过半数Follower针对NEWLEADER的反馈消息后，就会向所有Follower发送Commit消息。至此，Leader完成同步阶段。</li><li>L.2.2，当Follower收到来自Leader的Commit消息后，就会依次处理并提交之前接受的Ie’中的事务。至此，Follower完成同步阶段。</li></ul><blockquote><p>此阶段是ZAB协议中相对Paxos算法额外添加的，能够有效的保证Leader在新的周期中提出Proposal之前，所有的进程都已经完成了对之前所有事务的提交。</p></blockquote><h2 id="广播阶段"><a href="#广播阶段" class="headerlink" title="广播阶段"></a>广播阶段</h2><p>完成同步阶段后，ZAB协议就可以正式开始接受客户端新的事务请求，并进行广播流程。</p><ul><li>L.3.1，Leader接收到客户端新的事务请求后，会生成对应的事务Proposal，并根据ZXID的顺序向所有Follower发送提案。</li><li>F.3.1，Follower根据消息接收的先后顺序来处理来自Leader的事务Proposal，并追加到已接受的事务Proposal集合，之后再反馈给Leader。</li><li>L.3.2，当Leader接收到超过半数的Follower针对事务Proposal的ACK消息后，就会发送相应的Commit消息给所有的Follower，要求它们进行事务提交。</li><li>F.3.2，Follower接收到来自Leader的Commit消息后，就会提交相应的事务Proposal。</li></ul><p>算法流程图如下所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/zab.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ZAB协议，即ZooKeeper Atomic Broadcast，ZooKeeper原子消息广播协议，是分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。&lt;/p&gt;
&lt;p&gt;ZAB协议与Paxos算法不完全相同，它不是一种通用的分布式一致性算法，而是一</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式共识算法之Raft算法</title>
    <link href="https://haifuns.com/2021/11/18/raft/"/>
    <id>https://haifuns.com/2021/11/18/raft/</id>
    <published>2021-11-18T12:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<p>Raft算法是一种等价派生于Multi Paxos的分布式共识算法，它源自于题为《In Search of an Understandable Consensus Algorithm》的论文，后来成为Etcd、LogCabin、Consul等重要分布式系统的理论基础。</p><h1 id="如何达到分布式共识"><a href="#如何达到分布式共识" class="headerlink" title="如何达到分布式共识"></a>如何达到分布式共识</h1><p>Raft算法论文论证了当以下三个问题同时被解决时，即等价于达成共识：</p><ul><li>如何选主（Leader Election）</li><li>如何把数据复制到各个节点（Entity Replication）</li><li>如何保证过程是安全的（Safety）</li></ul><h2 id="如何选主"><a href="#如何选主" class="headerlink" title="如何选主"></a>如何选主</h2><p>前篇Paxos算法详尽介绍了选主的原理，尽管选主问题的实际工程实践中还涉及很多细节，譬如心跳、随机超时、并行竞选等，其本质还是对分布式系统对“谁当主节点”这件事达成共识，不妨碍我们理解。</p><h2 id="如何把数据复制到各个节点"><a href="#如何把数据复制到各个节点" class="headerlink" title="如何把数据复制到各个节点"></a>如何把数据复制到各个节点</h2><p>这里我们需要讨论一下数据（Paxos中的提案、Raft中的日志）在各个网络节点间的复制问题：</p><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><p>在正常情况下，当客户端向主节点发起一个操作请求，主节点会先写入自己的变更日志，但是不提交，接着把变更信息在下一个心跳包中广播给所有从节点，并要求从节点回复确认收到的消息，从节点收到消息后，将操作写入自己的变更日志，然后给主节点发送确认签收的消息，主节点在收到多数签收消息后，提交自己的变更、应答客户端并且给从节点广播可以提交的消息，从节点收到提交消息后提交自己的变更，此时数据在节点间的复制就完成了。</p><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>在异常情况下，网络出现分区，部分节点失联，但是只要仍能工作的节点满足过半数的要求，分布式系统就仍然可以正常工作，此时，数据复制过程如下：</p><p>假设S1、S2、S3、S4、S5五个节点，S1是主节点，由于网络故障导致S1、S2和S3、S4、S5之间无法通信，形成网络分区。</p><p>一段时间后，S3、S4、S5中的某一个节点（假设是S3）先达到心跳超时阈值，此时S3发起竞选主节点广播并收到S4、S5两个节点的批准响应，加上自己的一票达到了多数派的要求，竞选成功，此时系统中存在S1和S3两个主节点，由于网络分区，它们不知道对方的存在。</p><p>此时如果客户端发起操作请求会有以下两种情况：</p><ul><li>如果客户端连接到S1、S2之一，都将由S1处理，由于操作只能获取两个节点的响应，没有达到多数派的要求，所以任何变更都无法更改。</li><li>如果客户端连接到S3、S4、S5之一，都将由S3处理，此时操作可以满足多数派响应，变更可以被提交，系统可以正常提供服务。</li></ul><blockquote><p>网络分区是由于软、硬件或网络故障构成，内部网络出现分区，但两个分区仍能分别与外部网络中的客户端正常通信的情况非常少见。所以以上两种情况很少能同时出现，更多的场景是算法能容忍网络里下线了部分节点。</p></blockquote><p>假设之后故障恢复，网络分区解除，五个节点恢复通信，此时S1、S3都会向所有节点发送心跳包，从各自的心跳中可以得知S3的任期编号更大，此时五个节点都会承认S3是唯一的主节点，S1、S2会回滚它们所有没有提交的变更，然后从S3的心跳包中获得失联期间所有的变更，将变更写入本地磁盘，此时分布式系统从网络分区中恢复，各个节点的状态达到最终一致。</p><h2 id="如何保证过程安全"><a href="#如何保证过程安全" class="headerlink" title="如何保证过程安全"></a>如何保证过程安全</h2><p>在分布式理论中有两个描述安全性的预定义术语：</p><ul><li>协定性（Safety）：所有的坏事都不会发生（something “bad” will never happen）</li><li>终止性（Liveness）：所有的好事都终将发生，但不知道是啥时候（something “good” will must happen, but we don’t know when）</li></ul><p>术语太过晦涩，以选主问题举例，Safety要保证选主的结果一定是有且只有一个主节点，不可能同时出现两个主节点。Liveness则要保证选举过程一定在某个时刻可以结束。在Liveness整个属性上选主问题存在理论上的瑕疵，即可能由于活锁问题导致无法选出主节点，在Raft论文中只对Safety做了保证，但是由于工程实现上的处理，现实中几乎不会出现终止性问题。</p><h1 id="Raft算法动画演示"><a href="#Raft算法动画演示" class="headerlink" title="Raft算法动画演示"></a>Raft算法动画演示</h1><ul><li>英文版：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li><li>中文版：<a href="http://www.kailing.pub/raft/index.html">http://www.kailing.pub/raft/index.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Raft算法是一种等价派生于Multi Paxos的分布式共识算法，它源自于题为《In Search of an Understandable Consensus Algorithm》的论文，后来成为Etcd、LogCabin、Consul等重要分布式系统的理论基础。&lt;/p</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式共识算法之Multi Paxos算法</title>
    <link href="https://haifuns.com/2021/11/17/multi-paxos/"/>
    <id>https://haifuns.com/2021/11/17/multi-paxos/</id>
    <published>2021-11-17T13:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<p>分布式共识的复杂性主要来源于网络的不可靠和请求可并发两个因素。相应的，Basic Paxos算法的活锁问题（两个提案节点互不相让地争相提出自己的提案，抢占同一个值的修改权限，导致整个系统持续性地“反复横跳”，在外部看就像是被锁住了一样），以及许多Basic Paxos异常场景中的问题，都源于任何一个提案都能完全平等地与其他节点并发地提出提案而带来的复杂问题。</p><p>为此，Lamport提出了一种Paxos的改进版本，<strong>“Multi Paxos”算法，其目的是在既不破坏Paxos中“众节点平等”的原则，又能在提案节点中实现主次之分，限制每个节点都有不受控的提案权利</strong>。</p><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>Multi Paxos对Basic Paxos的核心改进是增加了“选主”的过程。提案节点通过定时轮询（心跳），确定当前网络中所有节点里是否存在一个主提案节点，如果不存在主节点，那么节点会在心跳超时之后使用Basic Paxos中定义的准备、批准的两轮网络交互过程，向其他所有节点广播竞选主节点的请求。如果得到了多数派决策节点的批准，那么就认为竞选成功。</p><p>在选主完成后，除非主节点失联后重新竞选，否则从此以后就只有主节点本身才能发起提案。此时，无论是哪个提案节点收到客户端的操作请求，都会将请求转发给主节点来完成提案，<strong>主节点的提案过程中无需再进行准备过程，因为可以视为经过选举时的一次准备之后，后续的提案都是对相同提案ID的一连串批准过程</strong>。</p><blockquote><p>在选主完成后，不存在其他节点与主节点竞争，相当于处在无并发环境中进行有序操作，此时系统中要对某个值达成一致只需要一轮批准交互。</p></blockquote><p>此时算法流程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/multi-paxos-01.png" alt="image"></p><p>如上图所示，请求中Accept请求中多了一个i，i为主节点的“任期编号”，任期编号必须是单调递增的，用于应对主节点陷于网络分区中恢复，但是另外一部分节点仍然有多数派且已经完成选举的情况。此时必须以任期编号大的主节点为准。</p><p>当节点有了选主机制，从整体上看，节点角色不再区分为提案节点、决策节点、记录节点，而是同样的角色，只有主和从的区别。</p><p>此时算法流程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/multi-paxos-02.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式共识的复杂性主要来源于网络的不可靠和请求可并发两个因素。相应的，Basic Paxos算法的活锁问题（两个提案节点互不相让地争相提出自己的提案，抢占同一个值的修改权限，导致整个系统持续性地“反复横跳”，在外部看就像是被锁住了一样），以及许多Basic Paxos异常场</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式共识算法之Paxos算法</title>
    <link href="https://haifuns.com/2021/11/17/paxos/"/>
    <id>https://haifuns.com/2021/11/17/paxos/</id>
    <published>2021-11-17T04:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos是Leslie Lamport提出的一种基于消息传递的协商共识算法，现已是当今分布式系统最重要的理论基础。</p><h1 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h1><p>Paxos算法将分布式系统中的节点分为三类：</p><ul><li>提案节点（Proposer），提出对某个值进行设置操作的节点，设置值的行为称为提案，值一旦设置成功就是不会丢失也是不可变的。</li><li>决策节点（Acceptor），应答提案的节点，决定该提案是否可以被投票、是否可以被接受。提案一旦得到半数决策节点接受，即称为该提案被批准，提案被批准意味着该值不能再更改也不会丢失，且最终所有节点都会接受它。</li><li>记录节点（Learner），不参与提案，也不参与决策，只是从提案、决策节点学习已经达成共识的提案。例如少数派节点从网络分区中恢复时将会进入这种状态。</li></ul><p>在使用Paxos的分布式系统中，所有节点都是平等的，它们可以承担一种或者多种角色。需要注意的是，为了确保有明确的多数派，决策节点的数量应该被设置为奇数个，且在系统初始化时，网络中每个节点都需要知道整个网络中的决策节点的数量、地址等信息。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>Paxos算法包含准备和批准两个阶段来协商已达成共识。</p><h2 id="准备（Prepare）阶段"><a href="#准备（Prepare）阶段" class="headerlink" title="准备（Prepare）阶段"></a>准备（Prepare）阶段</h2><p>准备阶段相当于分布式系统中锁抢占的过程。如果某个提案节点准备发起提案，必须先向所有决策节点广播一个许可申请（称为Prepare请求）。Parepare请求中包含一个全局唯一的数字n作为提案ID，决策节点收到请求后，将会给予提案节点两个承诺和一个应答。</p><p>两个承诺指：</p><ul><li>承诺不会再接受提案ID小于或等于n的Prepare请求。</li><li>承诺不会再接受提案ID小于n的Accept请求（下一阶段）。</li></ul><p>一个应答指：</p><ul><li>在不违背以上承诺的前提下，回复已经批准过的提案ID中最大的提案所设定的值，如果从未被设定过就返回空。如果违反此前做出的承诺，即收到的提案ID不是决策节点收到过最大的，那么不会对此Prepare请求作出应答。</li></ul><h2 id="批准（Accept）阶段"><a href="#批准（Accept）阶段" class="headerlink" title="批准（Accept）阶段"></a>批准（Accept）阶段</h2><p>当提案节点收到多数派节点的应答（称为Promise应答）后，就开始第二阶段即批准阶段。此时可能有以下两种可能：</p><ul><li>如果提案节点发现所有响应的决策节点此前都没有批准过其他提案（即返回空），那么说明它是第一个设置值得节点，可以随意的决定要设置的值，此时提案节点会将自己选定的值与提案ID组成一个二元组(id,value)结构，再次广播给所有的决策节点（称为Accept请求）。</li><li>如果提案节点收到的响应中至少有一个应答已经有值了，那么就不能随意取值，必须从响应中找到提案ID最大的值并接受，组成一个二元组(id,value)结构，再次广播给所有的决策节点。</li></ul><p>每一个决策节点在收到Accept请求时，都会在不违背此前承诺的前提下，接受并持久化对当前提案ID对应的值。如果违背承诺，即收到的提案ID不是收到的Prepare请求中最大的，那么不会理会此Accept请求。</p><p>当提案节点收到了多数派决策节点的应答（称为 Accepted 应答）后，协商结束，共识决议形成，将形成的决议发送给所有记录节点进行学习。整个过程时序图如下所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/paxos01.png" alt="image"></p><h1 id="工作实例"><a href="#工作实例" class="headerlink" title="工作实例"></a>工作实例</h1><p>假设在一个分布式系统中包含五个节点（正常通信场景，不涉及网络分区），记为S1、S2、S3、S4、S5，其中每个节点都同时扮演提案节点和决策节点。</p><p>某一时刻，有两个并发请求分别希望将同一个值设定为X（S1节点提案）和Y（S5节点提案），以P表示准备阶段，以A表示批准阶段，此时有可能发生以下几种情况：</p><p><strong>情况1</strong>：S1选定提案ID是3.1，先取得了多数派决策节点的Promise和Accepted应答，此时S5选定的提案ID为4.5，发起Prepare请求，此时收到的多数派应答中至少会包含一个此前已经应答过S1的决策节点，假设为S3，那么S3返回的应答中必将包含S1已经设定的值X，S5就必须无条件地使用X代替Y作为自己的提案值，此时整个系统对“取值为X”这个事实达成一致。如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/paxos-example-01.png" alt="image"></p><p><strong>情况2</strong>：对于情况1，X被选定为最终值是必然结果，从上图可以看出X被选定为最终值并不是必定经过多数派批准，只取决于S5提案时得到的Promise应答中是否包含批准过X值的决策节点，例如下图所示，当S5发起提案的Prepare请求时，X并为获得多数派批准，但由于S3已经批准，最终共识结果仍然是X。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/paxos-example-02.png" alt="image"></p><p><strong>情况3</strong>：S5提案时Promise应答中不包含批准过X的决策节点，例如应答S5提案时，节点S1已经批准了X，节点S2、S3未批准但返回了Promise应答，此时S5以更大的提案ID获得了S3、S4、S5的Promise应答，这三个节点均未批准过任何值，那么S3将不会再接收来自S1的Accept请求，因为S1的提案ID已经不是最大的了，这三个节点将批准Y的取值，整个系统最终将会对取值“Y”达成一致，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/paxos-example-03.png" alt="image"></p><p><strong>情况4</strong>：从情况3可以推导出一种极端情况，如果两个提案节点交替使用最大ID使得准备阶段成功，但是批准阶段失败，那么就会形成活锁（Live Lock），如下图所示。在算法实现中需要引入随机超时机制来避免活锁的产生。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distributed/paxos/paxos-example-04.png" alt="image"></p><p>以上是基于Basic Paxos、以未出现网络分区的正常流程进行讲解Paxos算法。Basic Paxos的价值在于开拓了分布式共识算法的发展思路，但是它仍存在以下缺陷，一般不会直接用于实践：Basic Paxos只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准），在高并发情况下将会产生较大的网络开销，极端情况下甚至可能形成活锁。在实际的应用中都是基于Multi Paxos和Fast Paxos算法以及一些等价的算法（如Raft、ZAB等）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Paxos是Leslie Lamport提出的一种基于消息传递的协商共识算法，现已是当今分布式系统最重要的理论基础。&lt;/p&gt;
&lt;h1 id=&quot;节点分类&quot;&gt;&lt;a href=&quot;#节点分类&quot; class=&quot;headerlink&quot; title=&quot;节点分类&quot;&gt;&lt;/a&gt;节点分类&lt;/h1</summary>
      
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Databus简介</title>
    <link href="https://haifuns.com/2021/08/12/databus/"/>
    <id>https://haifuns.com/2021/08/12/databus/</id>
    <published>2021-08-12T13:50:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>在互联网架构中，数据系统通常可以分为真实数据系统以及衍生数据系统。前者作为基础数据库存储用户产生的写操作，后者通常复制自主数据并对数据进行转换或业务处理，提供读取和其他复杂查询操作。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/dataflow.png" alt="dataflow"></p><h1 id="数据同步方案"><a href="#数据同步方案" class="headerlink" title="数据同步方案"></a>数据同步方案</h1><p>以缓存数据为例，缓存数据来自主数据，当主数据发生变化时，缓存中的数据也需要随之更新。要实现数据同步有两种常用解决方案：应用驱动双写和数据库日志挖掘。</p><h2 id="应用双写"><a href="#应用双写" class="headerlink" title="应用双写"></a>应用双写</h2><p>应用双写指在写数据到DB时，同时写入缓存。但是应用双写存在数据不一致的情况，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-redis.png" alt="image"></p><p>另外，在变更DB后更新缓存时，如果出现操作失败的情况，也有可能造成数据不一致。在需要保证严格数据一致时，使用应用双写策略并不容易实现。</p><h2 id="日志挖掘"><a href="#日志挖掘" class="headerlink" title="日志挖掘"></a>日志挖掘</h2><p>日志挖掘通过提取数据库变更日志实现数据同步，这从根本上解决了数据一致性问题。如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-flow.png" alt="image"></p><span id="more"></span><h1 id="Databus-概述"><a href="#Databus-概述" class="headerlink" title="Databus 概述"></a>Databus 概述</h1><p>Databus是LinkedIn于2013年开源的低延迟数据变更抓取系统。Databus支持端到端毫秒级别的延时，每台服务器每秒可处理数千更改事件，同时支持无限回溯并且有丰富的订阅功能。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-usecases.jpg" alt="image"></p><p>如上图所示，搜索引擎和只读副本等系统充当事件消费者，当主OLTP数据库发生写入时，连接到此数据库的中继服务会将更改事件同步给事件消费者，从而实现索引或副本与源数据保持一致。</p><h1 id="Databus-功能特性"><a href="#Databus-功能特性" class="headerlink" title="Databus 功能特性"></a>Databus 功能特性</h1><ul><li>来源独立：Databus支持Oracle和Mysql两种数据源变更抓取，并且数据变更的抓取独立于数据源，不会对数据源产生影响。</li><li>可扩展、高可用：Databus可扩展支持数千消费者和事务数据来源，同时保持高度可用。</li><li>事务按序提交：Databus能保持来源数据库的事务完整性，并按照事务分组和来源提交顺序交付变更事件。</li><li>低延时、支持多种订阅机制：数据源变更完成后，Databus能在毫秒级别将事务提交给消费者。同时，消费者使用Databus中的服务端过滤功能可以只获取需要的特定数据。</li><li>无限回溯：Databus支持消费者无限回溯功能。</li></ul><h1 id="Databus-日志挖掘原理"><a href="#Databus-日志挖掘原理" class="headerlink" title="Databus 日志挖掘原理"></a>Databus 日志挖掘原理</h1><h2 id="Mysql-知识回顾"><a href="#Mysql-知识回顾" class="headerlink" title="Mysql 知识回顾"></a>Mysql 知识回顾</h2><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>Mysql中的二进制日志文件（binary log）记录了对数据库执行更改的所有操作，但是不包含SELECT和SHOW这类操作。</p><p>binlog主要有以下几种作用：</p><ul><li>恢复：通过binlog进行数据恢复。</li><li>复制：通过复制和执行binlog实现主从同步。</li><li>审计：通过binlog判断是否有对数据库进行注入的攻击。</li></ul><p>binlog的日志格式由binlog_format参数控制，可选格式有STATMENT、ROW、MIXED。区别如下：</p><ul><li>STATMENT：记录日志的逻辑SQL语句，此格式在某些情况下可能会导致主从数据不一致。例如使用rand、uuid等函数，或者使用触发器。另外在使用RC事务隔离级别时会出现丢失更新的现象从而导致主从数据不一致。</li><li>ROW：记录表的行更改情况。</li><li>MIXED：以上两种格式混用。</li></ul><blockquote><p>在使用Databus时，binlog_format需要设置为ROW模式。</p></blockquote><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/mysql-replication.png" alt="image"></p><h2 id="Databus日志挖掘方式"><a href="#Databus日志挖掘方式" class="headerlink" title="Databus日志挖掘方式"></a>Databus日志挖掘方式</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-replication.png" alt="image"></p><h1 id="Databus-整体架构"><a href="#Databus-整体架构" class="headerlink" title="Databus 整体架构"></a>Databus 整体架构</h1><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-as-a-service.png" alt="image"></p><p>Databus系统的构成如上图所示，其中包括中继（Relay）、Bootstrap服务和客户端库。Bootstrap服务中包括Bootstrap Producer和Bootstrap Server。消费者从Relay中获取最新事件，如果一个消费者的数据更新大幅落后，就需要到Bootstrap Producer里获取，提交给它的将会是自消费者上次处理变更之后的所有数据变更快照。</p><p>Databus Relay的主要功能包括：</p><ol><li>从数据来源读取变更行，并在内存缓存内将其序列化为Databus变更事件。</li><li>监听来自Databus客户端（包括Bootstrap Producer）的请求，并传输新的Databus数据变更事件。</li></ol><p>Databus Client的功能主要包括：</p><ol><li>获取Relay上新的数据变更事件，并执行特定业务逻辑的回调。</li><li>如果落后Relay太多，向Bootstrap Server发起查询。</li><li>新Databus客户端会向Bootstrap Server发起Bootstrap启动查询，然后切换到向Relay发起查询，以完成最新的数据变更事件。</li><li>单一客户端可以处理整个Databus数据流，或者可以成为消费者集群的一部分，其中每个消费者只处理一部分流数据。</li></ol><p>Databus Bootstrap Producer的功能主要包括：</p><ol><li>检查Relay上的新数据变更事件。</li><li>将变更存储在MySQL数据库中。</li><li>MySQL数据库供Bootstrap和客户端使用。</li></ol><p>Databus Bootstrap Server的功能主要包括：</p><ol><li>监听来自Databus客户端的请求，并返回长期回溯数据变更事件。</li></ol><h1 id="Databus-Relay"><a href="#Databus-Relay" class="headerlink" title="Databus Relay"></a>Databus Relay</h1><p>Databus Relays主要功能如下：</p><ol><li>从源数据库中的读取变化的行并序列化为Databus中的更改事件保存在内存缓冲区中。</li><li>监听Databus客户端的请求，并将Databus中的更改事件传输到客户端。</li></ol><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-relays.png" alt="image"></p><h2 id="Event-Producer"><a href="#Event-Producer" class="headerlink" title="Event Producer"></a>Event Producer</h2><p>Event Producer会轮询数据库并读取源数据中变更的行然后转换为<a href="https://avro.apache.org/docs/current/">Apache Avro</a>记录。</p><p>从JDBC RowSets到AvroRecords的转换是根据存储在Schema Registry中的Avro Schemas完成的，然后AvroRecords被序列化成Databus事件。</p><h2 id="Event-Buffers"><a href="#Event-Buffers" class="headerlink" title="Event Buffers"></a>Event Buffers</h2><p>Databus Relays中有一个或多个Circular Buffer 循环事件缓冲区（内存或mmap内存映射文件），用于按系统更改号（SCN）递增的顺序存储数据总线事件。每个缓冲区对应一个SCN稀疏索引，以及一个MaxSCN读写器，MaxSCN读写器会定时保存Relays中的SCN最大值。Relays通过netty channel接收客户端请求，并由Request Processor处理。</p><blockquote><p>SCN（System Change Number）即事件序列号，占64位，其中高32位表示binlog文件编号，低32位表示binlog文件偏移量，这种实现方式在Mysql主节点发生变化（如DBA执行了reset master命令将binlog文件和偏移量重置）会导致逻辑序列被重置，简单的解决方案是只清理日志。在Mysql5.6.5+版本中增加了唯一全局事务id（GTID），使用ServerId + GTID作为SCN是一种更好的选择。</p></blockquote><h2 id="Databus-Relay-HA"><a href="#Databus-Relay-HA" class="headerlink" title="Databus Relay HA"></a>Databus Relay HA</h2><p>Databus Relay除了可以监听主库消费数据外，还可以进行监听其他Databus Relay进行链式消费。直接监听主库的Relay为领导者，监听领导者的Relay为跟随者。</p><p>Databus依靠<a href="http://helix.apache.org/">Apache Helix</a>进行集群管理。Helix是一种通用的集群管理框架，用于自动管理托管在节点集群上的分区，复制和分布式资源。Helix提供以下功能：</p><ul><li>将资源/分区自动分配给节点</li><li>节点故障检测和恢复</li><li>动态添加资源</li><li>动态添加节点到集群</li><li>可插拔分布式状态机通过状态转换来管理资源的状态</li><li>自动负载均衡和过渡节流</li></ul><h1 id="Databus-Clients"><a href="#Databus-Clients" class="headerlink" title="Databus Clients"></a>Databus Clients</h1><p>Databus Clients负责拉取Relays中的事件，处理后发送给感兴趣的消费者。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-clients.png" alt="image"></p><ul><li>Relay Puller：负责从Relay拉取数据，具体工作有挑选Relay，请求Source，请求Register，校验Schema，设置Dispatcher等。</li><li>Bootstrap Puller：负责从Bootstrap servers拉取数据，功能类似Relay Puller。</li><li>Dispatcher：从event buffers中读取事件，调用消费逻辑的回调，主要职责有：<ul><li>判断回调是否正确，回调失败后会进行重试，重试次数超限后抛出异常</li><li>监控错误和超时</li><li>持久化checkpoint</li></ul></li><li>Checkpoint persistence Provider：checkpoint是消费者消费变更记录点的位置，负责将checkpoint持久化到本地，保证下次启动后可以从正常的位置pull event。</li><li>Event Callback：调用消费者自定义业务逻辑代码。</li></ul><h2 id="Databus-Client-HA"><a href="#Databus-Client-HA" class="headerlink" title="Databus Client HA"></a>Databus Client HA</h2><p>Databus支持动态客户端负载均衡，当新的客户端加入或脱离集群时，分区动态重新分配给集群中所有客户端实例。集中写入的cheakpoint（通过Helix写到zookeeper）可以保证分区在客户端无缝移动。</p><h1 id="开源日志挖掘方案Databus-amp-Canal对比"><a href="#开源日志挖掘方案Databus-amp-Canal对比" class="headerlink" title="开源日志挖掘方案Databus&amp;Canal对比"></a>开源日志挖掘方案Databus&amp;Canal对比</h1><table><thead><tr><th>对比项</th><th>Databus</th><th>Canal</th></tr></thead><tbody><tr><td>开源公司</td><td>linkedin（13年开源，已停止维护，其内部转用brooklin）</td><td>alibaba（14年开源，最后更新时间4个月前）</td></tr><tr><td>数据源</td><td>MySQL、Oracle</td><td>MySQL（内部支持Oracle）</td></tr><tr><td>日志解析方式</td><td>open-replicator（开源）</td><td>Build-in（自研）</td></tr><tr><td>订阅/同步方式</td><td>（美团支持订阅方式：Mafka、RabbitMQ、Thrift、Http、Zebra）</td><td>官方同步Adapter ：Kafka、RocketMQ、HBase、RDB（MySQL/Oracle/PostgreSQL/SQLServer）、ES</td></tr><tr><td>Server</td><td>relay可以同时服务多个client</td><td>一个server instance只能服务一个clinet（受限于server端保存拉取位点）</td></tr><tr><td>Client</td><td>client可以拉取多个relay变更，访问的relay可以指定获取某些表某些分片的变更</td><td>client只能从一个server拉取变更，而且只能拉取全量变更</td></tr><tr><td>可扩展性</td><td>client支持线性扩展，支持动态分片</td><td>client不支持扩展</td></tr><tr><td>可用性</td><td>relay和client都支持集群模式，relay故障时主备切换，client故障时动态重新分配分区。relay可以订阅mysql主库或者从库不关心其主从角色</td><td>server和client都是主备模式，主挂备用接管。可以自动切换Mysql主从库</td></tr><tr><td>监控</td><td>提供JMX监控</td><td>支持prometheus监控</td></tr></tbody></table><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://sq.163yun.com/blog/article/173552201158811648">Databus架构分析与初步实践（for mysql）（上篇）</a></li><li><a href="https://engineering.linkedin.com/data-replication/open-sourcing-databus-linkedins-low-latency-change-data-capture-system">Open sourcing Databus: LinkedIn’s low latency change data capture system</a></li><li><a href="https://github.com/linkedin/databus/wiki">github/linkedin/databus/wiki</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h1&gt;&lt;p&gt;在互联网架构中，数据系统通常可以分为真实数据系统以及衍生数据系统。前者作为基础数据库存储用户产生的写操作，后者通常复制自主数据并对数据进行转换或业务处理，提供读取和其他复杂查询操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/dataflow.png&quot; alt=&quot;dataflow&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据同步方案&quot;&gt;&lt;a href=&quot;#数据同步方案&quot; class=&quot;headerlink&quot; title=&quot;数据同步方案&quot;&gt;&lt;/a&gt;数据同步方案&lt;/h1&gt;&lt;p&gt;以缓存数据为例，缓存数据来自主数据，当主数据发生变化时，缓存中的数据也需要随之更新。要实现数据同步有两种常用解决方案：应用驱动双写和数据库日志挖掘。&lt;/p&gt;
&lt;h2 id=&quot;应用双写&quot;&gt;&lt;a href=&quot;#应用双写&quot; class=&quot;headerlink&quot; title=&quot;应用双写&quot;&gt;&lt;/a&gt;应用双写&lt;/h2&gt;&lt;p&gt;应用双写指在写数据到DB时，同时写入缓存。但是应用双写存在数据不一致的情况，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-redis.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外，在变更DB后更新缓存时，如果出现操作失败的情况，也有可能造成数据不一致。在需要保证严格数据一致时，使用应用双写策略并不容易实现。&lt;/p&gt;
&lt;h2 id=&quot;日志挖掘&quot;&gt;&lt;a href=&quot;#日志挖掘&quot; class=&quot;headerlink&quot; title=&quot;日志挖掘&quot;&gt;&lt;/a&gt;日志挖掘&lt;/h2&gt;&lt;p&gt;日志挖掘通过提取数据库变更日志实现数据同步，这从根本上解决了数据一致性问题。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/databus/databus-flow.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日志挖掘" scheme="https://haifuns.com/categories/%E6%97%A5%E5%BF%97%E6%8C%96%E6%8E%98/"/>
    
    
    <category term="Databus" scheme="https://haifuns.com/tags/Databus/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：高级应用</title>
    <link href="https://haifuns.com/2021/06/06/kafka-09/"/>
    <id>https://haifuns.com/2021/06/06/kafka-09/</id>
    <published>2021-06-06T05:42:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>Kafka支持幂等功能来避免生产者重试时重复写入消息，开启方式为生产者客户端参数enable.idempotence设置为true（默认为false）。幂等性功能开启需要配合以下参数：</p><ul><li>如果显示设置retries则必须大于0，未显示指定默认为Integer.MAX_VALUE。</li><li>max.in.flight.requests.per.connection参数不能大于5。</li><li>如果显示指定了acks，需要保证参数值为-1，不设置Kafka会自行设置。</li></ul><p>Kafka的幂等性主要是通过日志格式中RecordBatch的producer id和first sequence两个字段实现，每个生产者在初始化时都会被分配一个pid，对于每个pid，消息发送到的每个分区都有对应的序列号，从0开始递增。生产者每发送一条消息就会将&lt;pid,分区&gt;对应的序列号的值加1。</p><p>broker端会为每一个&lt;pid,分区&gt;维护一个序列号。当收到消息时，只有它的序列号的值比维护的序列号大1时，才能正常接收。</p><span id="more"></span><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>幂等性并不能跨多个分区运作，而事务可以保证对多个分区写入操作的原子性。在需要使用事务时，需要显示设置transactional.id参数为唯一值，并且开启幂等特性。</p><p>KafkaProducer提供5种事务相关的方法：</p><ul><li>initTransactions：初始化事务</li><li>beginTransactions：开启事务</li><li>sendOffsetsToTransaction：消费者在事务内的位移提交</li><li>commitTransaction：提交事务</li><li>abortTransaction：终止事务（回滚）</li></ul><p>消费端存在参数isolation.level，默认值为read_uncommitted即可以消费未提交的事务，此参数可以设置为read_committd即只能消费已提交的消息。</p><h3 id="事务实现原理"><a href="#事务实现原理" class="headerlink" title="事务实现原理"></a>事务实现原理</h3><p>Kafka事务功能由事务协调器（TransactinoCoordinator）负责处理，TransactionCoordinator会将事务状态持久化到内部主题__transaction_state中。</p><p>事务实现原理如下：</p><ol><li>查找TransactionCoordinator，broker使用生产者请求中的transactionId的哈希值计算主题__transactino_state分区编号，leader所在broker即为要查找的TransactionCoordinator。</li><li>获取pid，生产者发送transactionId到TransactionCoordinator，TransactionCoordinator收到请求后会把transactionId和对应的PID以消息形式保存在主题__transactin_state中。</li><li>开启事务，生产者本地标记开启了一个事务，只有在发送第一条消息之后TransactionCoordinator才会认为此事务已经开启。</li><li>Conusme-Transform-Produce，此阶段包含整个事务的数据处理过程。<ul><li>AddPartitionsToTxnRequest：生产者给新的分区发送数据前，需要先向TransactionCoordinator发送请求将&lt;transactionId,TopicPartition&gt;的对应关系存储到__transaction_state中。</li><li>ProduceRequest：生产者发送消息到用户自定义的主题中，消息中包含PID、producer_epoch和sequence number信息。</li><li>AddOffsetsToTxnRequest：sendOffsetsToTransaction方法可以在一个事务批次里处理的消费和发送。</li><li>TxnOffsetCommitRequest：生产者发送TxnOffsetCommitRequest请求给GroupCoordinator将消费位移信息offsets存储到__consumer_offsets中。</li></ul></li><li>提交或终止事务：生产者通知TransactionCoordinator提交或终止事务。TransactionCoordinator在收到请求后会执行一下操作：<ul><li>将prepare_commit或prepare_abort消息写到__transaction_state中；</li><li>将提交或终止消息写入用户所使用的普通主题和__consumer_offsets中；</li><li>将complete_commit或complete_abort消息写到__transaction_state；</li></ul></li></ol><h1 id="过期时间（扩展）"><a href="#过期时间（扩展）" class="headerlink" title="过期时间（扩展）"></a>过期时间（扩展）</h1><p>消息过期时间功能Kafka本身并没有直接支持，但是我们可以基于消息的timestamp和消费者拦截器实现，在生产端发送消息时设置ttl存放在headers中，消费者拦截器判断消息是否超时。对于超时消息可以配合死信队列使用，即避免了消息丢失也便于进行系统诊断。</p><h1 id="延时队列（扩展）"><a href="#延时队列（扩展）" class="headerlink" title="延时队列（扩展）"></a>延时队列（扩展）</h1><p>对于Kafka的延时队列扩展支持，下面将讨论两种可行方案：基于自定义延时主题；服务端增加前置缓存；</p><h2 id="基于延时主题"><a href="#基于延时主题" class="headerlink" title="基于延时主题"></a>基于延时主题</h2><p>此方案的思路是在发送延时消息时，并不直接投递到真实的主题（real_topic）中，而是先投递到Kafka内部主题（delay_topic），然后通过一个自定义的服务（DelayService）拉取这些内部主题的消息，并将满足条件的消息投递到要发送的真实主题中，消费者订阅的还是真实的主题。</p><p>考虑到延时时间一般以秒计，如果要支持2个小时内的延时消息就创建7200个主题将会造成极度的资源浪费。可以按照不同的延时等级划分，比如5s/10s/30/1min/2min/5min/10min/20min/30min/45min/1h/2h，延时消息按照延时时间投递到不同等级的主题中，同一主题的消息延时时间强制转为一致的延时时间，这样只需增加少量主题就能在误差可控情况下实现延时功能。</p><p>具体实现上，对于生产者客户端需要进行一定封装，通过生产者拦截器，根据消息的timestamp、headers字段（设置延时时间）对延时消息划分等级发送到对应的内部主题中。</p><p>发送到内部主题（delay_topic_*）中的消息会被一个独立的DelayService消费，DelayService进程与Broker进程以一对一配比进行同机部署以保证可用性。对于不同延时级别的主题，DelaySercie内部都有单独的线程进行消息拉取，以及单独的DelayQueue进行消息暂存。DelayService应对主题中每个分区进行计数，当达到一定阈值就暂停该分区消息拉取。同时还会有专门的消息发送线程获取DelayQueue的消息并转发到真实主题中。</p><h2 id="服务端增加前置缓存"><a href="#服务端增加前置缓存" class="headerlink" title="服务端增加前置缓存"></a>服务端增加前置缓存</h2><p>此方案思路为在Kafka服务中增加一个前置缓存，生产者消息正常发送，Kafka在判断是延时消息时（需扩展延时消息协议）就将消息存储在缓存中，待延时操作触发时就将消息发送到真实的主题中。为了保证消息的可靠性，可以引入缓存多副本机制。</p><p>此思路需要对Kafka内核源码进行修改，另外需要衡量后期维护成本以及社区福利等问题，一般不适合实际应用。</p><h1 id="死信队列和重试队列（扩展）"><a href="#死信队列和重试队列（扩展）" class="headerlink" title="死信队列和重试队列（扩展）"></a>死信队列和重试队列（扩展）</h1><p>对于死信队列，指由于某些原因无法被正确投递，为了保证消息不丢失，将其置于的一个特殊角色的队列。死信队列可以在broker端存入也可以在客户端存入，可根据实际场景对Kafka进行扩展实现。</p><p>重试队列指消费端消费消息失败时，为了防止消息丢失而重新将消息回滚到broker中。重试队列一般分为多个等级，每个等级一般会设置重新投递延时，重试次数越多投递延时就越大，当超过投递次数时，消息就进入死信队列。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;h2 id=&quot;幂等&quot;&gt;&lt;a href=&quot;#幂等&quot; class=&quot;headerlink&quot; title=&quot;幂等&quot;&gt;&lt;/a&gt;幂等&lt;/h2&gt;&lt;p&gt;Kafka支持幂等功能来避免生产者重试时重复写入消息，开启方式为生产者客户端参数enable.idempotence设置为true（默认为false）。幂等性功能开启需要配合以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果显示设置retries则必须大于0，未显示指定默认为Integer.MAX_VALUE。&lt;/li&gt;
&lt;li&gt;max.in.flight.requests.per.connection参数不能大于5。&lt;/li&gt;
&lt;li&gt;如果显示指定了acks，需要保证参数值为-1，不设置Kafka会自行设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kafka的幂等性主要是通过日志格式中RecordBatch的producer id和first sequence两个字段实现，每个生产者在初始化时都会被分配一个pid，对于每个pid，消息发送到的每个分区都有对应的序列号，从0开始递增。生产者每发送一条消息就会将&amp;lt;pid,分区&amp;gt;对应的序列号的值加1。&lt;/p&gt;
&lt;p&gt;broker端会为每一个&amp;lt;pid,分区&amp;gt;维护一个序列号。当收到消息时，只有它的序列号的值比维护的序列号大1时，才能正常接收。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：副本剖析</title>
    <link href="https://haifuns.com/2021/06/06/kafka-08/"/>
    <id>https://haifuns.com/2021/06/06/kafka-08/</id>
    <published>2021-06-06T05:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka为分区引入了副本机制，通过增加副本数量提升数据容灾能力以及故障自动转移。</p><p>相关概念回顾：</p><ul><li>副本是相对分区而言的，即副本是特定分区的副本。</li><li>一个分区包含一个或多个副本，其中一个为leader副本，其余为follower副本，各个副本位于不同的broker节点中。只有leader副本对外提供服务，follower副本只负责数据同步。</li><li>分区中所有副本统称为AR，而ISR指与leader副本保持同步的副本集合（包含leader）。</li><li>LEO标识每个分区最后一条消息的下一个位置，分区每个副本都有自己的LEO，ISR中最小的LEO即为HW，消费者只能拉取到HW之前的消息。</li></ul><span id="more"></span><h1 id="失效副本"><a href="#失效副本" class="headerlink" title="失效副本"></a>失效副本</h1><p>正常情况下，分区的所有副本都处于ISR集合中。处于同步失效或功能失效的副本会被剥离出ISR集合，称为失效副本，失效副本对应的分区为同步失效分区。</p><p>当ISR集合中的follower副本滞后leader副本的时间超过broker端参数replica.lag.time.max.ms参数指定的值（默认1000）就判定为同步失败，此时此broker副本会被剔除ISR集合。具体实现原理为：</p><ol><li>当follower副本将leader副本LEO之前的日志全部同步时，则认为此follower副本已经追上leader副本，此时会更新lastCaughtUpTimeMs标识。</li><li>Kafka的副本管理器存在一个副本过期检测的定时任务，定期检查当前时间与副本的lastCaughtUpTimeMs差值是否大于replica.lag.time.max.ms指定的值。</li></ol><p>以下几种情况可能导致副本失效：</p><ul><li>follower副本进程卡住，在一段时间没有向leader副本发起同步请求，比如频繁FullGC。</li><li>follower副本进程同步过慢，在一段时间内无法追上leader副本，比如I/O开销过大。</li><li>新增加的副本在赶上leader副本之前。</li></ul><h1 id="LEO与HW"><a href="#LEO与HW" class="headerlink" title="LEO与HW"></a>LEO与HW</h1><p>对于多副本分区，整个消息追加过程如下：</p><ol><li>生产者客户端发送消息到leader副本中。</li><li>消息被追加到leader副本的本地日志，并更新日志的偏移量。</li><li>follower副本向leader副本请求同步数据。</li><li>leader副本所在的服务器读取本地日志，并更新对应拉取的follower副本的信息。</li><li>leader副本所在的服务器将拉取结果返回给follower副本。</li><li>follower副本收到leader副本返回的拉取结果，将消息追加到本地日志中，并更新日志的偏移量信息。</li></ol><p>在消息追加过程中各个副本LEO和HW变化情况如下：</p><ol><li>生产者一直向leader副本发送消息，某一时刻leader副本LEO&gt;HW。</li><li>follower副本从leader副本拉取消息，拉取请求中会携带自身LEO信息。</li><li>leader副本将请求中的LEO最小值作为HW，返回给follower副本相应的信息，并且携带自身HW信息。</li><li>follower副本写入消息并更新LEO，然后更新自己的HW为min(owner.LEO,leader.HW)。</li></ol><h1 id="Leader-Epoch"><a href="#Leader-Epoch" class="headerlink" title="Leader Epoch"></a>Leader Epoch</h1><p>在follower与leader副本的数据同步过程中，当发生宕机只依靠HW进行恢复可能会造成数据丢失。Kafka引入了leader epoch（leader的纪元信息，相当于一个版本号），在需要截断数据时使用leader epoch作为参考依据而不是HW。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Kafka为分区引入了副本机制，通过增加副本数量提升数据容灾能力以及故障自动转移。&lt;/p&gt;
&lt;p&gt;相关概念回顾：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;副本是相对分区而言的，即副本是特定分区的副本。&lt;/li&gt;
&lt;li&gt;一个分区包含一个或多个副本，其中一个为leader副本，其余为follower副本，各个副本位于不同的broker节点中。只有leader副本对外提供服务，follower副本只负责数据同步。&lt;/li&gt;
&lt;li&gt;分区中所有副本统称为AR，而ISR指与leader副本保持同步的副本集合（包含leader）。&lt;/li&gt;
&lt;li&gt;LEO标识每个分区最后一条消息的下一个位置，分区每个副本都有自己的LEO，ISR中最小的LEO即为HW，消费者只能拉取到HW之前的消息。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：控制器</title>
    <link href="https://haifuns.com/2021/06/06/kafka-07/"/>
    <id>https://haifuns.com/2021/06/06/kafka-07/</id>
    <published>2021-06-06T05:38:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），控制器负责整个集群中所有分区和副本的状态。当某个分区的leader副本出现故障时，由控制器负责为该分区选举出新的leader副本。当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新元数据信息。当使用kafka-topic.sh脚本为topic增加分区数量时，还是由控制器负责分区的重新分配。</p><span id="more"></span><h1 id="控制器选举"><a href="#控制器选举" class="headerlink" title="控制器选举"></a>控制器选举</h1><p>Kafka中的控制器选举依赖于zookeeper，broker启动时会尝试读取/controller临时节点的brokerid的值，如果读取到的brokerid值不为-1，则表示已经有其他broker节点成功竞选为控制器，如果zookeeper中不存在/controller节点或者这个节点的数据异常，那么broker会尝试创建/controller节点。竞选失败的broker节点会保存当前控制器的brokerid（activeControllerId）。每个broker会对/controller节点添加监听器来监听此节点的数据变化。当/controller节点的数据变化时，每个broker都会更新自身内存中的activeControllerId。如果broker在数据变更之前是控制器，变更后自身的brokerId与新的activeControllerId不一致，那么就需要“退位”，关闭相应的资源。</p><p>zookeeper还有一个/controller-epoch的持久节点，用于记录控制器发生变更的次数，称为控制器纪元，kafka通过controller_epoch来保证控制器的唯一性。</p><p>具有控制器身份的broker比普通broker多以下职责：</p><ul><li>监听分区相关的变化。包含处理分区重分配、处理ISR集合变更、处理优先副本的选举。</li><li>监听主题相关的变化。包含处理主题增减、处理删除主题。</li><li>监听broker相关的变化。处理broker增减的变化。</li><li>从zookeeper读取当前所有主题、分区、broker有关的信息的管理。监听主题的分区分配变化。</li><li>启动并管理分区状态机和副本状态机。</li><li>更新集群的元数据信息。</li><li>如果参数auto.leader.rebalance.enable为true，还会启动一个定时任务负责维护分区的优先副本均衡。</li></ul><p>控制器在选举成功后会读取zookeeper中各个节点的数据来初始化并管理上下文信息（ControllerContext）。比如为某个主题增加了分区，控制器负责创建分区的同时会更新上下文信息，并且需要将变更信息同步到其他broker节点中。不管是监听器触发的事件，还是定时任务触发的事件，或者是其他事件，都会读取或更新控制器中的上下文信息，Kafka的控制器使用单线程基于事件队列的模型，对每个事件进行一层封装，然后按照事件发生的先后顺序暂存到LinkedBlockingQueue中，最后使用一个专用的线程（ControllerEventThread）按照FIFO的原则处理事件。</p><h1 id="分区leader选举"><a href="#分区leader选举" class="headerlink" title="分区leader选举"></a>分区leader选举</h1><p>分区leader副本的选举由控制器负责，当创建分区或分区上线时都需要执行leader的选举动作，对应的策略为OfflinePartitionLeaderElectionStratrgy。这种策略的基本思路是按照AR集合中的副本顺序查找第一个存活对象，并且这个副本在ISR集合中。一个分区的AR集合在分配的时候被指定并且只要不发生重分配，集合内部副本的顺序是保持不变的，而分区的ISR集合的副本可能会改变。如果ISR集合中没有可用的副本，那么此时还要再检查一下unclean.leader.election.enable参数（默认false），如果参数配置为true那么表示允许从非ISR列表中的选举leader，从AR列表找到第一个存活对象副本即为leader。</p><p>当分区重分配时也会执行leader的选举动作，对应的策略为ReassignPartitionElectionStrategy。此策略的思路为从重分配的AR列表中找到第一个存活的副本，且这个副本在ISR列表中。</p><p>当发生优先副本选举时，直接将优先副本设置为leader即可，AR集合中的第一个副本即为优先副本（PreferredReplicaPartitionLeaderElectionStrategy）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），控制器负责整个集群中所有分区和副本的状态。当某个分区的leader副本出现故障时，由控制器负责为该分区选举出新的leader副本。当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新元数据信息。当使用kafka-topic.sh脚本为topic增加分区数量时，还是由控制器负责分区的重新分配。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：日志存储</title>
    <link href="https://haifuns.com/2021/05/29/kafka-06/"/>
    <id>https://haifuns.com/2021/05/29/kafka-06/</id>
    <published>2021-05-29T15:10:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka中的消息以主题为基本单位进行归类，每个主题可以分为一个或多个分区，不考虑多副本的情况下，一个分区对应一个日志（Log）。</p><p>为了防止Log过大、便于消息维护和管理，Kafka引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment。Log和LogSegment都不是纯粹物理意义上的概念，实际上，Log在物理层面是以文件夹形式存储，而每个LogSegment对应磁盘上的一个日志文件和两个索引文件，以及可能的其他文件。</p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>Log对应一个命名形式为<code>&lt;topic&gt;-&lt;partiton&gt;</code>的文件夹，向Log中追加消息时是顺序写入的，只有最后一个LogSegment才能执行写入操作（称为activeSegment，即当前活跃数据），此前的LogSegment都不能写入数据。随着消息的不断写入，当activeSegment满足一定条件时，就会创建新的activeSegment，之后追加消息到新的activeSegment。</p><p>每个LogSegment中的日志文件都对应两个索引文件：</p><ul><li>偏移量索引文件（.index文件后缀）</li><li>时间戳索引文件（.timeindex文件后缀）</li></ul><p>每个LogSegment都有一个基准偏移量baseOffset，用来表示当前LogSegment中的第一条消息的offset。偏移量是一个64位的长整数，日志文件和两个索引文件都是根据baseOffset命名的，名称固定为20位数字，比如第一个LogSegment的baseOffset为0，对应的日志文件为<code>00000000000000000000.log</code>。</p><span id="more"></span><h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><h2 id="V1版本"><a href="#V1版本" class="headerlink" title="V1版本"></a>V1版本</h2><p>Kafka消息格式（V1版本，未压缩）如下图所示，图中RECORD为消息体，offset和message size为日志头部（LOG_OVERHEAD）。与消息对应的还有消息集的概念，消息集中包含一条或者多条消息，消息集不仅是存储于磁盘及在网络上传输（Produce &amp; Fetch）的基本形式，而且是Kafka中压缩的基本单元，结构如图中右边部分。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka05.png" alt="image"></p><p>消息格式中的各个字段如下：</p><ul><li>crc32（4B）：crc32校验值，校验范围为magic到value之间。</li><li>magic（1B）：消息格式版本号。</li><li>timestamp（8B）：消息时间戳。（broker端可配置，默认使用生产者创建消息时的时间）</li><li>attributes（1B）：消息属性。低3位表示压缩类型，0-NONE，1-GZIP，2-SNAPPY，3-LZ4。第4位表示timestamp类型，0-CreateTime，1-LogAppendTime。其余位保留。</li><li>key length（4B）：消息key的长度。-1表示key为null。</li><li>key：消息键。</li><li>value length（4B）：实际消息体的长度。-1表示消息为null。</li><li>value：消息体。</li></ul><h2 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h2><p>为了得到更好的压缩效果，Kafka实现的压缩方案是将多条消息一起压缩。一般情况下，生产者发送的压缩消息在broker中也是保持压缩状态进行存储的，消费者从broker拉取到的也是压缩消息，在处理消息前才会进行解压。</p><p>Kafka日志压缩方式通过参数<code>compression.type</code>配置，默认值为producer，即保留生产者使用的压缩方式。压缩方式还可以配置为gzip/snappy/lz4三种压缩算法，以及可以配置不压缩（uncompressed）。</p><p>消息压缩时，将整个消息集作为内层消息，内层消息整体作为外层的value。压缩后的消息key为null，value是多条压缩消息。当生产者创建压缩消息时，对内部压缩消息设置的offset从0开始，offset由broker进行转换，保存内层最后一条的绝对位移在外层offset。如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka06.png" alt="image"></p><h2 id="V2版本"><a href="#V2版本" class="headerlink" title="V2版本"></a>V2版本</h2><p>V2版本中的消息集称为Record Batch，而不是Messgage Set，其内部也包含一条或者多条消息，如下图中部和右边。在消息压缩时，Record Batch Header部分（图左，first offset到records count字段）是不被压缩的，被压缩的是records字段中的所有内容。</p><p>生产者客户端中的ProducerBatch对应RecordBatch，而ProducerRecord对应Record。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka07.png" alt="image"></p><p>消息格式中Record部分字段为varints变长字段，Kafka会根据具体值确定需要几个字节保存。部分字段解释如下：</p><ul><li>length：消息总长度。</li><li>attributes：已弃用。</li><li>timestamp delta：时间戳增量，保存与RecordBatch的起始时间戳差值。</li><li>offset delta：时间戳增量，保存与RecordBatch起始位移的差值。</li></ul><p>RecordBatch字段解释如下：</p><ul><li>first offset：当前RecordBatch的起始偏移。</li><li>length：从partition leader epoch字段开始到末尾的长度。</li><li>partition leader epoch：分区leader纪元，可以看作分区leader的版本号或更新次数。</li><li>magic：消息格式版本号，V2版本此字段为2。</li><li>attributes：消息属性，低3位表示压缩格式，第4位表示时间戳类型，第5位表示此RecordBatch是否处于事务中，第6位表示是否是控制消息（ControlBatch），控制消息用来支持事务功能。</li><li>last offset delta：RecordBatch中最后一个Record的offset与first offset的差值。</li><li>first timestamp：RecordBatch中第一条Record的时间戳。</li><li>max timestamp：RecordBatch中最大的时间戳。</li><li>producer id：PID，用来支持幂等和事务。</li><li>producer epoch：同producer id，用来支持幂等和事务。</li><li>producer sequence：同producer id、producer epoch，用来支持幂等和事务。</li><li>records count：RecordBatch中的Record的个数。</li></ul><h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1><p>每个日志分段文件都对应两个索引文件，用来提高查找消息的效率。偏移量索引文件用来建立消息偏移量到物理地址之间的映射关系，方便快速定位到消息所在的物理文件位置。时间戳索引文件用来根据指定时间戳来查找对应的偏移量信息。</p><p>Kafka中的索引文件以稀疏索引的方式构造，其不保证每条消息在索引文件中都有对应的索引项，每当写入一定量的消息时（broker端参数log.index.interval.bytes控制，默认4KB），偏移量索引文件和时间戳索引文件分别增加一个偏移量索引和时间戳索引项。</p><p>稀疏索引通过MapppedByteBuffer将索引文件映射到内存中以加快索引查询速度。偏移量索引文件中的偏移量是单调递增的，查询指定偏移量时，使用二分查找快速定位偏移量位置，如果指定偏移量不在索引文件中，则会返回小于指定偏移量的最大偏移量。时间戳索引查找方式同理，至于找到对应的物理文件位置时需要再根据偏移量索引再次定位。</p><p>对于日志分段文件，其切分条件如下，满足其一即可：</p><ol><li>当前日志分段文件的大小超过了broker端参数log.segment.bytes配置的值。默认值为1GB。</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳差值大于log.roll.ms或log.roll.hours参数配置的值。默认情况下只配置log.roll.hours参数，为7天。</li><li>偏移量索引或时间戳索引文件大小达到broker端参数log.index.size.max.bytes配置的值，默认10MB。</li><li>追加的消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE，即要追加的消息偏移量不能转变为相对偏移量（offset - baseOffset &gt; Integer.MAX_VALUE）。</li></ol><h2 id="偏移量索引"><a href="#偏移量索引" class="headerlink" title="偏移量索引"></a>偏移量索引</h2><p>每个偏移量索引项占8个字节，分为两个部分：</p><ol><li>relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，占用4个字节，当前索引文件文件名即为baseOffset。</li><li>position：物理地址，也就是消息在日志分段文件中的对应物理位置，占用4个字节。</li></ol><h2 id="时间戳索引"><a href="#时间戳索引" class="headerlink" title="时间戳索引"></a>时间戳索引</h2><p>每个时间戳索引项占12个字节，也分为两个部分：</p><ol><li>timestamp：当前日志分段的最大时间戳，占用8个字节。</li><li>relativeOffset：时间戳对应的消息相对偏移量，占用4个字节。</li></ol><h1 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h1><p>为了控制消息存储占用的磁盘空间，Kafka提供了两种日志清理策略：</p><ol><li>日志删除（Log Retention）：按照一定策略直接删除不符合条件的日志分段。</li><li>日志压缩（Log Compaction）：针对每个消息的key进行整合，对于相同的key的不同value值，只保留最后一个版本。</li></ol><p>通过broker端参数log.cleanup.policy参数设置日志清理策略，默认为delete即采用日志清理策略，可配置为compact即日志压缩策略，还可以配置为delete,compact即同时支持两种策略。日志清理的粒度可以控制到主题级别，对应主题级别参数cleanup.policy。</p><p>对于日志删除，Kafka的日志管理器中有一个专门的日志删除任务来周期性检测和删除不符合保留条件的日志分段文件，默认频率5分钟。当前日志分段的保留策略有三种：</p><ul><li>基于时间的保留策略</li><li>基于日志大小的保留策略</li><li>基于日志起始偏移量的保留策略</li></ul><h1 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h1><h2 id="磁盘顺序写"><a href="#磁盘顺序写" class="headerlink" title="磁盘顺序写"></a>磁盘顺序写</h2><p>Kafka采用文件追加的方式写入消息，即只能在日志文件的尾部追加新的消息，并且不允许修改已写入的消息。这种顺序写盘的操作使得Kafka即使使用磁盘作为存储介质，其所能承载的吞吐量也不容小觑。</p><h2 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h2><p>Kafka中大量使用了页缓存，消息先被写入页缓存，然后由操作系统负责具体的刷盘任务，同时Kafka提供同步刷盘及强制性刷盘（fsync）功能，通过log.flushl.interval.messages、log.flush.interval.ms等参数控制。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>Kafka还使用了零拷贝（Zero-Copy，将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序）技术来进一步提升性能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Kafka中的消息以主题为基本单位进行归类，每个主题可以分为一个或多个分区，不考虑多副本的情况下，一个分区对应一个日志（Log）。&lt;/p&gt;
&lt;p&gt;为了防止Log过大、便于消息维护和管理，Kafka引入了日志分段（LogSegment）的概念，将Log切分为多个LogSegment。Log和LogSegment都不是纯粹物理意义上的概念，实际上，Log在物理层面是以文件夹形式存储，而每个LogSegment对应磁盘上的一个日志文件和两个索引文件，以及可能的其他文件。&lt;/p&gt;
&lt;h1 id=&quot;文件目录&quot;&gt;&lt;a href=&quot;#文件目录&quot; class=&quot;headerlink&quot; title=&quot;文件目录&quot;&gt;&lt;/a&gt;文件目录&lt;/h1&gt;&lt;p&gt;Log对应一个命名形式为&lt;code&gt;&amp;lt;topic&amp;gt;-&amp;lt;partiton&amp;gt;&lt;/code&gt;的文件夹，向Log中追加消息时是顺序写入的，只有最后一个LogSegment才能执行写入操作（称为activeSegment，即当前活跃数据），此前的LogSegment都不能写入数据。随着消息的不断写入，当activeSegment满足一定条件时，就会创建新的activeSegment，之后追加消息到新的activeSegment。&lt;/p&gt;
&lt;p&gt;每个LogSegment中的日志文件都对应两个索引文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏移量索引文件（.index文件后缀）&lt;/li&gt;
&lt;li&gt;时间戳索引文件（.timeindex文件后缀）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个LogSegment都有一个基准偏移量baseOffset，用来表示当前LogSegment中的第一条消息的offset。偏移量是一个64位的长整数，日志文件和两个索引文件都是根据baseOffset命名的，名称固定为20位数字，比如第一个LogSegment的baseOffset为0，对应的日志文件为&lt;code&gt;00000000000000000000.log&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：主题与分区</title>
    <link href="https://haifuns.com/2021/05/29/kafka-05/"/>
    <id>https://haifuns.com/2021/05/29/kafka-05/</id>
    <published>2021-05-29T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题管理"><a href="#主题管理" class="headerlink" title="主题管理"></a>主题管理</h1><h2 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h2><p>如果broker端配置参数<code>auto.create.topics.enable</code>设置为true（默认），当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为<code>num.partitions</code>（默认1）、副本数为<code>default.replication.factor</code>（默认1）的主题。当一个消费者从一个未知主题中读取消息时，或者当任意客户端向未知主题发送元数据请求时，都会按照配置创建一个相应的主题。</p><p>不建议将<code>auto.create.topics.enable</code>参数设置为true，推荐使用kafka-topic.sh脚本手动创建主题。</p><p>示例，创建分区数为4，副本数为3的主题topic-demo：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kafka-topics.sh --zookeeper localhost:2181/kafka --create --topic topic-demo --replication-factor 3 --partitions 4</span></span><br></pre></td></tr></tbody></table></figure><p>在执行完脚本之后，Kafka会在log.dir或者log.dirs参数所配置的目录下创建相应的主题分区，默认目录为/tmp/kafka-logs。</p><span id="more"></span><h2 id="查看主题"><a href="#查看主题" class="headerlink" title="查看主题"></a>查看主题</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka -list <span class="comment"># 查看当前所有可用主题</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka -desctibe -- topic topic-create,topic-demo <span class="comment"># 查看指定主题详细信息</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka --alter --topic topic-config --partitons 3 <span class="comment"># 将topic-config分区由1增加到3，注意：不可以减少分区</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka --alter --topic topic-config --config max.message.bytes=2000 <span class="comment"># 修改主题配置信息</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka --alter --topic topic-config --delete-config max.message.bytes <span class="comment"># 删除主题配置</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>Kafka可以使用kafka-config.sh脚本动态修改配置，alter命名变更、desctibe命令查看。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kafka-topic.sh --zookeeper localhost:2181/kafka --describe --entity-type topics --entity-name topic-config</span> </span><br><span class="line">                    # --describe 查看指令</span><br><span class="line">                    # --entity-type 指定查看配置实体类型，topics/brokers/clients/users</span><br><span class="line">                    # --entity-name 指定查看配置实体名称</span><br><span class="line">                    </span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-configs.sh --zookeeper localhost:2181/kafka --alter --entity-type topics --entity-name topic-config --add-config cleanup.policy=compact,max.message.bytes=10000 <span class="comment"># 覆盖配置</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-topics.sh --zookeeper localhost:2181/kafka --describe --topic topic-config --topics-with-overrides <span class="comment"># 查看被覆盖的配置</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kafka-configs.sh --zookeeper localhost:2181/kafka --alter --entity-type topics --entity-name topic-config --delete-config cleanup.policy,max.message.bytes <span class="comment"># 删除配置</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topic.sh --zookeeper localhost:2181/kafka --delete --topic topic-delete # 删除主题topic-delete</span><br></pre></td></tr></tbody></table></figure><p>删除主题还有broker端配置参数<code>delete.topic.enable</code>有关，只有配置为true时（默认），才能删除主题，否则删除主题操作会被忽略。</p><p>使用kafka-topic.sh脚本删除主题本质上只是在zookeeper中的/admin/delete_topics路径下创建一个与带删除主题同名的节点，以此标记主题为待删除状态。与创建主题相同，真正删除主题的操作由Kafka的控制器负责完成。</p><h1 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h1><h2 id="优先副本选举"><a href="#优先副本选举" class="headerlink" title="优先副本选举"></a>优先副本选举</h2><p>分区使用多副本的机制提升可靠性，但是只有leader副本对外提供读写服务，而follower副本只负责在内部进行消息同步。如果分区leader副本不可用，那么整个分区都会不可用，此时Kafka会从剩余的follower副本中挑选一个新的leader副本继续对外提供服务。</p><p>为了防止Kafka集群的broker节点遇到故障导致分区漂移从而使集群负载不均衡的情况，Kafka引入了优先副本（preferred replica）的概念。优先副本即AR集合中的第一个副本，理想情况下，优先副本就是分区的leader副本。Kafka会通过优先副本选举促使优先副本选举为leader副本，促进集群负载均衡，这一行为称为“分区平衡”。</p><p>Kafka提供分区自动平衡的功能，对应broker参数<code>auto.leader.rebaleance.enable</code>，默认为true。当开启分区自动平衡时，Kafka控制器会开启一个定时任务轮询所有broker节点，计算分区不平衡率（broker不平衡率=非优先副本leader个数/分区总数）是否超过<code>leader.imbalance.per.broker.percentage</code>参数配置的值（默认10%），如果超过设定比值就会自动进行分区平衡。</p><p>自动分区平衡可能会导致负面的性能问题、客户端阻塞等问题，对于生产环境不建议将分区自动平衡功能开启，而建议使用<code>kafka-perferred-replica-election.sh</code>脚本手动对分区leader副本进行分区平衡。</p><h2 id="分区重分配"><a href="#分区重分配" class="headerlink" title="分区重分配"></a>分区重分配</h2><p>当集群中新增broker节点时，只有新创建的主题分区才有可能被分配到这个节点上，而之前的主题并不会自动分配到新加入的节点中，为了解决这样的新节点负载和原先节点的负载不均衡，Kafka支持让分区副本进行再分配，即分区重分配。</p><p>Kafka提供<code>kafka-reassign-partitions.sh</code>脚本来执行分区重分配工作，可以在集群扩容、broker节点失效的场景下对分区进行迁移。</p><p>分区重分配的基本原理是先通过控制器为每个分区添加新副本，新副本将从分区的leader副本复制所有数据，在复制完成后，控制器将旧副本从副本清单里清除完成重分配。</p><h2 id="复制限流"><a href="#复制限流" class="headerlink" title="复制限流"></a>复制限流</h2><p>分区重分配的本质在于数据复制，但是数据复制会占用额外的资源，当重分配的量太大就会影响性能。Kafka支持使用<code>kafka-config.sh</code>和<code>kafka-reassign-partitons.sh</code>两种方式对副本间的复制流量进行限制。</p><h2 id="修改副本因子"><a href="#修改副本因子" class="headerlink" title="修改副本因子"></a>修改副本因子</h2><p>创建主题之后同样可以修改副本因子（副本数），具体可以通过<code>kafka-reassign-partition.sh</code>脚本实现。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;主题管理&quot;&gt;&lt;a href=&quot;#主题管理&quot; class=&quot;headerlink&quot; title=&quot;主题管理&quot;&gt;&lt;/a&gt;主题管理&lt;/h1&gt;&lt;h2 id=&quot;创建主题&quot;&gt;&lt;a href=&quot;#创建主题&quot; class=&quot;headerlink&quot; title=&quot;创建主题&quot;&gt;&lt;/a&gt;创建主题&lt;/h2&gt;&lt;p&gt;如果broker端配置参数&lt;code&gt;auto.create.topics.enable&lt;/code&gt;设置为true（默认），当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为&lt;code&gt;num.partitions&lt;/code&gt;（默认1）、副本数为&lt;code&gt;default.replication.factor&lt;/code&gt;（默认1）的主题。当一个消费者从一个未知主题中读取消息时，或者当任意客户端向未知主题发送元数据请求时，都会按照配置创建一个相应的主题。&lt;/p&gt;
&lt;p&gt;不建议将&lt;code&gt;auto.create.topics.enable&lt;/code&gt;参数设置为true，推荐使用kafka-topic.sh脚本手动创建主题。&lt;/p&gt;
&lt;p&gt;示例，创建分区数为4，副本数为3的主题topic-demo：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; kafka-topics.sh --zookeeper localhost:2181/kafka --create --topic topic-demo --replication-factor 3 --partitions 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在执行完脚本之后，Kafka会在log.dir或者log.dirs参数所配置的目录下创建相应的主题分区，默认目录为/tmp/kafka-logs。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：再均衡原理剖析</title>
    <link href="https://haifuns.com/2021/05/22/kafka-04/"/>
    <id>https://haifuns.com/2021/05/22/kafka-04/</id>
    <published>2021-05-22T12:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka中多个消费者间的分区分配由消费者协调器（ConsumerCoordinator）和组协调器（GroupCoordinator）共同完成。全部消费组被分为多个子集，每个子集在服务端对应者一个GroupCoordinator进行管理，而消费者客户端中的ConsumerCoordinator组件负责与GroupCoordinator进行交互。</p><p>GroupCoordinator与ConsumerCoordinaor之间最重要的工作就是负责执行消费者再均衡。分区分配工作也是在再均衡期间完成的。</p><span id="more"></span><h1 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h1><p>触发再均衡的场景如下：</p><ul><li>新的消费者加入消费组。</li><li>消费者宕机。</li><li>消费者主动退出消费组。</li><li>消费组对应的GroupCoordinaor节点发生变更。</li><li>消费组内订阅的任一主题或主题分区数量发生变化。</li></ul><h1 id="再均衡流程"><a href="#再均衡流程" class="headerlink" title="再均衡流程"></a>再均衡流程</h1><h2 id="第一阶段（FIND-COORDINATOR）"><a href="#第一阶段（FIND-COORDINATOR）" class="headerlink" title="第一阶段（FIND_COORDINATOR）"></a>第一阶段（FIND_COORDINATOR）</h2><p>此阶段消费者需要与所属消费组对应的GroupCoordinator所在的broker建立连接。如果消费者已经保存与消费组对应的GroupCoordinator节点的信息，并且与之建立的网络连接正常，那么就直接进入第二阶段。否则，需要向负载最小的节点（leastLoadedNode）发送FindCoordinatorRequest（coordinator_key + coordinator_type）请求来查找对应的GroupCoordinator。</p><p>Kafka收到FindCoordinatorRequest消息后，会根据coordinator_key（即groupId）查找对应的GroupCoordinator节点，返回对应的node_id、ip、port信息。</p><p>查找GroupCoordinator的方式为先根据groupId的hash值对__consumers_offsets的分区数取余，得到分区号，然后寻找此分区leader副本所在的broker节点，即这个groupId所对应的GroupCoordinator节点。</p><p>消费者groupId最终的分区分配方案及组内消费者提交的消费位移都会提交到查到的broker节点上。</p><h2 id="第二阶段（JOIN-GROUP）"><a href="#第二阶段（JOIN-GROUP）" class="headerlink" title="第二阶段（JOIN_GROUP）"></a>第二阶段（JOIN_GROUP）</h2><p>此阶段消费者会向GroupCoordinator发送JoinGroupRequest请求，请求体包含如下信息：</p><ul><li>group_id：消费组id。</li><li>session_timeout：对应消费者session.timeout.ms，默认10s。当GroupCoordinator超过session_timeout指定的时间没有收到心跳则认为消费者已下线。</li><li>reblance_timeout：对应消费者max.poll.interval.ms，默认5min。表示消费组再平衡时GroupCoordinator等待消费者重新加入的最长时间。</li><li>member_id：GroupCoordinator分配给消费者的id。消费者第一次发送JoinGroupRequest请求时此字段为null。</li><li>protocol_type：消费者实现协议，此处传consumer。</li><li>group_protocols：多个分区分配策略，配置多种策略时包含多个protocol_name和protocol_metadata信息。</li></ul><h3 id="选举消费者组leader"><a href="#选举消费者组leader" class="headerlink" title="选举消费者组leader"></a>选举消费者组leader</h3><p>GroupCoordinator需要为消费组内的消费者选举一个消费组leader，当消费者组还没有leader时，第一个加入的消费者即为消费者组leader，如果leader退出了消费者组就随机选一个消费者作为leader。</p><h3 id="选举分区分配策略"><a href="#选举分区分配策略" class="headerlink" title="选举分区分配策略"></a>选举分区分配策略</h3><p>消费组需要从各个消费者呈报的分配策略中选举出一个策略，由消费者投票选出。具体选举过程如下：</p><ol><li>收集各个消费者支持的所有分配策略（partition.assignment.strategy）组成候选集。</li><li>每个消费者从候选集中找出第一个支持的的策略并投票。</li><li>计算候选集中的策略投票数，选票最多的策略即为当前消费组的分配策略。</li></ol><p>分配策略选举完成后Kafka会发送给消费者JoinGroupResponse回执，回执中包含GroupCoordinator中投票选举出的分配策略信息，并且只有leader消费者的回执中包含各个消费者的订阅信息。</p><h2 id="第三阶段（SYNC-GROUP）"><a href="#第三阶段（SYNC-GROUP）" class="headerlink" title="第三阶段（SYNC_GROUP）"></a>第三阶段（SYNC_GROUP）</h2><p>此阶段leader消费者会根据上一个阶段选举出来的分区分配策略进行具体的分区分配，之后通过GroupCorrdinator转发同步分配方案。</p><p>所有消费者会向GroupCoordinator发送SyncGroupRequest请求，并且只有leader消费者的请求中携带分区分配方案。</p><p>GroupCoordinator会将leader消费者请求中的分区分配策略连同这个消费组的元数据信息存入Kafka的__consumer_offsets主题中。最后发送分区分配方案给各个消费者。</p><h2 id="第四阶段（HEARTAEAT）"><a href="#第四阶段（HEARTAEAT）" class="headerlink" title="第四阶段（HEARTAEAT）"></a>第四阶段（HEARTAEAT）</h2><p>进入此阶段后消费组中的所有消费者就会处于正常工作状态。在开始消费前，消费者需要拉取消息的起始位置，如果之前提交过消费位移则通过OffsetFetchRequest向GroupCoordinator获取上次提交的位移并从此处继续消费。</p><p>消费者通过一个独立的心跳线程向GroupCoordinator发送心跳，心跳间隔由heartbeat.interval.ms指定，默认3s。如果一个消费者发生崩溃并停止消费消息，那么GroupCoordinator会等待session.timeout.ms时间确认消费者死亡后触发再均衡。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Kafka中多个消费者间的分区分配由消费者协调器（ConsumerCoordinator）和组协调器（GroupCoordinator）共同完成。全部消费组被分为多个子集，每个子集在服务端对应者一个GroupCoordinator进行管理，而消费者客户端中的ConsumerCoordinator组件负责与GroupCoordinator进行交互。&lt;/p&gt;
&lt;p&gt;GroupCoordinator与ConsumerCoordinaor之间最重要的工作就是负责执行消费者再均衡。分区分配工作也是在再均衡期间完成的。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：消费者</title>
    <link href="https://haifuns.com/2021/05/22/kafka-03/"/>
    <id>https://haifuns.com/2021/05/22/kafka-03/</id>
    <published>2021-05-22T12:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>消息的消费一般有两种模式：</p><ul><li>推模式：服务端主动将消息推送给消费者。</li><li>拉模式：消费者主动从服务端拉取消息。</li></ul><p>Kafka中的消费是拉模式，消费者轮训订阅的主题/分区进行消息拉取，支持订阅一个或多个主题，同时也支持订阅分区。</p><span id="more"></span><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"key.deserializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.deserializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.40:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"group.id"</span>, <span class="string">"group.demo"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置消费者实例</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        consumer.subscribe(Collections.singleton(<span class="string">"topic-demo"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="消费者与消费组"><a href="#消费者与消费组" class="headerlink" title="消费者与消费组"></a>消费者与消费组</h1><p>消费者订阅Kafka中的主题并且拉取消息。每个消费者都对应一个消费组，当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。</p><p>Kafka支持两种消息投递模式：</p><ul><li>点对点模式：所有消费者隶属于同一个消费组。此时所有消息会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理。</li><li>发布/订阅模式：所有的消费者都隶属于不同的消费组。此时所有的消息都会被广播给所有的消费者，即每条消息都会被所有的消费者处理。</li></ul><h1 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h1><p>KafkaConsumer可以通过参数<code>partition.assignment.strategy</code>设置消费者与订阅主题之间的分区分配策略，可配置为多个分配策略。默认情况值为<code>org.apache.kafka.clients.consumer.RangeAssignor</code>，即使用RangeAssignor分配策略。Kafka还支持RoundRobinAssignor和StickyAssignor两种分配策略，</p><h2 id="RangeAssignor分配策略（默认）"><a href="#RangeAssignor分配策略（默认）" class="headerlink" title="RangeAssignor分配策略（默认）"></a>RangeAssignor分配策略（默认）</h2><p>此策略分配原理是按照消费者总数和分区总数进行整除获得跨度，然后将分区按照跨度进行平均分配。</p><p>对于每一个主题，RangeAssignor策略会将消费组内所有订阅主题的消费者按照名称排序，然后为每个消费者划分固定的分区范围，如果不够平均分配，则顺序靠前的消费者会被多分配一个分区。</p><p>例如，消费组中有两个消费者C0和C1，都订阅了主题T0和T1，每个主题都有3个分区，即T0P0/T0P1/T0P2、T1P0/T1P1/T1P2。最终的分配结果为：</p><ul><li>消费者C0：T0P0、T0P1、T1P0、T1P1</li><li>消费者C1：T0P2、T1P2</li></ul><p>RangeAssignor策略存在分配不均的情况，极端情况下可能出现部分消费者过载。</p><h2 id="RoundRobinAssignor分配策略"><a href="#RoundRobinAssignor分配策略" class="headerlink" title="RoundRobinAssignor分配策略"></a>RoundRobinAssignor分配策略</h2><p>此策略分配原理是将消费组内所有的消费者以及消费者订阅的所有主题分区排序，然后通过轮训的方式将分区以此分配给每个消费者。</p><p>例如，消费组中有两个消费者C0和C1，都订阅了主题T0和T1，每个主题都有3个分区，即T0P0/T0P1/T0P2、T1P0/T1P1/T1P2。最终的分配结果为：</p><ul><li>消费者C0：T0P0、T0P2、T1P1</li><li>消费者C1：T0P1、T1P0、T1P2</li></ul><p>如果同一个消费组内的消费者订阅的信息不同，那么在分区分配时就不是完全的轮训分配，也有可能导致分配不均。</p><p>例如，消费组中有三个消费者C0、C1、C2，共订阅了主题T0、T1、T2，分别有1、2、3个分区，即T0P0、T1P0/T1P1、T2P0/T2P1/T2P2。C0订阅T0，C1订阅T0和T1，C2订阅T1和T2，则最终的分配结果为：</p><ul><li>消费者C0：T0P0</li><li>消费者C1：T1P0</li><li>消费者C2：T1P1、T2P0、T2P1、T2P2</li></ul><h2 id="StickyAssignor分配策略"><a href="#StickyAssignor分配策略" class="headerlink" title="StickyAssignor分配策略"></a>StickyAssignor分配策略</h2><p>SkickyAssignor分配策略有两个目的：</p><ol><li>分区的分配尽可能均匀</li><li>分区的分配尽可能与上次分配的保持相同</li></ol><p>当两者发生冲突时第一个目标优先于第二个目标。</p><p>例如，消费组中有两个消费者C0、C1、C2，都订阅了主题T0、T1、T2、T3，每个主题都有2个分区，即T0P0/T0P1、T1P0/T1P1、T2P0/T2P1、T3P0/T3P1。最终的分配结果为：</p><ul><li>消费者C0：T0P0、T1P1、T3P0</li><li>消费者C1：T0P1、T2P0、T3P1</li><li>消费者C2：T1P0、T2P1</li></ul><p>在以上分配完成后，如果C1脱离了消费组，那么消费组就会进行再均衡重新分配分区，此时如果使用RoundRobinAssignor分配策略结果为：</p><ul><li>消费者C0：T0P0、T1P0、T2P0、T3P0</li><li>消费者C2：T0P1、T1P1、T2P1、T3P1</li></ul><p>如上所示，RoundRobinAssignor分配策略会按照CO和C2进行重新轮训分配。但是如果使用SkickyAssignor分配策略会保留上次的分配结果，在此基础上对C1被分配的分区重新分配，再分配结果为：</p><ul><li>消费者C0：T0P0、T1P1、T3P0、T2P0</li><li>消费者C2：T1P0、T2P1、T0P1、T3P1</li></ul><p>对于前文提到的RoundRobinAssignor无法分配不均的情况，消费组中有三个消费者C0、C1、C2，共订阅了主题T0、T1、T2，分别有1、2、3个分区，即T0P0、T1P0/T1P1、T2P0/T2P1/T2P2。C0订阅T0，C1订阅T0和T1，C2订阅T1和T2，StickyAssignor分配策略最终的分配结果为：</p><ul><li>消费者C0：T0P0</li><li>消费者C1：T1P0、T1P1</li><li>消费者C2：T2P0、T2P1、T2P2</li></ul><h1 id="消费位移"><a href="#消费位移" class="headerlink" title="消费位移"></a>消费位移</h1><p>在Kafka分区中每条消息都有唯一的offset用来表示消息在分区中的位置。对于消费者而言，也有offset的概念，用来表示消费到分区中消息的位置，可以称为是消费位移。</p><p>在新的客户端中，消费位移存储在Kafka内部的主题__consumer_offsets中。在消费完消息之后，消费者需要进行消费位移的提交。如下图所示，当前拉取消息的起始位置是上一次提交的消费位移，而本次将要提交的消费位置是拉取到的最大位移+1。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka04.png" alt="image"></p><blockquote><p>__consumer_offsets主题在Kafka集群第一次有消费者消费消息时自动创建，副本数由offsets.topic.replication.factor参数设置，默认3，分区数由offsets.topic.num.partitions参数设置，默认50。</p></blockquote><h2 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h2><p>Kafka中的消费位移提交支持两种方式：</p><ul><li>自动提交（默认）：默认情况下每隔5s会将拉取到的每个分区中的最大消息位移进行提交。此方式可能会导致重复消费和消息丢失。<ul><li>enable.auto.commit：自动提交开关，默认true</li><li>auto.commit.interval.ms：定期提交周期，默认5s</li></ul></li><li>手动提交：可细分为同步提交和异步提交两种方式。</li></ul><h2 id="指定位移消费"><a href="#指定位移消费" class="headerlink" title="指定位移消费"></a>指定位移消费</h2><p>当一个消费组建立的时候或者消费组中的一个新的消费者订阅了一个新的主题，又或者__consumer_offsets主题中有关这个消费组的位移消息过期而被删除时，Kafka中的消费者查找不到记录的消费位移。<br>此时会根据消费者客户端参数<code>auto.offset.reset</code>参数配置来决定从何处开始进行消费，可选参数如下：</p><ul><li>latest：从分区末尾开始消费消息（默认）</li><li>earliest：从分区起始开始消费消息</li><li>none：抛出异常</li></ul><p>KafkaConsumer支持使用seek()方法从特定位移处开始拉取消息，需要注意的是，在执行seek()方法前需要先执行poll()，在分配到分区之后才可以重置消费位置。</p><h1 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h1><p>当添加或删除消费组中的消费者时会发生再均衡，即分区的所属权从一个消费者转移到另一个消费者。在<strong>再均衡发生期间，消费组不可用</strong>，同时当一个分区被重新分配给另一个消费者是，消费者当前状态也会丢失。比如，消费者消费完某个分区中的一部分消息还没来得及提交消息位移就发生了再均衡操作，之后这个分区被分配给了消费组中的另一个消费者，此时消息就会被重复消费。所以应该尽量避免不必要的再均衡发生。</p><h1 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h1><ul><li>group.id：消费组名称</li><li>fetch.min.bytes：一次拉取请求能拉取的最小数据量，默认1B</li><li>fetch.max.bytes：一次拉取请求能拉取的最大数据量，默认50M</li><li>fetch.max.wait.ms：等待时间，默认500ms</li><li>max.partition.fetch.bytes：每个分区返回给消费者的最大数据量，默认1M</li><li>max.poll.records：一次请求拉取的最大消息数，默认500条</li><li>connections.max.idle.ms：连接最长空闲时间，默认9min</li><li>exclude.internal.topics：指定内部主题（__consumer_offsets、__transaction_state）是否对消费者公开，默认true</li><li>receive.buffer.bytes：Socket接收缓冲区大小，默认64K</li><li>send.buffer.bytes：Socket发送消息缓冲区大小，默认128K</li><li>request.timeout.ms：消费者请求最长等待时间，默认30s</li><li>metadata.max.age.ms：元数据过期时间，默认5min</li><li>reconnect.backoff.ms：重连等待时间，默认50ms</li><li>retry.backoff.ms：重试间隔时间，默认100ms</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;消息的消费一般有两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推模式：服务端主动将消息推送给消费者。&lt;/li&gt;
&lt;li&gt;拉模式：消费者主动从服务端拉取消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kafka中的消费是拉模式，消费者轮训订阅的主题/分区进行消息拉取，支持订阅一个或多个主题，同时也支持订阅分区。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：生产者</title>
    <link href="https://haifuns.com/2021/05/22/kafka-02/"/>
    <id>https://haifuns.com/2021/05/22/kafka-02/</id>
    <published>2021-05-22T12:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka Producer负责向Kafka发送消息，最新的客户端为Java语言编写，但Kafka社区有提供其他语言的客户端，包括C/C++、Python、Go等。</p><p>Kafka Producer支持三种消息发送模式：发后即忘、同步发送、异步发送。</p><span id="more"></span><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.40.134:9092"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置生产者实例</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建消息</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"topic-demo"</span>, <span class="string">"hello kafka"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        producer.send(record);</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><ul><li>ProducerInterceptors：拦截器。</li><li>Partitioner：分区器，决定消息路由到哪个分区。默认分区器会对key进行哈希（MurmurHash2算法），根据哈希值计算分区号，如果key为空则轮询发送。</li><li>Metadata：缓存broker集群元数据，Topic -&gt; Partitions（Leader+Follwers，ISR）。懒加载，初始化时不会拉取元数据而是在发送消息时拉取指定topic元数据。<ul><li>metadata.max.age.ms：元数据刷新时间，默认5min</li></ul></li><li>Serializer：序列化器。<ul><li>key.serializer：key序列化器</li><li>value.serializer：value序列化器</li></ul></li><li>RecordAccumulator：消息累加器。<ul><li>buffer.memory：缓冲区内存大小，默认32M</li><li>batch.size：每个批次内存大小，默认16K</li><li>linger.ms：批次未满时每隔多久发送一次，默认0</li><li>request.timeout.ms：请求超时时间，默认30s</li><li>max.block.ms：缓冲区满后阻塞时间</li></ul></li><li>NetworkClient：网络通信。<ul><li>connections.max.idle.ms：网络连接最大空闲时间，默认9min</li><li>reconnect.backoff.ms：重连时间间隔，默认50ms</li><li>send.buffer.bytes：socket发送缓冲区大小，默认128k</li><li>receive.buffer.bytes：socket接收缓冲区大小，默认32k</li><li>compression.type：消息压缩方式，默认为none不压缩</li></ul></li><li>Sender：发送线程。<ul><li>max.request.size：每个请求最大大小，默认1M</li><li>acks：指定消息需要多少个follower同步成功认为发送成功，默认1（只要leader写入成功就认为成功）</li><li>retries：重试次数</li><li>retry.backoff.ms：每次重试间隔时间</li><li>request.timeout.ms：producer等待请求响应的最长时间，默认30s</li><li>max.in.flight.requests.per.connection：客户端在单个连接上能够发送的未响应请求的个数，默认5</li></ul></li></ul><h1 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h1><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka03.png" alt="image"></p><p>消息发送流程：</p><ol><li>回调自定义的拦截器。（图示步骤1）</li><li>同步阻塞等待获取Topic元数据（无缓存需要获取）。</li><li>序列化Key、Value数据转换为Byte[]。（图示步骤2）</li><li>基于获取到的Topic元数据，使用Partitioner获取消息对应分区。（图示步骤3）</li><li>检查要发送的消息是否超出请求最大大小以及内存缓冲最大大小。</li><li>将消息添加到RecordAccumulator消息累加器中。（图示步骤4）</li><li>设置自定义的Callback回调函数以及对应的Intercepor。</li><li>如果某个分区对应的Batch满了，或者新创建了一个Batch就唤醒Sender线程发送消息。（图示步骤5）</li><li>Sender将Batch封装成ProduceRequest。（图示步骤6）</li><li>在发送Kafka前，消息还会保存在InFlightRequests中，然后发往服务端。（图示步骤7、8）</li><li>在服务端响应后调用Callback和Intercepor，清理InFlightRequests和RecordAccumulator中的缓存消息。（图示步骤9、10、11）</li></ol><blockquote><p>流程中涉及的InFlightRequests主要用来缓存已经发送出去但是还没有收到响应的请求。还可以获得LeastLoadedNode即所有Node中的最小负载，未确认的请求越多则认为负载越大。LeastLoadedNode的概念可以用于比如元数据请求、消费者组播协议的交互，避免因网络拥堵等异常而影响整体进度。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Kafka Producer负责向Kafka发送消息，最新的客户端为Java语言编写，但Kafka社区有提供其他语言的客户端，包括C/C++、Python、Go等。&lt;/p&gt;
&lt;p&gt;Kafka Producer支持三种消息发送模式：发后即忘、同步发送、异步发送。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】：初识篇</title>
    <link href="https://haifuns.com/2021/05/15/kafka-01/"/>
    <id>https://haifuns.com/2021/05/15/kafka-01/</id>
    <published>2021-05-15T01:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kafka起初是由LinkedIn公司采用Scala语言开发的一个多分区、多副本且基于ZooKeeper协调的分布式消息系统，现已捐献Apache基金会，定位为一个分布式流式处理平台，以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。</p><span id="more"></span><h1 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h1><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker pull wurstmeister/zookeeper</span><br><span class="line"><span class="variable">$</span> docker pull wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> docker run <span class="literal">-d</span> -<span class="literal">-name</span>=zookeeper <span class="literal">-p</span> <span class="number">2181</span>:<span class="number">2181</span> -<span class="literal">-restart</span> always wurstmeister/zookeeper</span><br><span class="line"><span class="variable">$</span> docker run <span class="literal">-d</span> -<span class="literal">-name</span> kafka <span class="literal">-p</span> <span class="number">9092</span>:<span class="number">9092</span> -<span class="literal">-restart</span>=always <span class="literal">-e</span> KAFKA_BROKER_ID=<span class="number">0</span> <span class="literal">-e</span> KAFKA_ZOOKEEPER_CONNECT=<span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">2181</span>/kafka <span class="literal">-e</span> KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://<span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">9092</span> <span class="literal">-e</span> KAFKA_LISTENERS=PLAINTEXT://:<span class="number">9092</span> -<span class="literal">-restart</span> always wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> docker exec <span class="literal">-it</span> kafka /bin/bash</span><br><span class="line">bash<span class="literal">-4</span>.<span class="number">4</span><span class="variable">$</span> kafka<span class="literal">-topics</span>.sh -<span class="literal">-zookeeper</span> <span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">2181</span>/kafka -<span class="literal">-create</span> -<span class="literal">-topic</span> topic<span class="literal">-demo</span>  -<span class="literal">-replication</span><span class="literal">-factor</span> <span class="number">1</span> -<span class="literal">-partitions</span> <span class="number">4</span> <span class="comment"># 创建主题，副本因子1，分区4</span></span><br><span class="line">bash<span class="literal">-4</span>.<span class="number">4</span><span class="variable">$</span> kafka<span class="literal">-topics</span>.sh -<span class="literal">-zookeeper</span> <span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">2181</span>/kafka -<span class="literal">-describe</span> -<span class="literal">-topic</span> topic<span class="literal">-demo</span> <span class="comment"># 查看主题信息</span></span><br><span class="line"></span><br><span class="line">bash<span class="literal">-4</span>.<span class="number">4</span><span class="variable">$</span> kafka<span class="literal">-console</span><span class="literal">-consumer</span>.sh -<span class="literal">-bootstrap</span><span class="literal">-server</span> <span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">9092</span> -<span class="literal">-topic</span> topic<span class="literal">-demo</span> <span class="comment"># 消费消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个终端</span></span><br><span class="line">bash<span class="literal">-4</span>.<span class="number">4</span><span class="variable">$</span> kafka<span class="literal">-console</span><span class="literal">-producer</span>.sh -<span class="literal">-broker</span><span class="literal">-list</span> <span class="number">192.168</span>.<span class="number">40.134</span>:<span class="number">9092</span> -<span class="literal">-topic</span> topic<span class="literal">-demo</span> <span class="comment"># 发送消息</span></span><br><span class="line">&gt;hello kafka</span><br></pre></td></tr></tbody></table></figure><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>典型的Kafka体系架构包含若干Producer、若干Broker、若干Consumer以及一个ZooKeeper集群。如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka01.png" alt="image"></p><p>其中：</p><ul><li>Producer为生产者，负责创建消息并投递到Kafka。</li><li>Consumer为消费者，从Kafka接收消息。</li><li>Broker为服务代理节点，可简单看做是一个Kafka服务实例。</li><li>ZooKeeper负责Kafka集群元数据管理和控制器选举等工作。</li></ul><p>Kafka中还有两个重要概念：</p><ol><li>Topic（主题）：主题是逻辑概念，消息以主题为单位归类，生产者将消息发送到指定主题，消费者订阅主题进行消费。</li><li>Partition（分区）：分区在存储层面可看作可追加日志文件。同一个主题可以细分为多个分区。同时分区也有多副本机制，leader副本负责处理读写请求，follower副本只负责同步leader消息。<ul><li>AR（Assigned Replicas）：分区中所有副本。AR = ISR + OSR。</li><li>ISR（In-Sync Replicas）：所有与leader副本保持一定程度同步的副本（包含leader副本）。<ul><li>HW（High Watermark）：高水位，标识特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。</li><li>LEO（Log End Offset）：标识当前日志文件中下一条待写入消息的offset。</li></ul></li><li>OSR（Out-of-Sync Replicas）：与leader副本同步滞后过多的副本，此状态的副本无选举资格。</li></ul></li></ol><p>消息在被追加到分区日志文件时会被分配一个唯一的偏移量（offset），用来保证消息在分区内的顺序性。但是offset并不跨区，也就是说Kafka保证的是分区有序而不是主题有序。</p><p>如下图所示，日志文件中有9条消息，起始消息offset为0，最后一条为8，offset=9表示下一条待写入的消息。日志文件的HW为6，表示消费者只能拉取到offset在[0,5]的消息。HW及以后的消息消费者不可见。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/kafka/kafka02.png" alt="image"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Kafka起初是由LinkedIn公司采用Scala语言开发的一个多分区、多副本且基于ZooKeeper协调的分布式消息系统，现已捐献Apache基金会，定位为一个分布式流式处理平台，以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://haifuns.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>常见限流方案设计</title>
    <link href="https://haifuns.com/2021/04/04/distribution-01/"/>
    <id>https://haifuns.com/2021/04/04/distribution-01/</id>
    <published>2021-04-04T12:46:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>限流在日常生活中很常见，比如在节假日期间去一个旅游景点，为了防止人流量过大，景点管理方通常会在入口处设置拦截，限制进入景点的人数，等有游客出去后才放新游客进去。对应到计算机中，比如要办活动、秒杀等，由于系统有自己的最大服务能力，即在达到某个临界点之前，系统都可以正常提供服务。为了保证系统在面临临界流量时仍然可以对外提供服务，这时就需要限流技术。</p><p>限流可以分为技术层面的限流和业务层面的限流。技术层面的限流比较通用，各个业务场景都可以用到。业务层面的限流则需要根据具体的业务场景做开发。</p><span id="more"></span><h1 id="技术层面的限流"><a href="#技术层面的限流" class="headerlink" title="技术层面的限流"></a>技术层面的限流</h1><p>技术层面的限流有两种方案：</p><ul><li>限制并发数，也就是根据系统的最大资源量进行限制，比如数据库连接池、线程池、Nginx的limit_conn模块。</li><li>限制速率（QPS），比如Guava的RateLimiter、Nginx的limit_req模块。</li></ul><p>限制速率这种方式对于服务的接口调用非常有用。比如通过压力测试知道服务的QPS是2000，那么就可以限流2000QPS。当调用方的并发量超过了这个数字会直接拒绝提供服务，虽然部分请求被拒绝了，但是保证了其他请求可以正常处理。</p><h1 id="业务层面的限流"><a href="#业务层面的限流" class="headerlink" title="业务层面的限流"></a>业务层面的限流</h1><p>比如在秒杀系统中，一个商品的库存只有100件，有2万人抢购，没有必要放2万个人进来，可以只放前500个，后面的人直接返回已售完即可。</p><p>针对这种业务场景，可以做一个限流系统（或者叫票据系统），票据系统中存放着500张票据，每进来一个人领一张票据，领到票据的人再进入后面的业务系统进行抢购。对于领不到票据的人，则返回已售完。</p><p>具体实现上，可以使用Redis或Nginx+Lua脚本实现。</p><h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p>常用的限流算法有计数器算法、漏桶算法、令牌桶算法和滑动时间窗口算法。</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器算法“简单粗暴”，该算法会维护一个counter，规定在单位时间内counter的大小不能超过最大值，每隔固定时间将counter值归零。如果counter值大于设定的阈值，那么系统就开始拒绝请求以保护系统的负载。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>如下图所示，在漏桶算法中会维护一个固定容量的桶，这个桶按照指定速率漏水。如果桶空了就停止漏水。</p><p>请求到达系统就类似于水加到桶中，这个速度可以是匀速的也可以瞬间的，如果桶满了就忽略后面来的请求，直到桶可以存放多余的水。</p><p>漏桶算法的好处是可以将系统的处理能力维持在一个比较平稳的水平，缺点是在瞬间流量过来时会拒绝后续的请求流量。</p><p>一般来说，代码实现时会使用一个队列实现“漏桶”效果，当请求过多时，队列中的请求开始积压，当队列满了系统就开始拒绝请求。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distribution/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶与漏桶算法的效果一致，但是原理相反：如下图所示，随着时间的流逝，系统会按照指定速率往令牌桶中添加token，每来一个新请求就从桶中拿走一个token，没有token就拒绝服务。这种算法的好处是便于控制系统的处理速度，甚至可以通过统计信息实时优化令牌桶的大小。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distribution/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p><p>漏桶算法和令牌桶算法一个是保持流出速率恒定，另一个是保持流入速率恒定。两者用途有一些差别，令牌桶限制的是平均流入速率而不是瞬时速率，因为可能出现一段时间没有请求进来，令牌桶中存满了令牌，然后短时间内突发流量过来，一瞬间从桶中拿令牌出来；漏桶有点类似消息队列，起到削峰的作用，平滑了突发流入速率。</p><blockquote><p>Guava中的concurrent包中提供了限流工具类RateLimiter，使用了令牌桶算法，它支持两种令牌获取接口：获取不到就一直阻塞；在指定时间内获取不到就阻塞，超过这个时间就返回获取失败。</p></blockquote><h2 id="滑动时间窗口算法"><a href="#滑动时间窗口算法" class="headerlink" title="滑动时间窗口算法"></a>滑动时间窗口算法</h2><p>滑动时间窗口算法就是根据当前时间获取对应的时间窗口，时间窗口保存有流量相关的统计值，根据该统计值判断是否触发流控。</p><p>一般来说，时间窗口可以循环复用，在复用时重新初始化即可。滑动时间窗口能够支持的瞬时流量最大可为该窗口上限，而令牌桶算法能够支持的瞬时流量最大为桶大小。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/distribution/%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95.png"></p><p>参考文献：</p><ul><li>《软件架构设计》</li><li>《高可用可伸缩微服务架构》</li><li><a href="https://www.cnblogs.com/hlkawa/p/13111003.html">限流相关的算法实现</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;限流在日常生活中很常见，比如在节假日期间去一个旅游景点，为了防止人流量过大，景点管理方通常会在入口处设置拦截，限制进入景点的人数，等有游客出去后才放新游客进去。对应到计算机中，比如要办活动、秒杀等，由于系统有自己的最大服务能力，即在达到某个临界点之前，系统都可以正常提供服务。为了保证系统在面临临界流量时仍然可以对外提供服务，这时就需要限流技术。&lt;/p&gt;
&lt;p&gt;限流可以分为技术层面的限流和业务层面的限流。技术层面的限流比较通用，各个业务场景都可以用到。业务层面的限流则需要根据具体的业务场景做开发。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="高可用" scheme="https://haifuns.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    <category term="分布式" scheme="https://haifuns.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="限流" scheme="https://haifuns.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper入门</title>
    <link href="https://haifuns.com/2021/03/21/zookeeper/"/>
    <id>https://haifuns.com/2021/03/21/zookeeper/</id>
    <published>2021-03-21T13:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://zookeeper.apache.org/">ZooKeeper</a>是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供高性能、高可用且具有严格顺序访问控制能力的分布式协调存储服务。</p><p>常被用于以下场景：</p><ol><li>分布式锁</li><li>元数据管理</li><li>分布式协调</li><li>master选举</li></ol><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://mirrors.bfsu.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz <span class="comment"># 下载安装包</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz <span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p /tmp/zookeeper</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> apache-zookeeper-3.6.2-bin/conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp zoo_sample.cfg zoo.cfg</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/apache-zookeeper-3.6.2-bin/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zkServer.sh start <span class="comment"># 启动服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zkServer.sh stop <span class="comment"># 停止服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zkServer.sh status <span class="comment"># 查看状态</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./zkCli.sh <span class="comment"># 进入客户端</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> create [-s] [-e] path data acl <span class="comment"># 创建节点</span></span></span><br><span class="line">        # -s表示顺序节点</span><br><span class="line">        # -e表示临时节点。默认持久节点</span><br><span class="line">        # path是节点路径</span><br><span class="line">        # data是节点数据</span><br><span class="line">        # acl用来进行权限控制</span><br><span class="line">        </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">set</span> path data <span class="comment"># 更新节点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> delete path [version] <span class="comment"># 删除节点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> get path <span class="comment"># 查看节点</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">stat</span> path <span class="comment"># 查看节点状态</span></span></span><br><span class="line">    # cZxid = 0x2 # 创建节点的事务ID</span><br><span class="line">    # ctime = Mon Mar 15 13:14:23 CST 2021 # 创建节点的时间</span><br><span class="line">    # mZxid = 0x2 # 最后更新节点的事务ID</span><br><span class="line">    # mtime = Mon Mar 15 13:14:23 CST 2021 # 最后更新节点的时间</span><br><span class="line">    # pZxid = 0x2 # 子节点最后一次被修改的事务ID</span><br><span class="line">    # cversion = 0 # 子节点的更改次数</span><br><span class="line">    # dataVersion = 0 # 节点数据的更改次数</span><br><span class="line">    # aclVersion = 0 # 节点的ACL更改次数</span><br><span class="line">    # ephemeralOwner = 0x0 # 节点类型，临时节点为创建节点的会话ID，持久节点为0</span><br><span class="line">    # dataLength = 3 # 数据长度</span><br><span class="line">    # numChildren = 0 # 子节点个数</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls path <span class="comment"># 查看节点列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -s path <span class="comment"># 查看节点增强列表，指定路径下的所有节点和当前节点的信息</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>Zookeeper的内存数据模型可以视为树形结构（或者目录），树中各个节点被称为znode（zookeeper node）。znode兼具文件和目录的特点，既像文件一样存储着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p><p>每个znode都有一个版本号，随每次数据变化而自增，修改或删除时版本号一致才会调用成功。</p><p>znode一共有四种类型：持久的、临时的、持久有序的和临时有序的。</p><h2 id="持久节点"><a href="#持久节点" class="headerlink" title="持久节点"></a>持久节点</h2><p>持久znode节点通常用来为应用保存数据，即使znode的创建者不再属于应用系统时，数据也不会丢失，只能通过delete命令删除。</p><h2 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h2><p>临时znode节点仅当创建者会话有效时保存数据，当创建该节点的客户端崩溃或者关闭连接时，临时节点就会被删除。</p><p>临时znode在以下两种场景会被删除：</p><ol><li>创建该znode的客户端会话因超时或主动关闭而终止时</li><li>当某个客户端（不一定是创建者）主动删除改节点时</li></ol><h2 id="有序节点"><a href="#有序节点" class="headerlink" title="有序节点"></a>有序节点</h2><p>znode可以设置为有序节点，有序znode节点被分配唯一一个全局单调递增的整数。当创建有序节点时，会在路径后追加一个序号。</p><h1 id="长连接和会话"><a href="#长连接和会话" class="headerlink" title="长连接和会话"></a>长连接和会话</h1><p>客户端与zk节点建立TCP连接，基于TCP长连接进行通信。建立连接时也会建立一个会话，通过心跳感知会话是否存在，超过sessionTimeout就认为会话断开。</p><h1 id="Watcher监听回调"><a href="#Watcher监听回调" class="headerlink" title="Watcher监听回调"></a>Watcher监听回调</h1><p>Zookeeper提供通知机制，客户端可以向Zookeeper注册需要接收通知的znode，通过对znode设置监视点（watch）来接收通知。需要注意的是监视点是一个单次触发的操作，为了接收多个通知，客户端必须在每次通知后设置一个新的监视点。</p><p><strong>在对同一个znode操作时，zk会先向客户端传送通知，然后再对节点进行变更。</strong> 其意义在于在znode发生连续多次变更时，客户端在第二次变化前就接收到了通知，然后读取znode中的数据。zk使用通知机制阻止客户端所观察的更新顺序，客户端以全局的顺序来观察zk状态。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> get -w path <span class="comment"># 监听节点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -w path <span class="comment"># 监听子节点</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><ul><li>Leader：选举成功为领导者节点，只有leader可以写入，写入操作原子性同步到follower</li><li>Follower：选举失败为从节点，写入请求转发到leader</li><li>Observer：与follower相同但是不参与选举</li></ul><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p><strong>只要有超过一半的机器认可，则可以选举为leader。</strong></p><p>只要有不超过一半的机器宕机就可以保证集群正常进行选举。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB即ZooKeeper原⼦⼴播协议 （ZooKeeper Atomic Broadcast protocol）。</p><ul><li>集群启动：恢复模式，leader选举（过半机器选举机制） + 数据同步</li><li>消息写入：消息广播模式，leader采用2PC模式的过半写机制，给follower进行同步</li><li>崩溃恢复：恢复模式，leader/follower宕机，只要剩余机器超过一半，集群宕机不超过一半的机器，就可以选举新的leader，数据同步</li></ul><p>ZAB协议提交事务流程如下（类似两阶段提交）：</p><ol><li>leader节点向所有follower节点发送proposal提议消息</li><li>follower节点收到提议消息后会将消息写到磁盘日志文件中，然后响应master一个ack消息</li><li>当leader收到超过半数节点的ack消息，就会发送消息给follower节点进行commit操作，follower收到commit消息后就将消息写入到内存中</li></ol><h3 id="主从同步机制"><a href="#主从同步机制" class="headerlink" title="主从同步机制"></a>主从同步机制</h3><p>集群启动时，会进行leader选举，选举完成后follower会跟leader进行数据同步。</p><p>同步完成后进入消息广播机制，只有leader可以接受写请求，但是客户端可以连接任意节点，如果连接follower，follower会把写请求转发给leader，leader收到写请求会把请求同步给follower，过半的follower响应后，leader发送commit消息给follower提交事务。</p><h3 id="崩溃恢复机制"><a href="#崩溃恢复机制" class="headerlink" title="崩溃恢复机制"></a>崩溃恢复机制</h3><p>如果leader宕机，就会进入恢复模式，重新选举leader，过半机器同意则选举出新leader，新leader等待follower同步数据，完成后进入广播模式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;ZooKeeper&lt;/a&gt;是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供高性能、高可用且具有严格顺序访问控制能力的分布式协调存储服务。&lt;/p&gt;
&lt;p&gt;常被用于以下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;元数据管理&lt;/li&gt;
&lt;li&gt;分布式协调&lt;/li&gt;
&lt;li&gt;master选举&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://haifuns.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="ZooKeeper" scheme="https://haifuns.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>网络基础</title>
    <link href="https://haifuns.com/2021/03/13/tcpip/"/>
    <id>https://haifuns.com/2021/03/13/tcpip/</id>
    <published>2021-03-13T08:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>国际标准化组织（ISO）提出的开放系统互连参考模型 (Open System Interconnect 简称OSI）将计算机网络体系结构的通信协议划分为七层，自下而上依次为：</p><ul><li>物理层（Physics Layer）</li><li>数据链路层（Data Link Layer）</li><li>网络层（Network Layer）</li><li>传输层（Transport Layer）</li><li>会话层（Session Layer）</li><li>表示层（Presentation Layer）</li><li>应用层（Application Layer）</li></ul><p>其中第四层完成数据传送服务，上面三层面向用户。</p><span id="more"></span><p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/tcpip/tcpip-model.png" alt="image"></p><h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><table><thead><tr><th>层数</th><th>分层名称</th><th>功能</th><th>实例</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>针对特定应用的协议</td><td>HTTP、FTP、DNS、Telnet、SMTP、POP3</td></tr><tr><td>6</td><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换</td><td>ASCII、GIF、JPEG</td></tr><tr><td>5</td><td>会话层</td><td>通信管理，负责建立和断开通信连接，管理传输层以下的分层</td><td>RPC、SQL、NFS</td></tr><tr><td>4</td><td>传输层</td><td>管理两个节点之间的数据传输，负责可靠传输</td><td>TCP、UDP，设备：网关</td></tr><tr><td>3</td><td>网络层</td><td>地址管理与路由选择</td><td>IP、ICMP、ARP、RARP，设备：路由器</td></tr><tr><td>2</td><td>数据链路层</td><td>互连设备之间传送和识别数据帧</td><td>IEEE 802.3，设备：网桥、交换机</td></tr><tr><td>1</td><td>物理层</td><td>以0、1代表电压高低、灯光的闪灭，界定连接器和网线的规格</td><td>RS232、v.35，设备：集线器、中继器</td></tr></tbody></table><ul><li>物理层</li></ul><p>负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。</p><ul><li>数据链路层</li></ul><p>负责物理层面上的互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。</p><ul><li>网络层</li></ul><p>将数据层传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一地址。因此这一层主要负责寻址和路由选择。</p><ul><li>传输层</li></ul><p>起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</p><ul><li>会话层</li></ul><p>负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p><ul><li>表示层</li></ul><p>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此表示层主要负责数据格式的转换。</p><ul><li>应用层</li></ul><p>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录（虚拟中端）等协议。</p><h1 id="IP：网际协议"><a href="#IP：网际协议" class="headerlink" title="IP：网际协议"></a>IP：网际协议</h1><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP以及IGMP数据都以IP数据报格式传输。要注意的是IP不是可靠的协议，也就是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址（IPv4）由32位正整数来表示，每8位一组，分成4组，每组以“.”隔开。理论上最多可以允许2^32台机器连接到网络。</p><p>IP地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一个网段内出现。</p><p>对于从第几位到第几位是主机标识，哪些位是主机标识，有约定俗成的两种区分类型：最初以分类进行区分；现在基本以子网掩码（网络前缀）区分。</p><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>IP地址分为四个级别，分别是A类、B类、C类、D类。根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p><ul><li>A类地址：以0开头，前8位是网络标识，地址范围是0.0.0.0 ~ 127.255.255.255；</li><li>B类地址：以10开头，前16位是网络标识，地址范围是128.0.0.0 ~ 191.255.255.255；</li><li>C类地址：以110开头，前24位是网络标识，地址范围是192.0.0.0 ~ 223.255.255.255；</li><li>D类地址：以1110开头，前32位是网络标识，地址范围是224.0.0.0 ~ 239.255.255.255，D类地址常被用于多播；</li><li>以1111开头的地址为保留地址，地址范围是240.0.0.0 ~ 255.255.255.255；</li></ul><blockquote><p>注：只有A，B，C有网络号和主机号之分，D类地址没有划分网络号和主机号。</p></blockquote><h1 id="UDP：用户数据报协议"><a href="#UDP：用户数据报协议" class="headerlink" title="UDP：用户数据报协议"></a>UDP：用户数据报协议</h1><p>用户数据报协议（UDP，User Datagram Protocol）是一种面向无连接的传输层协议，提供面向事务的简单不可靠传送服务。常被用于一下场景：</p><ul><li>包总量较少的通信（DNS、SNMP）等；</li><li>视频、音频等多媒体通信（即时通信）；</li><li>限定于LAN等特定网络中的应用通信；</li><li>广播通信（广播、多播）；</li></ul><h1 id="TCP：传输控制协议"><a href="#TCP：传输控制协议" class="headerlink" title="TCP：传输控制协议"></a>TCP：传输控制协议</h1><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h2><p>TCP数据被封装在一个IP数据报中，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/tcpip/tcp-header.png" alt="image"></p><p>图中同时展示了TCP首部的数据格式，如果不计任选字段，通常是20个字节。包含如下部分：</p><ul><li>源端和目的端的端口号：用于寻找发端和收端应用进程。这两个值加上IP首部中源端IP地址和目的端IP地址唯一确定一个TCP连接。</li><li>序号：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据字节。序号到达2^32-1后从0重新开始。</li><li>确认序号：包含发送确认的一端所期望收到的下一个序号。只有ACK标志为1时，确认序号才有效。</li><li>首部长度：首部中32bit字的数目。TCP首部最多60字节，如果没有任选字段，正常长度是20字节。</li><li>标志位：<ul><li>URG：紧急指针有效；</li><li>ACK：确认序号有效；</li><li>PSH：接收方应该尽快将这个报文段交给应用层；</li><li>SYN：同步序号用来发起一个连接；</li><li>FIN：发端完成发送任务；</li></ul></li><li>窗口大小：字节数，起始于确认序号字段指明的值，这个值是接收端期望收到的字节。窗口大小最大为65535字节。TCP流量控制由连接的每一端通过声明的窗口大小来提供。</li><li>检验和：覆盖TCP首部和TCP数据，由发端计算和存储、收端验证。</li><li>紧急指针：正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。只有URG标志设置为1时紧急指针才有效。</li><li>可选字段：最常见的可选字段是最长报文大小，又称为MSS。</li></ul><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>TCP连接建立与终止流程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/tcpip/tcp-conn.png" alt="image"></p><h3 id="连接建立：三次握手"><a href="#连接建立：三次握手" class="headerlink" title="连接建立：三次握手"></a>连接建立：三次握手</h3><ol><li>请求端发送一个SYN段指明客户打算连接的服务器端口，以及初始序号。</li><li>服务端发回包含服务器的初始序号的SYN报文段作为应答，同时设置ACK标志，将确认序号设置为客户的序号加1以对客户的SYN报文段进行确认。</li><li>客户必须将确认序号设置为服务器的序号加1以对服务器的SYN报文段进行确认。</li></ol><h3 id="连接断开：四次挥手"><a href="#连接断开：四次挥手" class="headerlink" title="连接断开：四次挥手"></a>连接断开：四次挥手</h3><ol><li>请求端发送FIN报文到服务端，进入FIN-WAIT-1状态。</li><li>服务端发回一个ACK报文，确认序号为收到的序号加1，然后进入CLOSE-WAIT状态。（服务端可能还有数据没有发完，客户端收到后进入FIN-WAIT-2状态继续等待服务端FIN消息）</li><li>服务端处理完数据后向客户端发送FIN报文，序号，ACK标志以及确认序号，然后进入LAST-ACK状态。</li><li>客户端收到FIN回复后，发送ACK报文到服务端，然后进入TIME-WAIT状态，等待2MSL后如果没有收到服务端重传请求则认为服务端已确认，进入CLOSE状态。</li></ol><h3 id="十万个为什么"><a href="#十万个为什么" class="headerlink" title="十万个为什么"></a>十万个为什么</h3><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>三次握手可以有效防止已失效的连接请求报文段突然又传送到了服务端而产生错误。</p><p>在两次“握手”的情形下，假设客户端在跟服务端建立连接过程中数据报丢失了（有可能数据传输过程因为网络并发量很大在某个结点被阻塞了），那么客户端会再次发起连接请求。这种情形下服务端将有可能先后收到两次请求并建立连接，然后持续等待两个客户端请求向它发送数据。此时服务端有两个响应而客户端实际上只有一次请求，因而造成资源浪费。</p><h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>TCP是全双工模式，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p><h4 id="为什么第四次挥手后要等待2MSL才关闭？"><a href="#为什么第四次挥手后要等待2MSL才关闭？" class="headerlink" title="为什么第四次挥手后要等待2MSL才关闭？"></a>为什么第四次挥手后要等待2MSL才关闭？</h4><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p>等待2MSL主要有两个原因：</p><ol><li>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</li><li>可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。</li></ol><blockquote><p>服务器在发送FIN-ACK后，会立即启动超时重传计时器。客户端在发送最后一个ACK之后会立即启动时间等待计时器。</p></blockquote><p>参考文章：</p><ul><li>《TCP/IP详解 卷一：协议》</li><li>《图解TCPIP》</li><li><a href="https://www.cnblogs.com/maybe2030/p/4781555.html">[Network] 计算机网络基础知识总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络层次划分&quot;&gt;&lt;a href=&quot;#网络层次划分&quot; class=&quot;headerlink&quot; title=&quot;网络层次划分&quot;&gt;&lt;/a&gt;网络层次划分&lt;/h1&gt;&lt;p&gt;国际标准化组织（ISO）提出的开放系统互连参考模型 (Open System Interconnect 简称OSI）将计算机网络体系结构的通信协议划分为七层，自下而上依次为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层（Physics Layer）&lt;/li&gt;
&lt;li&gt;数据链路层（Data Link Layer）&lt;/li&gt;
&lt;li&gt;网络层（Network Layer）&lt;/li&gt;
&lt;li&gt;传输层（Transport Layer）&lt;/li&gt;
&lt;li&gt;会话层（Session Layer）&lt;/li&gt;
&lt;li&gt;表示层（Presentation Layer）&lt;/li&gt;
&lt;li&gt;应用层（Application Layer）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中第四层完成数据传送服务，上面三层面向用户。&lt;/p&gt;</summary>
    
    
    
    <category term="TCP/IP" scheme="https://haifuns.com/categories/TCP-IP/"/>
    
    
    <category term="TCP/IP" scheme="https://haifuns.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus+Grafana监控JVM</title>
    <link href="https://haifuns.com/2021/02/25/devops-02/"/>
    <id>https://haifuns.com/2021/02/25/devops-02/</id>
    <published>2021-02-25T12:26:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置JMX-Exporter"><a href="#配置JMX-Exporter" class="headerlink" title="配置JMX Exporter"></a>配置JMX Exporter</h1><h2 id="下载jmx-exporter"><a href="#下载jmx-exporter" class="headerlink" title="下载jmx_exporter"></a>下载jmx_exporter</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /opt/monitor/jmx_exporter</span><br><span class="line">$ chmod 777 -R /opt/monitor/jmx_exporter</span><br><span class="line">$ wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.3.1/jmx_prometheus_javaagent-0.3.1.jar</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/monitor/jmx_exporter/jmx_exporter.yml</span><br></pre></td></tr></tbody></table></figure><p>jmx_exporter.yml文件内容如下：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lowercaseOutputLabelNames:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">lowercaseOutputName:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">whitelistObjectNames:</span> [<span class="string">"java.lang:type=OperatingSystem"</span>]</span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">'java.lang&lt;type=OperatingSystem&gt;&lt;&gt;((?!process_cpu_time)w+):'</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">os_$1</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">GAUGE</span></span><br><span class="line">   <span class="attr">attrNameSnakeCase:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h1 id="配置应用程序"><a href="#配置应用程序" class="headerlink" title="配置应用程序"></a>配置应用程序</h1><h2 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h2><p><code>java -jar -javaagent:/opt/monitor/jmx_exporter/jmx_prometheus_javaagent-0.3.1.jar=8099:/opt/monitor/jmx_exporter/jmx_exporter.yml app.jar</code></p><h2 id="docker运行"><a href="#docker运行" class="headerlink" title="docker运行"></a>docker运行</h2><ol><li>修改启动配置：添加<code>-javaagent:/opt/monitor/jmx_exporter/jmx_prometheus_javaagent-0.3.1.jar=8099:/opt/monitor/jmx_exporter/jmx_exporter.yml</code></li><li>挂载数据卷：<code>-v /opt/monitor/jmx_exporter:/opt/monitor/jmx_exporter</code></li><li>添加端口映射：<code>-p 8099:8099</code></li><li>创建容器</li></ol><h1 id="配置Prometheus拉取监控指标"><a href="#配置Prometheus拉取监控指标" class="headerlink" title="配置Prometheus拉取监控指标"></a>配置Prometheus拉取监控指标</h1><ol><li>在prometheus.yml中添加任务：</li></ol><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'java'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'ip:port'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'ip:port'</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>重启prometheus</li></ol><h1 id="配置Grafana模板"><a href="#配置Grafana模板" class="headerlink" title="配置Grafana模板"></a>配置Grafana模板</h1><ol><li>配置Prometheus数据源</li><li>添加<a href="https://grafana.com/grafana/dashboards/8563/revisions">JVM dashboard</a>模板</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;配置JMX-Exporter&quot;&gt;&lt;a href=&quot;#配置JMX-Exporter&quot; class=&quot;headerlink&quot; title=&quot;配置JMX Exporter&quot;&gt;&lt;/a&gt;配置JMX Exporter&lt;/h1&gt;&lt;h2 id=&quot;下载jmx-exporter&quot;&gt;&lt;a href=&quot;#下载jmx-exporter&quot; class=&quot;headerlink&quot; title=&quot;下载jmx_exporter&quot;&gt;&lt;/a&gt;下载jmx_exporter&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir -p /opt/monitor/jmx_exporter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ chmod 777 -R /opt/monitor/jmx_exporter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.3.1/jmx_prometheus_javaagent-0.3.1.jar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://haifuns.com/categories/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://haifuns.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建Prometheus+Grafana监控</title>
    <link href="https://haifuns.com/2021/02/25/devops-01/"/>
    <id>https://haifuns.com/2021/02/25/devops-01/</id>
    <published>2021-02-25T12:25:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><p>监控组件说明：</p><ul><li>Grafana：负责展示数据。</li><li>Prometheus：负责收集数据。其中采用Prometheus中的Exporter：<ul><li>Node Exporter：负责收集硬件和操作系统数据。</li><li>Cadvisor：负责收集容器数据。</li><li>Alertmanager：负责告警。</li></ul></li></ul><p>运行环境准备：</p><ul><li>docker</li><li>docker-compose</li></ul><span id="more"></span><h1 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h1><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /opt/docker-compose</span><br><span class="line">$ mkdir -p /opt/monitor/config</span><br><span class="line"></span><br><span class="line">$ mkdir -p /opt/monitor/prometheus/data</span><br><span class="line">$ chmod 777 -R /opt/monitor/prometheus/data</span><br><span class="line">$ mkdir -p /opt/monitor/grafana/data</span><br><span class="line">$ chmod 777 -R /opt/monitor/grafana/data</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> /opt/monitor/config</span><br><span class="line">$ vi prometheus.yml <span class="comment"># 添加prometheus配置文件</span></span><br><span class="line">$ vi alertmanager.yml <span class="comment"># 添加alertmanager配置，配置收发邮件邮箱</span></span><br><span class="line">$ vi node_down.yml <span class="comment"># 添加node exporter配置，配置告警规则</span></span><br></pre></td></tr></tbody></table></figure><h2 id="prometheus-yml"><a href="#prometheus-yml" class="headerlink" title="prometheus.yml"></a>prometheus.yml</h2><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'alertmanager:9093'</span>]</span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"node_down.yml"</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'prometheus:9090'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'cadvisor'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'cadvisor:8080'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'node'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">8s</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">'node-exporter:9100'</span>]</span><br></pre></td></tr></tbody></table></figure><h2 id="alertmanager-yml"><a href="#alertmanager-yml" class="headerlink" title="alertmanager.yml"></a>alertmanager.yml</h2><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">smtp_smarthost:</span> <span class="string">''</span>        <span class="comment"># 邮箱服务器</span></span><br><span class="line">  <span class="attr">smtp_from:</span> <span class="string">''</span>             <span class="comment"># 发件邮箱</span></span><br><span class="line">  <span class="attr">smtp_auth_username:</span> <span class="string">''</span>    <span class="comment"># 用户名</span></span><br><span class="line">  <span class="attr">smtp_auth_password:</span> <span class="string">''</span>    <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">smtp_require_tls:</span> <span class="literal">false</span>   <span class="comment"># 不进行tls验证</span></span><br><span class="line"></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">'alertname'</span>]</span><br><span class="line">  <span class="attr">group_wait:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">10m</span></span><br><span class="line">  <span class="attr">receiver:</span> <span class="string">live-monitoring</span></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">'live-monitoring'</span></span><br><span class="line">  <span class="attr">email_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">''</span>                  <span class="comment"># 收件邮箱</span></span><br></pre></td></tr></tbody></table></figure><h2 id="node-down-yml"><a href="#node-down-yml" class="headerlink" title="node_down.yml"></a>node_down.yml</h2><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node_down</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">"Instance <span class="template-variable">{{ $labels.instance }}</span> down"</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">"<span class="template-variable">{{ $labels.instance }}</span> of job <span class="template-variable">{{ $labels.job }}</span> has been down for more than 1 minutes."</span></span><br></pre></td></tr></tbody></table></figure><h1 id="编写docker-compose"><a href="#编写docker-compose" class="headerlink" title="编写docker-compose"></a>编写docker-compose</h1><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /opt/docker-compose</span><br><span class="line">$ vi docker-compose-monitor.yml</span><br></pre></td></tr></tbody></table></figure><h2 id="docker-compose-monitor-yml"><a href="#docker-compose-monitor-yml" class="headerlink" title="docker-compose-monitor.yml"></a>docker-compose-monitor.yml</h2><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">    <span class="attr">monitor:</span></span><br><span class="line">        <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">prometheus:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/prometheus</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/opt/monitor/config/prometheus.yml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/opt/monitor/config/node_down.yml:/etc/prometheus/node_down.yml</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/opt/monitor/prometheus/data:/prometheus</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">'--config.file=/etc/prometheus/prometheus.yml'</span> <span class="comment"># 加载主配置文件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">'--storage.tsdb.path=/prometheus'</span> <span class="comment"># 启动数据持久存储</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"9090:9090"</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">grafana:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">grafana/grafanai</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">grafana</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/opt/monitor/grafana/data:/var/lib/grafana</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">alertmanager:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">prom/alertmanager</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">alertmanager</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">alertmanager</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/opt/monitor/config/alertmanager.yml:/etc/alertmanager/alertmanager.yml</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"9093:9093"</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line">            </span><br><span class="line">    <span class="attr">node-exporter:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/prometheus/node-exporter</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">node-exporter</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"9100:9100"</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">monitor</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">cadvisor:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">google/cadvisor:latest</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">cadvisor</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">cadvisor</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">monitor</span></span><br></pre></td></tr></tbody></table></figure><h1 id="启动docker-compose"><a href="#启动docker-compose" class="headerlink" title="启动docker-compose"></a>启动docker-compose</h1><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">$ docker-compose -f /opt/docker-compose/docker-compose-monitor.yml up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">$ docker-compose -f /opt/docker-compose/docker-compose-monitor.yml down</span><br></pre></td></tr></tbody></table></figure><h1 id="监控使用"><a href="#监控使用" class="headerlink" title="监控使用"></a>监控使用</h1><ul><li>Prometheus地址： <a href="http://ip:9090/">http://ip:9090</a></li><li>服务状态：<a href="http://ip:9090/targets">http://ip:9090/targets</a></li><li>Grafana地址：<a href="http://ip:3000/">http://ip:3000</a></li></ul><p>在Grafana中添加Prometheus数据源：<code>Configuration -&gt; DataSource -&gt; Prometheus</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h1&gt;&lt;p&gt;监控组件说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana：负责展示数据。&lt;/li&gt;
&lt;li&gt;Prometheus：负责收集数据。其中采用Prometheus中的Exporter：&lt;ul&gt;
&lt;li&gt;Node Exporter：负责收集硬件和操作系统数据。&lt;/li&gt;
&lt;li&gt;Cadvisor：负责收集容器数据。&lt;/li&gt;
&lt;li&gt;Alertmanager：负责告警。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;docker-compose&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://haifuns.com/categories/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://haifuns.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】内存管理</title>
    <link href="https://haifuns.com/2021/02/13/redis-07/"/>
    <id>https://haifuns.com/2021/02/13/redis-07/</id>
    <published>2021-02-13T06:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h1><h2 id="内存使用统计"><a href="#内存使用统计" class="headerlink" title="内存使用统计"></a>内存使用统计</h2><p>通过执行<code>info memory</code>命令可以获取Redis内存相关指标。内存统计指标和对应解释如下表所示：</p><table><thead><tr><th>属性名</th><th>属性描述</th></tr></thead><tbody><tr><td>used_memory</td><td>内存存储的所有数据内存占用量</td></tr><tr><td>used_memory_human</td><td>以可读的格式返回used_memory</td></tr><tr><td>used_memory_rss</td><td>从操作系统的角度显示Redis进程占用的物理内存总量</td></tr><tr><td>used_memory_peak</td><td>内存使用的最大值，表示used_memory的峰值</td></tr><tr><td>used_memory_peak_human</td><td>以可读格式返回used_memory_peak</td></tr><tr><td>used_memory_lua</td><td>Lua引擎消耗的内存大小</td></tr><tr><td>mem_fragmentation_ratio</td><td>used_memory_rss/used_memory比值，表示内存碎片率。大于1表示used_memory_rss - used_memory多出的部分内存被内存碎片消耗；小于1一般是操作系统把Redis内存交换到磁盘导致</td></tr><tr><td>mem_allocator</td><td>Redis使用的内存分配器，默认为jemalloc</td></tr></tbody></table><span id="more"></span><h2 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h2><p>Redis进程内内存消耗主要包括：自身内存、对象内存、缓冲内存、内存碎片。</p><p>其中Redis空进程自身内存消耗非常小，通常used_memory_rss在3MB左右，used_memory在800KB左右，一个空Redis进程消耗内存可以忽略不计。</p><p>对象内存是Redis内存占用最大的一块，存储着用户所有数据。</p><p>缓冲内存主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。</p><h2 id="子进程内存消耗"><a href="#子进程内存消耗" class="headerlink" title="子进程内存消耗"></a>子进程内存消耗</h2><p>子进程内存消耗主要是指AOF/RDB重写时Redis创建的子进程内存消耗。Redis执行fork操作产生的子进程不需要消耗1倍父进程内存，实际消耗根据期间写入的命令量决定，但是依然要预留出一些内存防止溢出。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存上限"><a href="#内存上限" class="headerlink" title="内存上限"></a>内存上限</h2><p>Redis默认无限使用服务器内存，使用maxmemory参数可以限制最大可用内存。需要注意的是，maxmemory限制的是Redis实际使用的内存量，也就是used_memory统计的内存。由于内存碎片率的存在，实际消耗内存可能会大于maxmemory设置的值。</p><p>Redis内存上限可以通过<code>config set maxmemory</code>进行动态修改。</p><h2 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h2><p>Redis的内存回收机制主要体现在两个方面：</p><ul><li>删除达到过期时间的键对象</li><li>内存使用达到maxmemory上限时触发内存溢出控制策略</li></ul><h2 id="删除过期键对象"><a href="#删除过期键对象" class="headerlink" title="删除过期键对象"></a>删除过期键对象</h2><p>Redis所有键都可以设置过期属性，由于进程内保存大量键，维护每个键精准的过期删除机制会导致消耗大量的CPU成本过高，因此Redis采用惰性删除和定时任务删除机制实现过期键的内存回收。</p><ul><li>惰性删除：用于当客户端读取带有超时属性的键时，如果已经超出键设置的过期时间，会执行删除操作并返回空。</li><li>定时任务删除：Redis内部维护着一个定时任务，默认每秒运行10次。其中删除过期键逻辑采用自适应算法，根据键的过期比例使用快慢两种速率模式回收，快慢两种模式删除逻辑相同只是超时时间不同。任务流程如下：<ul><li>定时任务在每个数据库随机检查20个键，当发现过期时删除对应键。</li><li>如果超过检查数25%的键过期，循环执行回收逻辑直到不足25%或运行超时（慢模式下超时时间为25ms）</li><li>如果之前回收键逻辑超时，则在Redis触发内部事件前再次以快模式回收（快模式下超时时间为1ms且2s内只能运行1次）</li></ul></li></ul><h2 id="内存溢出控制策略"><a href="#内存溢出控制策略" class="headerlink" title="内存溢出控制策略"></a>内存溢出控制策略</h2><p>当Redis所用的内存达到maxmemory上限时会触发相应的溢出控制策略。具体策略受maxmemoey-policy参数控制，支持6种策略：</p><ol><li>noeviction：默认策略，不会删除任何数据，拒绝写入并返回OOM错误</li><li>volatile-lru：根据LRU算法删除最近最少使用且设置了超时属性的键，直到腾出足够空间，如果没有可以删除的键则回退到noeviction策略</li><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止</li><li>allkeys-random：随机删除所有键，直到腾出足够空间</li><li>volatile-random：随机删除设置过期时间的键，直到腾出足够空间</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期的数据，如果没有回退到noevication策略</li><li>volatile-lfu：redis4.0新增，根据LFU算法删除最不经常使用且设置了超时属性的键</li><li>allkeys-lfu：redis4.0新增，根据LFU算法删除所有键</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;内存消耗&quot;&gt;&lt;a href=&quot;#内存消耗&quot; class=&quot;headerlink&quot; title=&quot;内存消耗&quot;&gt;&lt;/a&gt;内存消耗&lt;/h1&gt;&lt;h2 id=&quot;内存使用统计&quot;&gt;&lt;a href=&quot;#内存使用统计&quot; class=&quot;headerlink&quot; title=&quot;内存使用统计&quot;&gt;&lt;/a&gt;内存使用统计&lt;/h2&gt;&lt;p&gt;通过执行&lt;code&gt;info memory&lt;/code&gt;命令可以获取Redis内存相关指标。内存统计指标和对应解释如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;属性描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;used_memory&lt;/td&gt;
&lt;td&gt;内存存储的所有数据内存占用量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used_memory_human&lt;/td&gt;
&lt;td&gt;以可读的格式返回used_memory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used_memory_rss&lt;/td&gt;
&lt;td&gt;从操作系统的角度显示Redis进程占用的物理内存总量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used_memory_peak&lt;/td&gt;
&lt;td&gt;内存使用的最大值，表示used_memory的峰值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used_memory_peak_human&lt;/td&gt;
&lt;td&gt;以可读格式返回used_memory_peak&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;used_memory_lua&lt;/td&gt;
&lt;td&gt;Lua引擎消耗的内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mem_fragmentation_ratio&lt;/td&gt;
&lt;td&gt;used_memory_rss/used_memory比值，表示内存碎片率。大于1表示used_memory_rss - used_memory多出的部分内存被内存碎片消耗；小于1一般是操作系统把Redis内存交换到磁盘导致&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mem_allocator&lt;/td&gt;
&lt;td&gt;Redis使用的内存分配器，默认为jemalloc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：核心参数</title>
    <link href="https://haifuns.com/2021/02/10/jvm-7/"/>
    <id>https://haifuns.com/2021/02/10/jvm-7/</id>
    <published>2021-02-10T15:42:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<ul><li>-Xms/-XX:InitialHeapSize ：初始堆大小，默认物理内存1/64</li><li>-Xmx/-XX:MaxHeapSize ：最大堆大小，默认物理内存1/4</li><li>-Xmn ：新生代大小</li><li>-XX:PermSize/-XX:MetaspaceSize ：永久代大小</li><li>-XX:MaxPermSize/-XX:MaxMetaspaceSize ：永久代最大大小</li><li>-Xss ：每个线程的栈内存大小</li><li>-XX:NewSize ：新生代大小</li><li>-XX:MaxNewSize ：新生代最大大小</li><li>-XX:NewRatio ：老年代与新生代比值，默认2即比值2:1</li><li>-XX:SurvivorRatio ：eden区与survivor区比值，默认为8</li><li>-XX:MaxTenuringThreshold ：对象晋升到老年代的GC次数阈值，默认为15</li><li>-XX:PretenureSizeThreshold ：大对象直接晋升老年代的字节阈值</li><li>-XX:HandlePromotionFailure ：设置空间分配担保，jdk1.6后已废弃</li><li>-XX:SoftRefLRUPolicyMSPerMB ：设置软引用能跨越的GC周期</li><li>-XX:+DisableExplicitGC ：禁止使用System.gc()手动触发GC<span id="more"></span></li></ul><hr><ul><li>-XX:+UseParNewGC ：使用ParNew作为新生代收集器</li><li>-XX:ParallelGCThreads ：并行GC线程数，默认为CPU核心数</li></ul><hr><ul><li>-XX:+UseConcMarkSweepGC ：使用CMS作为老年代收集器，Serial Old将作为CMS出错后的后备收集器</li><li>-XX:CMSInitiatingOccupancyFraction ：CMS收集器在老年代空间被使用多少后触发回收，jdk1.6默认92%</li><li>-XX:+UseCMSCompactAtFullCollection ：在Full GC后进行Stop The World，停止工作线程进行内存碎片整理，默认开启</li><li>-XX:CMSFullGCsBeforeCompaction ：在执行多少次Full GC后执行碎片整理，默认0即每次Full GC都进行内存整理</li><li>-XX:+CMSParallelInitialMarkEnabled ：CMS“初始标记”阶段多线程并发开关</li><li>-XX:+CMSScavengeBeforeRemark ：CMS“重新标记”阶段之前尽量执行一次Young GC</li><li>-XX:+CMSParallelRemarkEnabled : 手动配置开启CMS“并行标记”</li></ul><hr><ul><li>-XX:+UseG1GC ：使用G1收集器，jdk1.9后默认</li><li>-XX:G1HeapRegionSize ：指定Region大小，取值范围1MB ~ 32MB，应为2的N次幂</li><li>-XX:G1NewSizePercent ：G1新生代初始占比，默认5%</li><li>-XX:G1MaxNewSizePercent ：G1新生代最大占比，默认60%</li><li>-XX:MaxGCPauseMills ：G1目标停顿时间，默认200ms</li><li>-XX:InitiatingHeapOccupancyLPercent ：G1老年代占比Region多少触发混合回收，默认45%</li><li>-XX:G1MixedGCCountTarget ：G1混合回收中最后一个阶段执行混合垃圾回收的目标次数，默认8次</li><li>-XX:G1HeapWastePercent ：空闲Region达到堆指定占比停止混合回收，默认5%</li><li>-XX:G1MixedGCLiveThresholdPercent ：存活对象占比Region低于多少可以进行回收，默认85%</li></ul><hr><ul><li>-XX:+HeapDumpOnOutOfMemoryError ： OOM时自动生成dump文件</li><li>-XX:HeapDumpPath ：指定dump导出路径</li><li>-XX:+PrintGCDetails ：打印详细GC日志</li><li>-XX:+PrintGCTimeStamps ：打印每次GC发生的时间</li><li>-XX:+PrintHeapAtGC ：每次GC后打印堆信息</li><li>-Xloggc:gc.log ：指定GC日志</li><li>-XX:+TraceClassLoading ：追踪类加载输出到日志</li><li>-XX:+TraceClassUnloading ：追踪类卸载输出到日志</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;-Xms/-XX:InitialHeapSize ：初始堆大小，默认物理内存1/64&lt;/li&gt;
&lt;li&gt;-Xmx/-XX:MaxHeapSize ：最大堆大小，默认物理内存1/4&lt;/li&gt;
&lt;li&gt;-Xmn ：新生代大小&lt;/li&gt;
&lt;li&gt;-XX:PermSize/-XX:MetaspaceSize ：永久代大小&lt;/li&gt;
&lt;li&gt;-XX:MaxPermSize/-XX:MaxMetaspaceSize ：永久代最大大小&lt;/li&gt;
&lt;li&gt;-Xss ：每个线程的栈内存大小&lt;/li&gt;
&lt;li&gt;-XX:NewSize ：新生代大小&lt;/li&gt;
&lt;li&gt;-XX:MaxNewSize ：新生代最大大小&lt;/li&gt;
&lt;li&gt;-XX:NewRatio ：老年代与新生代比值，默认2即比值2:1&lt;/li&gt;
&lt;li&gt;-XX:SurvivorRatio ：eden区与survivor区比值，默认为8&lt;/li&gt;
&lt;li&gt;-XX:MaxTenuringThreshold ：对象晋升到老年代的GC次数阈值，默认为15&lt;/li&gt;
&lt;li&gt;-XX:PretenureSizeThreshold ：大对象直接晋升老年代的字节阈值&lt;/li&gt;
&lt;li&gt;-XX:HandlePromotionFailure ：设置空间分配担保，jdk1.6后已废弃&lt;/li&gt;
&lt;li&gt;-XX:SoftRefLRUPolicyMSPerMB ：设置软引用能跨越的GC周期&lt;/li&gt;
&lt;li&gt;-XX:+DisableExplicitGC ：禁止使用System.gc()手动触发GC&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】集群</title>
    <link href="https://haifuns.com/2021/02/01/redis-06/"/>
    <id>https://haifuns.com/2021/02/01/redis-06/</id>
    <published>2021-02-01T14:50:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。</p><span id="more"></span><h1 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h1><h2 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h2><p>分布式数据库会把整个数据集按照分区规则映射到多个节点上，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。</p><p>常见的分区规则有哈希分区和顺序分区两种。区别如下表所示：</p><table><thead><tr><th>分区方式</th><th>特点</th></tr></thead><tbody><tr><td>哈希分区</td><td>离散度好；数据分布与业务无关；无法顺序访问</td></tr><tr><td>顺序分区</td><td>离散度易倾斜；数据分布与业务有关；可顺序访问</td></tr></tbody></table><p>Redis Cluster采用的是哈希分区规则，下面重点讨论哈希分区，常见的哈希分区规则有以下几种：</p><ol><li>节点取余分区</li></ol><p>使用特定的数据，如Redis的键或者用户id，根据节点数量N使用公式：hash(key) % N 计算出哈希值，用来决定数据映射到哪一个节点上。</p><p>这种方式存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p><p>节点取余分区使用简单，常用于数据库的分库分表规则，一般采用预分区的方式，提前规划好分区数，扩容时采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。</p><ol start="2"><li>一致性哈希分区</li></ol><p>一致性哈希分区（Distributed Hash Table）实现思路是为系统的每个节点分配一个token，范围一般在0 ~ 2^32，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。</p><p>一致性哈希分区相比节点取余最大的好处在于新增或删除节点只影响哈希环中相邻的节点，对其他节点没有影响。但是一致性哈希分区存在以下几个问题：</p><ul><li>加减节点会造成哈希环中部分数据无法命中，需要手动处理或忽略这部分数据，因此一致性哈希常用于缓存场景</li><li>当使用少量节点时，节点变换将大范围影响哈希环数据映射，因此不适合少量数据节点的分布式方案</li><li>普通的一致性哈希分区在增减节点时需要增加一倍或减少一半节点才能保证数据和负载的均衡</li></ul><ol start="3"><li>虚拟槽分区</li></ol><p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远大于节点数，比如Redis Cluster槽范围是0 ~ 16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。</p><h2 id="Redis数据分区"><a href="#Redis数据分区" class="headerlink" title="Redis数据分区"></a>Redis数据分区</h2><p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0 ~ 16383整数槽内，计算公式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = CRC16(key) &amp; 16383</span><br></pre></td></tr></tbody></table></figure><p>每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p>Redis虚拟槽分区特点如下：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景</li></ul><h2 id="集群功能限制"><a href="#集群功能限制" class="headerlink" title="集群功能限制"></a>集群功能限制</h2><p>Redis集群相对单机在功能上存在一些限制：</p><ol><li>key批量操作支持有限。如mset/mget，目前只支持具有相同slot值的key执行批量操作。对于映射为不同slot值的key由于执行mget、mset等操作可能存在于多个节点上因此不被支持。</li><li>key事务操作支持有限。同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。</li><li>key作为数据分区的最小粒度。</li><li>不支持多数据库空间。单机下Redis可以支持16个数据库，集群模式下只能使用一个数据库即db0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li></ol><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><p>搭建集群分为以下三个步骤：</p><ol><li>准备节点</li><li>节点握手</li><li>分配槽</li></ol><h2 id="准备节点"><a href="#准备节点" class="headerlink" title="准备节点"></a>准备节点</h2><p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。</p><p>建议为集群内所有节点统一目录，一般划分为三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下，集群相关配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6379 #节点端口</span><br><span class="line">cluster-enabled yes # 开启集群模式</span><br><span class="line">cluster-node-timeout 15000 # 节点超时时间，单位毫秒</span><br><span class="line">cluster-config-file "nodes-6379.conf" # 集群内部配置文件</span><br></pre></td></tr></tbody></table></figure><p>其他配置和单机模式一致即可，配置文件命令规则redis-{port}.conf，准备好配置后启动所有节点，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6380.conf</span><br><span class="line">redis-server conf/redis-6381.conf</span><br><span class="line">redis-server conf/redis-6382.conf</span><br><span class="line">redis-server conf/redis-6383.conf</span><br><span class="line">redis-server conf/redis-6384.conf</span><br></pre></td></tr></tbody></table></figure><p>Redis节点第一次启动时如果没有配置文件则会自动创建，文件名由cluster-config-file参数项控制，建议使用node-{port}.conf格式定义，使用端口号区分不同节点，防止同一机器侠多个节点彼此覆盖，造成集群信息异常。如果启动时存在集群配置文件，节点会使用配置文件内容初始化集群信息。启动过程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-cluster-start.png" alt="Redis集群模式启动过程"></p><p>集群文件中记录着集群的状态信息，其中最重要的是节点Id，是一个40位16进制的字符串，用于唯一标识集群内的节点，节点Id重启不会变化。</p><h2 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h2><p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命令：<code>cluster meet {ip} {port}</code>，cluster meet是一个异步命令，执行后立刻返回。节点内部发起与目标节点进行握手通信，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-cluster-meet.png" alt="cluster meet命令进行节点握手的过程"></p><ol><li>节点6379本地创建6380节点信息对象，并发送meet消息</li><li>节点6380接收到meet消息后，保存6379节点信息并回复pong消息</li><li>之后节点6379与6380彼此定期通过ping/pong消息进行节点通信</li></ol><p>只需要在集群内任意节点执行cluster meet命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程。最后使用cluster nodes命令确认6个节点彼此感知并组成集群。</p><h2 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h2><p>在节点建立握手后，集群还不能正常工作，集群处于下线状态，数据读写被禁止。使用cluster info命令可以获取集群当前状态。只有当16384个槽全部分配给节点后，集群才进入在线状态。</p><p>Redis把所有的数据映射到16348个槽中。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的命令。</p><p>通过cluster addslots命令为节点分配槽。利用bash特性批量设置槽命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots {0...5461}</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots {5462...10922}</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots {10923...16383}</span><br></pre></td></tr></tbody></table></figure><p>把16384个slot平均分配给6379、6380、6381三个节点。执行cluster info命令可查看集群状态。</p><p>集群模式下，Reids节点角色分为主节点和从节点。使用cluster replicate {nodeId} 命令让剩余三个节点分别成为从节点，nodeId是要复制主节点的节点Id。</p><blockquote><p>Redis官方另外提供redis-trib.rb工具方便快速搭建集群</p></blockquote><h1 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h1><h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><p>Redis集群采用P2P的Gossip（流言）协议维护节点信息等元数据信息。Gossip协议的工作原理是节点彼此不断通信交换信息，一段时间后所有节点就会知道集群完整信息，这种方式类似于流言传播。</p><p>通信过程如下：</p><ol><li>集群中每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000</li><li>每个节点在固定周期内通过特定规则选择几个节点发送ping信息</li><li>接收到ping信息的节点用pong消息响应</li></ol><h2 id="Gossip消息"><a href="#Gossip消息" class="headerlink" title="Gossip消息"></a>Gossip消息</h2><p>Gossip协议的主要职责是信息交换。消息交换的载体是节点彼此发送的Gossip消息。</p><p>常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息等。它们之间的通信模式如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-gossip.png" alt="Gossip 通信模式"></p><ul><li>meet消息：用于通知新节点加入。</li><li>ping消息：用于检测节点是否在线和交换彼此状态信息，ping消息发送封装了自身节点和其他节点的状态信息。ping消息是集群内交换最频繁的消息。</li><li>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li><li>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到后把对应节点更新为下线状态。</li></ul><p>所有的消息格式划分为：消息头和消息体。消息头中包含发送节点关键数据，如节点id、槽映射、节点标识（主从角色，是否下线）等。</p><h1 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h1><h2 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h2><p>Redis集群扩容操作分为三步：</p><ol><li>准备新节点</li><li>加入集群</li><li>迁移槽和数据</li></ol><h3 id="准备新节点"><a href="#准备新节点" class="headerlink" title="准备新节点"></a>准备新节点</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6385.conf</span><br><span class="line">redis-server conf/redis-6386.conf</span><br></pre></td></tr></tbody></table></figure><p>新启动的节点作为孤儿节点运行，并没有与其他节点通信。</p><h3 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6385</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6386</span><br></pre></td></tr></tbody></table></figure><p>集群内新旧节点经过一段时间的ping/pong消息通信后，所有节点会发现新节点并保存状态到本地。新节点由于没有分配槽所以还不能接受读写操作。</p><h3 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h3><p>迁移计划需要确保每个节点负责相似数量的槽，从而保证各个节点数据均匀分布。</p><p>数据迁移过程是逐个槽进行的，流程如下:</p><ol><li>对目标节点发送<code>cluster setslot {slot} importing {sourceNodeId}</code>命令，让目标节点准备导入槽的数据。</li><li>对源节点发送<code>cluster setslot {slot} migrating {targerNodeId}</code>命令让源节点准备迁出槽数据。</li><li>源节点循环执行<code>cluster getkeysinslot {slot} {count}</code>命令，获取count个属于槽{slot}的键。</li><li>在源节点上执行<code>migrate {targetIp} {targetPort} "" 0 {timeout} keys {keys...}</code>命令，把获取的键通过流水线（pipeline）机制批量迁移到目标节点。</li><li>重复步骤3、4直到槽下所有键值数据迁移到目标节点。</li><li>向集群内所有主节点发送<code>cluster setslot {slot} node {targetNodeId}</code>命令，通知槽分配给目标节点。</li></ol><p>迁移流程实际操作时涉及大量槽并且每个槽对应非常多的键。因此redis-trib提供了槽重分片功能，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb reshard host:port --from &lt;arg&gt; --to &lt;arg&gt; --slots &lt;arg&gt; --yes --timeout </span><br><span class="line"> &lt;arg&gt; --pipeline &lt;arg&gt;</span><br><span class="line"></span><br><span class="line"># host:port：必传参数，集群内任意节点地址，用来获取整个集群信息</span><br><span class="line"># --from：制定源节点的id，如果有多个源节点，使用逗号分隔，如果是all源节点变为集群内所有主节点，在迁移过程中提示用户输入</span><br><span class="line"># --to：需要迁移的目标节点的id，目标节点只能填写一个，在迁移过程中提示用户输入</span><br><span class="line"># --slots：需要迁移槽的总数量，在迁移过程中提示用户输入</span><br><span class="line"># --yes：当打印出reshard执行计划时，是否需要用户输入yes确认后再执行reshard</span><br><span class="line"># --timeout：控制每次migrate操作的超时时间，默认为60000毫秒</span><br><span class="line"># --pipeline：控制每次批量迁移键的数量，默认为10</span><br></pre></td></tr></tbody></table></figure><h2 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h2><p>收缩集群流程如下：</p><ol><li>如果下线节点有负责的槽，需要把槽迁移到其他节点。</li><li>当下线节点不再负责槽或本身是从节点时，通知集群内其他节点忘记下线节点，当所有节点忘记该节点后可以正常关闭。</li></ol><h3 id="下线迁移槽"><a href="#下线迁移槽" class="headerlink" title="下线迁移槽"></a>下线迁移槽</h3><p>下线节点需要把负责的槽迁移到其他节点，原理与扩容迁移槽过程一致。</p><h3 id="忘记节点"><a href="#忘记节点" class="headerlink" title="忘记节点"></a>忘记节点</h3><p>Redis提供<code>cluster forget {downNodeId}</code>命令让集群内所有节点忘记下线的节点。当节点收到此命令后，会把nodeId指定的节点加入到禁用列表，在禁用列表的节点不再发送Gossip消息。禁用列表有效期是60秒。</p><p>线上操作cluster forget命令下线节点过于繁琐，建议使用<code>redis-trib.rb del-node {host:port} {downNodeId}</code>命令。</p><h1 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h1><h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p>集群模式下，Redis接收任何键相关的命令时首先要计算键对应的槽，再根据槽找到所对应的节点。如果节点是自身，则处理命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重定向。</p><p>使用<code>cluster keyslot {key}</code>命令可以获得key对应的槽。</p><p>键命令执行分为两步：</p><ol><li>计算槽：根据key的有效部分使用CRC16函数计算出散列值，再取对16383的余数<ul><li>key有效部分默认是整个key，可以使用hash_tag方式（{}包含）指定有效部分</li></ul></li><li>槽节点查找：在集群信息中查找槽对应的节点</li></ol><h2 id="Smart客户端"><a href="#Smart客户端" class="headerlink" title="Smart客户端"></a>Smart客户端</h2><p>大多数开发语言的Redis客户端都采用Smart客户端支持集群协议，通过在内部维护slot -&gt; node的映射关系，本地实现键到节点的查找，从而保证IO效率的最大化，而MOVED重定向负责协助Smart客户端更新slot -&gt; node映射。</p><h2 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h2><h3 id="客户端ASK重定向流程"><a href="#客户端ASK重定向流程" class="headerlink" title="客户端ASK重定向流程"></a>客户端ASK重定向流程</h3><p>Redis集群支持在线迁移槽（slot）和数据来完成水平伸缩，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点，当出现上述情况时，客户端键命令执行流程将发生变化，如下所示：</p><ol><li>客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端。</li><li>如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。格式如下：(error) ASK {slot} {targetIP}:{targetPort}。 </li><li>客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息。</li></ol><h3 id="节点内部处理"><a href="#节点内部处理" class="headerlink" title="节点内部处理"></a>节点内部处理</h3><p>为了支持ASK重定向，源节点和目标节点在内部结构中维护当前正在迁移的槽信息，用于识别槽迁移情况。</p><h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>集群故障发现通过消息传播机制实现，主要环节包括：主观下线（pfail）和客观下线（fail）。</p><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>主观下线指某个节点认为另一个节点不可用，存在误判的情况。</p><p>集群中每个节点都会定时向其他节点发送ping消息，接收节点回复pong消息。如果在cluster-node-timeout时间内通信一直失败，则发送节点认为接收节点存在故障，把接收节点标记为主观下线。</p><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p>客观下线指标记一个节点真正的下线，集群内多个节点认为该节点不可用。</p><p>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群中传播。当半数以上持有槽的主节点都标记某个节点主观下线时，触发客观下线。</p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，将会触发故障恢复流程：</p><ol><li>资格检查</li><li>准备选举时间</li><li>发起选举</li><li>选举投票</li><li>替换主节点</li></ol><h3 id="资格检查"><a href="#资格检查" class="headerlink" title="资格检查"></a>资格检查</h3><p>每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。如果从节点与主节点断线时间超过cluster-node-time*cluster-slave-validity-factor，则当前从节点不具备故障转移资格。参数cluster-slave-validity-factor用于从节点的有效因子，默认为10。</p><h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><p>当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。</p><h3 id="发起选举"><a href="#发起选举" class="headerlink" title="发起选举"></a>发起选举</h3><p>当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程如下：</p><ol><li>更新配置纪元：配置纪元是一个只增不减的整数，用来标示集群内每个主节点的不同版本和当前集群最大的版本。</li><li>广播选举消息：在集群内广播选举消息，并记录已发送过消息的状态，保证该从节点在一个配置纪元内只能发起一次选举。</li></ol><h3 id="选举投票"><a href="#选举投票" class="headerlink" title="选举投票"></a>选举投票</h3><p>只有持有槽的主节点才会处理故障选举消息，每个持有槽的节点在一个配置纪元内都有唯一的一张选票。</p><p>Redis集群没有直接使用从节点进行领导者选举，主要因为从节点数必须大于等于3个才能保证凑够N/2+1个节点，将导致从节点资源浪费。使用集群内所有持有槽的主节点进行领导者选举，即使只有一个从节点也可以完成选举过程。</p><p>当从节点收集到N/2+1个持有槽的主节点投票时，从节点可以执行替换主节点操作。</p><h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><p>当从节点收集到足够的选票之后，触发替换主节点操作：</p><ol><li>当前从节点取消复制变为主节点。</li><li>执行clusterDelSlot操作撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽委派给自己。</li><li>向集群广播自己的pong消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息。</li></ol><h2 id="故障转移时间"><a href="#故障转移时间" class="headerlink" title="故障转移时间"></a>故障转移时间</h2><p>故障转移时间，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failover-time(毫秒) &lt;= cluster-node-timeout + cluster-node-timeout/2 + 1000</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li>主观下线（pfail）识别时间 = cluster-node-timeout</li><li>主观下线状态消息传播时间 &lt;= cluster-node-timeout / 2</li><li>从节点转移时间 &lt;= 1000毫秒</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】哨兵模式</title>
    <link href="https://haifuns.com/2021/01/24/redis-05/"/>
    <id>https://haifuns.com/2021/01/24/redis-05/</id>
    <published>2021-01-24T12:18:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis从2.8开始正式提供了Redis Sentinel（哨兵）来实现高可用。</p><p>Redis Sentinel具有以下几个功能：</p><ul><li>监控：Sentinel节点会定期检测Redis数据节点、其他Sentinel节点是否可达</li><li>通知：Sentinel节点会将故障转移结果通知给应用方</li><li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系</li><li>配置提供者：在Redis Sentienl结构中，客户端在初始化时连接的是Sentienl节点集合，从中获取主节点信息</li></ul><span id="more"></span><h2 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h2><p>Redis主从复制模式是将主节点的数据改变同步给从节点，从节点即可以做备份也可以扩展主节点读能力。</p><p>但是主从复制模式存在如下问题：</p><ol><li>如果主节点故障，需要人工将从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点复制新的主节点。</li><li>主节点的写能力受单机限制</li><li>主节点的存储能力受到单机限制</li></ol><h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h2><p>当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。</p><p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点。每个Sentinel节点会对数据节点和其他Sentinel节点进行监控，当发现其他节点不可达时，会对节点做下线标识。如果被标识的是主节点，并且大多数Sentinel节点都认为主节点不可达时，则会选举出一个Sentinel节点来完成自动故障迁移工作，不需要人工干预。Redis Sentinel方案有效解决了Redis的高可用问题。</p><p>如下图所示，Redis Sentinel与Redis主从复制模式只是多了若干Sentinel节点并没有针对Redis节点做了特殊处理。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-sentinel-1.png" alt="Redis主从复制与Redis Sentinel架构的区别"></p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>下面将以3个Sentinel节点、1个主节点、2个从节点组成一个Redis Sentinel为例进行部署。</p><p>物理结构如下表所示：</p><table><thead><tr><th>角色</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>master</td><td>127.0.0.1</td><td>6379</td></tr><tr><td>slave-1</td><td>127.0.0.1</td><td>6380</td></tr><tr><td>slave-2</td><td>127.0.0.1</td><td>6381</td></tr><tr><td>sentinel-1</td><td>127.0.0.1</td><td>26379</td></tr><tr><td>sentinel-2</td><td>127.0.0.1</td><td>26380</td></tr><tr><td>sentinel-3</td><td>127.0.0.1</td><td>26381</td></tr></tbody></table><h2 id="部署Redis数据节点"><a href="#部署Redis数据节点" class="headerlink" title="部署Redis数据节点"></a>部署Redis数据节点</h2><p>Redis Sentinel中Redis数据节点没有做任何特殊配置，只需正常安装启动。</p><h3 id="启动主节点"><a href="#启动主节点" class="headerlink" title="启动主节点"></a>启动主节点</h3><p>配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-6379.conf</span><br><span class="line">port 6379 </span><br><span class="line">daemonize yes </span><br><span class="line">logfile "6379.log"</span><br><span class="line">dbfilename "dump-6379.rdb" </span><br><span class="line">dir "/opt/soft/redis/data/"</span><br></pre></td></tr></tbody></table></figure><p>启动主节点：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></tbody></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 ping</span><br></pre></td></tr></tbody></table></figure><h3 id="启动从节点"><a href="#启动从节点" class="headerlink" title="启动从节点"></a>启动从节点</h3><p>配置1（从节点2配置同理）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-6380.conf</span><br><span class="line">port 6380 </span><br><span class="line">daemonize yes </span><br><span class="line">logfile "6380.log" </span><br><span class="line">dbfilename "dump-6380.rdb" </span><br><span class="line">dir "/opt/soft/redis/data/" </span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></tbody></table></figure><p>启动从节点：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server redis-6381.conf</span><br></pre></td></tr></tbody></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6380 ping</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 ping</span><br></pre></td></tr></tbody></table></figure><h3 id="确认主从关系"><a href="#确认主从关系" class="headerlink" title="确认主从关系"></a>确认主从关系</h3><p>主节点视角下有两个从节点，分别是127.0.0.1:6380和127.0.0.1:6381</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=281,lag=0</span><br><span class="line">···</span><br></pre></td></tr></tbody></table></figure><p>从节点的视角，它的主节点是127.0.0.1:6379</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6380 info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">···</span><br></pre></td></tr></tbody></table></figure><h2 id="部署Sentinel节点"><a href="#部署Sentinel节点" class="headerlink" title="部署Sentinel节点"></a>部署Sentinel节点</h2><h3 id="配置Sentinel节点"><a href="#配置Sentinel节点" class="headerlink" title="配置Sentinel节点"></a>配置Sentinel节点</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-26379.conf</span><br><span class="line">port 26379 </span><br><span class="line">daemonize yes </span><br><span class="line">logfile "26379.log" </span><br><span class="line">dir /opt/soft/redis/data </span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 # 监控127.0.0.1:6379这个主节点(别名 mymaster)，2代表判断主节点失败至少需要2个Sentinel节点同意</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000 # 判定节点不可达超时时间，单位毫秒</span><br><span class="line">sentinel parallel-syncs mymaster 1 # 故障转移后，每次向主节点发起复制操作的从节点个数</span><br><span class="line">sentinel failover-timeout mymaster 180000 # 故障转移超时时间</span><br><span class="line">#sentinel auth-pass &lt;master-name&gt; &lt;password&gt; # 主节点密码</span><br><span class="line">#sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; # 故障转移期间事件通知脚本</span><br><span class="line">#sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; # 故障转移结束后触发脚本</span><br></pre></td></tr></tbody></table></figure><h3 id="启动Sentinel节点"><a href="#启动Sentinel节点" class="headerlink" title="启动Sentinel节点"></a>启动Sentinel节点</h3><p>Sentinel节点的启动方法有两种：</p><ol><li><p>使用redis-sentinel命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel redis-sentinel-26379.conf</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用redis-server命令加–sentinel参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>Sentinel节点本质上是一个特殊的Redis节点，所以也可以通过info命令来查询它的相关信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 26379 info Sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></tbody></table></figure><p>从info的Sentinel片段看，Sentinel节点找到了主节点127.0.0.1:6379，发现了它的两个从节点，同时发现Redis Sentinel一共有3个Sentinel节点。</p><h1 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sentinel masters # 展示所有被监控的主节点状态和统计信息</span><br><span class="line"></span><br><span class="line">sentinel master &lt;master name&gt; # 展示指定&lt;master name&gt;的主节点状态以及统计信息</span><br><span class="line"></span><br><span class="line">sentinel slaves &lt;master name&gt; # 展示指定&lt;master name&gt;的从节点以及相关统计信息</span><br><span class="line"></span><br><span class="line">sentinel sentinels &lt;master name&gt; # 展示指定&lt;master name&gt;的Sentinel节点集合（不包含当前Sentinel节点）</span><br><span class="line"></span><br><span class="line">sentinel get-master-addr-by-name &lt;master name&gt; # 返回指定&lt;master name&gt;主节点的IP地址和端口</span><br><span class="line"></span><br><span class="line">sentinel reset &lt;pattern&gt; # 当前Sentinel节点对符合&lt;pattern&gt;（通配符风格）主节点的配置进行重置，包含清除主节点的相关状态（例如故障转移），重新发现从节点和Sentinel节点</span><br><span class="line"></span><br><span class="line">sentinel failover &lt;master name&gt; # 对指定&lt;master name&gt;主节点进行强制故障转移（没有和其他Sentinel节点“协商”），当故障转移完成后，其他Sentinel节点按照故障转移的结果更新自身配置</span><br><span class="line"></span><br><span class="line">sentinel ckquorum &lt;master name&gt; # 检测当前可达的Sentinel节点总数是否达到&lt;quorum&gt;的个数</span><br><span class="line"></span><br><span class="line">sentinel flushconfig # 将Sentinel节点的配置强制刷到磁盘上</span><br><span class="line"></span><br><span class="line">sentinel remove &lt;master name&gt; # 取消当前Sentinel节点对于指定&lt;master name&gt;主节点的监控</span><br><span class="line"></span><br><span class="line">sentinel monitor &lt;master name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; # 通过命令的形式来完成Sentinel节点对主节点的监控</span><br><span class="line"></span><br><span class="line">sentinel set &lt;master name&gt; # 动态修改Sentinel节点配置选项</span><br><span class="line"></span><br><span class="line">sentinel is-master-down-by-addr # Sentinel节点之间用来交换对主节点是否下线的判断</span><br></pre></td></tr></tbody></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Redis Sentinel的基本实现原理，具体包含以下几个方面：<br>Redis Sentinel的三个定时任务、主观下线和客观下线、Sentinel领导者选举、故障转移。</p><h2 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h2><p>Redis Sentinel通过三个定时任务完成对各个节点发现和监控：</p><ol><li>每隔10秒，每个Sentinel节点会向数据主节点和从节点发送info命令获取最新的拓扑结构，作用有三点：<ul><li>通过向主节点执行info命令，获取从节点信息，所以不需要显示配置从节点</li><li>有新节点加入时可以立即感知</li><li>节点不可达或故障转移后，可以通过info命令实时更新节点拓扑信息</li></ul></li><li>每隔2秒，每个Sentinel节点会向数据节点的__sentinel__:hello频道发送该节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel也会订阅此频道，以获取其他Sentinel节点以及它们对主节点的判断。此任务完成以下两个工作：<ul><li>通过订阅主节点__sentinel__:hello频道，获取其他Sentinel节点信息，对于新节点保存信息并建立连接</li><li>Sentinel节点之间交换主节点状态，作为后面客观下线以及领导者选举的依据</li></ul></li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测确保这些节点可达</li></ol><h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>Redis Sentinel的第三个定时任务中，每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。主观下线存在误判的可能。</p><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p>当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is-master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定，客观下线是大部分Sentinel节点都对主节点的下线做了同意的判定。</quorum></p><h2 id="Sentinel领导者选举"><a href="#Sentinel领导者选举" class="headerlink" title="Sentinel领导者选举"></a>Sentinel领导者选举</h2><p>假如Sentinel节点对于主节点已经做了客观下线，接下来Redis会基于Raft算法从Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。</p><p>Sentinel节点选举大致思路如下：</p><ol><li>每个在线的Sentinel节点在做出主节点主观下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝</li><li>如果该Sentinel节点发现自己的票数已经大于等于max(quorum, num(sentinels)/2+1)，那么它将成为领导者</li><li>如果此过程没有选举出领导者，将进入下一次选举</li></ol><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>领导者选举出的Sentinel节点负责故障转移，具体步骤如下：</p><ol><li>在从节点列表中选出一个节点作为新的主节点，选择方法如下：<ul><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒</li><li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在继续</li><li>选择复制偏移量最大的从节点，存在返回，不存在继续</li><li>选择runId最小的节点</li></ul></li><li>Sentinel领导者节点会对第一步选出来的从节点执行slave no one命令让其成为主节点</li><li>Sentinel领导者节点会向其他从节点发送命令，让它们成为新主节点的从节点，复制规则与parallel-syncs参数有关</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis从2.8开始正式提供了Redis Sentinel（哨兵）来实现高可用。&lt;/p&gt;
&lt;p&gt;Redis Sentinel具有以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控：Sentinel节点会定期检测Redis数据节点、其他Sentinel节点是否可达&lt;/li&gt;
&lt;li&gt;通知：Sentinel节点会将故障转移结果通知给应用方&lt;/li&gt;
&lt;li&gt;主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系&lt;/li&gt;
&lt;li&gt;配置提供者：在Redis Sentienl结构中，客户端在初始化时连接的是Sentienl节点集合，从中获取主节点信息&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】主从复制</title>
    <link href="https://haifuns.com/2021/01/23/redis-04/"/>
    <id>https://haifuns.com/2021/01/23/redis-04/</id>
    <published>2021-01-22T16:00:05.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<p>为了满足故障恢复和负载均衡等需求，Redis提供了复制功能，实现了相同数据的多个副本。复制功能是高可用Redis的基础，哨兵和集群也都是在复制的基础上实现高可用。</p><span id="more"></span><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p>参与复制的Redis实例划分为主节点（master）和从节点（slave）。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。</p><p>配置复制的方式有以下三种：</p><ol><li>在配置文件中加入slaveof {masterHost} {masterPort} 随Redis启动生效</li><li>在redis-server启动命令后加入–slaveof {masterHost} {masterPort}</li><li>直接使用命令：slaveof {masterHost} {masterPort}</li></ol><p>slaveof本身是异步命令，执行slaveof命令时，节点只保存主节点信息后返回，后续复制流程在节点内部异步执行。主从节点复制成功建立后，可以使用info replication命令查看复制相关状态。</p><h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p>slaveof no one命令用来在从节点执行断开与主节点的复制关系。</p><p>断开复制主要流程：</p><ol><li>断开与主节点复制关系</li><li>从节点晋升为主节点</li></ol><p>通过slaveof {newMasterIp} {new MasterPort}命令还可以实现切主操作，把当前节点对主节点的复制切换到另一个主节点。</p><p>切主流程如下：</p><ol><li>断开与旧主节点的复制关系</li><li>与新主节点建立复制关系</li><li>删除从节点当前所有数据</li><li>对新主节点进行复制操作</li></ol><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>主节点设置requirepass参数进行密码验证时，从节点需要配置masterauth参数与主节点密码保持一致。</p><h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p>默认情况下，从节点使用slave-read-only=yes配置成只读模式。由于复制关系只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致，因此不建议修改线上从节点的只读模式。</p><h2 id="传输延迟"><a href="#传输延迟" class="headerlink" title="传输延迟"></a>传输延迟</h2><p>主从节点一般部署在不同机器上，考虑到复制时的网络延迟问题，Redis提供repl-disable-tcp-nodelay参数用于控制是否关闭TCP_NODELAY，默认关闭。</p><ul><li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延时变小，但是增加了网络带宽的消耗。适用于主从之间网络环境良好的场景，如同机架或机房部署。</li><li>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送时间间隔取决于Linux内核，一般默认40ms。这样节省了带宽但是增大了主从之间的延迟，适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。</li></ul><h1 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h1><p>Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为三种：一主一从、一主多从、树状主从结构。</p><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。</p><p>当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。</p><p>需要注意的是，当主节点关闭持久化功能时，如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据也被清空。</p><h2 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h2><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。</p><h2 id="树状主从"><a href="#树状主从" class="headerlink" title="树状主从"></a>树状主从</h2><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><p>复制过程大致分为6个过程：</p><ol><li>保存主节点信息：执行slaveof后从节点保存主节点的地址信息后直接返回</li><li>主从建立socket连接：从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当发现存在新主节点会尝试与之建立网络连接</li><li>发送ping命令：连接建立成功后从节点发送ping请求进行首次通信，如果失败会定时重连。发送ping请求主要目的如下：<ul><li>检测主从之间网络套接字是否可用</li><li>检测主节点当前是否可接受处理命令</li></ul></li><li>权限验证：如果主节点设置了requirepass参数，需要进行密码验证（从节点masterauth参数）</li><li>同步数据集：主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点</li><li>命令持续复制：数据集同步完成后，主节点会持续地把写命令发送到从节点，保证主从数据一致性</li></ol><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，2.8以下使用sync命令，同步过程分为全量复制和部分复制。</p><p>全量复制一般用于初次复制场景，把主节点全部数据一次性发送到从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p><p>部分复制用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连接主节点，如果条件允许，主节点会补发丢失数据给从节点。部分复制有效避免了不必要的全量复制操作。</p><p>psync命令运行需要以下组件支持：</p><ul><li>主从节点各自复制偏移量</li><li>主节点复制积压缓冲区</li><li>主节点运行id</li></ul><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>参与复制的主从节点都会维护自身复制偏移量。主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息info replication中的master_repl_offset指标中。</p><p>从节点每秒钟上报自身的复制偏移量给从主节点，因此主节点也会保存从节点的复制偏移量。从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量，统计信息在info replication中的slave_repl_offset指标中。</p><p>通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</p><h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小是1MB。当主节点有连接的从节点时被创建，这时主节点响应写命令时，不但会把命令发送给从节点，还会写到复制积压缓冲区。</p><p>缓冲区本质上是先进先出的定长队列，实现保存最近已复制数据的功能，用于部分复制和复制命令丢失数据的补救。</p><p>复制缓冲区相关信息保存在主节点info replication中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">//...</span><br><span class="line">repl_backlog_active:1 // 开启复制缓冲区</span><br><span class="line">repl_backlog_size:1048576 // 缓冲区最大长度</span><br><span class="line">repl_backlog_first_byte_offset:7479 // 起始偏移量，计算当前缓冲区可用范围</span><br><span class="line">repl_backlog_histlen:1048576 // 已保存数据的有效长度。</span><br></pre></td></tr></tbody></table></figure><p>复制积压缓冲区内可用偏移量范围是：[repl_backlog_first_byte_offset, repl_backlog_first_byte_offset + repl_backlog_histlen]。</p><h3 id="主节点运行ID"><a href="#主节点运行ID" class="headerlink" title="主节点运行ID"></a>主节点运行ID</h3><p>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是唯一标识Redis节点，比如从节点保存主节点的运行ID识别正在复制的是哪个主节点。使用info server命令可查看当前节点的运行ID。</p><h3 id="psync命令"><a href="#psync命令" class="headerlink" title="psync命令"></a>psync命令</h3><p>psync命令格式为<code>psync {runId} {offset}</code>，runId为主节点运行id，offset为当前从节点已复制的数据偏移量。</p><p>psync命令运行流程如下：</p><ol><li>从节点发送psync命令给主节点，第一次参与复制时offset为-1</li><li>主节点根据psync参数和自身数据决定响应结果：<ul><li>回复+FULLRESYNC {runId} {offset}，此时从节点将触发全量复制流程</li><li>回复+CONTINUE，从节点将触发部分复制流程</li><li>回复+ERR，说明主节点版本低于2.8无法识别psync命令，从节点将发送旧版的sync命令触发全量复制流程</li></ul></li></ol><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><p>全量复制是主从第一次建立复制时必须要经历的阶段。触发全量复制的命令时sync (Redis&lt;2.8)和psync(Redis&gt;=2.8)。</p><p>psync全量复制流程与2.8前的sync全量复制机制基本一致，psync全量复制完整运行流程如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-psync.png" alt="全量复制流程"></p><ol><li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点运行ID，发送psync ? -1</li><li>主节点回复+FULLRESYNC {runId} {offset}响应</li><li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li><li>主节点执行bgsave保存RDB文件到本地</li><li>主节点发送RDB文件给从节点，从节点接收RDB文件保存在本地直接作为从节点数据文件（Redis支持无盘复制，RDB文件不落盘，通过参数repl-diskless-sync参数控制，默认关闭）</li><li>RDB传输期间，主节点响应读写命令，同时会把写命令写到复制积压缓冲区，当从节点加载完成RDB文件后，主节点在把缓冲区的数据发送到从节点，保证主从数据一致</li><li>从节点接收完主节点传输的所有数据后会清空自身旧数据</li><li>从节点清空旧数据后，开始加载RDB文件</li><li>从节点成功加载RDB后，如果当前节点开启了AOF持久化功能，会立即做bgrewriteaof操作，为了保证全量复制后AOF持久化功能立即可以使用</li></ol><h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p>部分复制使用psync {runId} {offset}命令实现。当从节点正在复制主节点时出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，由于补发的这部分数据一般远远小于全量数据从而做到节省开销。</p><p>部分复制的流程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-psync2.png" alt="部分复制流程"></p><ol><li>当主从节点之间出现网络中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li><li>主从连接中断期间主节点依然响应命令同时写入复制积压缓冲区</li><li>从节点网络恢复再次连接主节点</li><li>从节点发送psync {runId} {offset}命令到主节点要求进行部分复制操作</li><li>主节点校验runId，根据offset在复制积压缓冲区查找，如果偏移量之后的数据在缓冲区中则向从节点回复+CONTINUE响应，表示可以进行部分复制</li><li>主节点根据偏移量把复制积压缓冲区数据发送给从节点，保证主从复制进入正常状态</li></ol><h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>主从节点建立复制后维护着长连接并彼此发送心跳命令。</p><p>主从心跳判断机制：</p><ol><li>主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信，通过client list命令查看复制相关的客户端信息，主节点连接状态为flag=M，从节点连接状态为flag=S。</li><li>主节点默认每隔10s对从节点发送ping命令，判断从节点存活性和连接状态。通过参数repl-ping-slave-period控制发送频率</li><li>从节点在主线程中每个1s发送replconf ack {offset}命令给主节点上报自身当前的复制偏移量</li></ol><h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>主节点进行数据读写的同时还会把写命令同步给从节点，发送过程是异步完成的，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。</p><p>主节点复制流程如下：</p><ol><li>主节点接收处理命令</li><li>命令处理完之后返回响应结果</li><li>对于修改命令异步发送给从节点，从节点在主线程中执行复制的命令</li></ol><p>由于主从复制过程是异步的，就会造成从节点的数据相对主节点存在延迟。具体延迟多少字节，可以在主节点执行info replication命令查看相关指标获得。例如以下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=841,lag=1</span><br><span class="line">master_repl_offset:841</span><br></pre></td></tr></tbody></table></figure><p>从节点slave0信息中offset表示当前从节点的复制偏移量，master_repl_offset表示当前主节点的复制偏移量，两者的差值就是当前从节点复制延迟量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了满足故障恢复和负载均衡等需求，Redis提供了复制功能，实现了相同数据的多个副本。复制功能是高可用Redis的基础，哨兵和集群也都是在复制的基础上实现高可用。&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】持久化</title>
    <link href="https://haifuns.com/2021/01/18/redis-03/"/>
    <id>https://haifuns.com/2021/01/18/redis-03/</id>
    <published>2021-01-18T14:08:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<p>Redis支持RDB和AOF两种持久化机制，持久化功能可以有效的避免因进程退出造成的数据丢失，当下次重启时利用之前持久化的文件即可实现数据恢复。</p><span id="more"></span><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>手动触发分为save和bgsave两种命令：</p><ul><li>save命令：阻塞当前服务器，直到RDB完成，对于内存较大的实例会造成长时间阻塞，不建议线上使用</li><li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，直到完成后结束。阻塞只发生在fork阶段，一般时间很短</li></ul><p>Redis内部还存在自动触发RDB持久化机制，例如以下场景：</p><ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发给从节点</li><li>执行debug reload命令重新加载Redis时，自动触发save操作</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bfsave</li></ul><h2 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h2><p>bgsave是主流的触发RDB持久化方式，其运作流程如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-bgsave.png" alt="RDB持久化流程"></p><ol><li>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在则bgsave命令直接返回</li><li>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获得最近一个fork操作的耗时，单位为微秒</li><li>父进程fork完成后，bfsave命令返回Background saving started信息，并不再阻塞父进程</li><li>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成的RDB的时间，对应info统计的rdb_last_save_time选项</li><li>子进程发送信号给父进程表示完成，父进程更新统计信息</li></ol><h2 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h2><p>RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定。通过执行<code>config set dir {newDir}</code>和<code>config set dbfilename {newFileName}</code>在运行期动态修改。</p><p>Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远小于内存大小，默认开启，通过执行<code>config set rdbcompression {yes|no}</code>动态修改</p><h2 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h2><p>优点：</p><ul><li>RDB是一个紧凑压缩的二进制文件，代表某个时间点的数据快照。非常适合备份、全量复制场景</li><li>Redis加载RDB恢复数据远远快于AOF方式</li></ul><p>缺点：</p><ul><li>RDB不能实时持久化/秒级持久化。因为bgsave每次执行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高</li><li>RDB文件使用特定二进制格式保存，存在老版本Redis无法兼容新版RDB格式的问题</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF(append only file) 持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。</p><p>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><h2 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h2><p>开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名可以通过appendfilename配置设置，默认是appendonly.aof。保存路径与RDB持久化方式一致，通过dir配置指定。</p><p>AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load），如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-aof.png" alt="AOF工作流程"></p><ol><li>所有的写入命令都会追加到aof_buf（缓冲区）中</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作</li><li>定期对AOF文件进行压缩重写</li><li>当Redis服务器重启时，加载AOF文件进行数据恢复</li></ol><h2 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h2><p>AOF命令写入的内容是文本协议格式。例如set hello world命令会在AOF缓冲区追加如下文本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></tbody></table></figure><p>AOF直接采用文本协议格式有如下原因：</p><ul><li>文本协议具有很好的兼容性</li><li>直接采用协议格式可避免二次处理开销</li><li>文本协议可读性高，方便直接修改和处理</li></ul><p>AOF直接把命令追加到aof_buf是因为Redis使用单线程响应命令，如果每次写AOF文件都直接追加到硬盘，那么性能完全取决于硬盘负载。而直接写到aof_buf缓冲区中，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p><h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p>Redis提供了多种AOF缓冲区同步文件策略，有参数appendfsync控制，可配置值以及含义如下表所示：</p><table><thead><tr><th>可配置值</th><th>说明</th></tr></thead><tbody><tr><td>always</td><td>命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回</td></tr><tr><td>everysec（默认）</td><td>命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次</td></tr><tr><td>no</td><td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30s</td></tr></tbody></table><p>系统调用write和fsync区别如下：</p><ul><li>write操作会触发延迟写（delayed write）机制。Linux内核提供页缓冲区来提高硬盘I/O性能。write操作在写入系统缓冲区后直接返回，同步硬盘策略依赖于系统调度机制，比如：缓冲区页空间写满或达到特定同步周期。在同步硬盘前如果系统故障宕机，缓冲区数据将会丢失。</li><li>fsync针对单个文件操作（比如AOF文件）做强制硬盘同步，fsync将阻塞直到同步完成。</li></ul><p>同步策略建议配置为everysec，这也是默认配置，可做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。</p><h2 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h2><p>Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</p><p>重写后AOF文件变小有如下原因：</p><ol><li>进程内已经超时的数据不再写入文件；</li><li>旧AOF文件含有无效命令，比如修改、删除等命令。而新AOF文件中只保留最终数据的写入命令；</li><li>多条写命令被合并成一个，为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，单条命令最多64个元素；</li></ol><h3 id="触发机制-1"><a href="#触发机制-1" class="headerlink" title="触发机制"></a>触发机制</h3><p>AOF重写过程可以手动触发和自动触发：</p><ul><li>手动触发：直接调用bgrewriteaof命令</li><li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机<ul><li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB；</li><li>auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值；</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动触发时机 = aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp; (aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage</span><br></pre></td></tr></tbody></table></figure><h3 id="AOF重写运作流程"><a href="#AOF重写运作流程" class="headerlink" title="AOF重写运作流程"></a>AOF重写运作流程</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-aof-rewrite.png" alt="AOF重写运作流程"></p><p>AOF重写运作流程说明：</p><ol><li>执行AOF重写请求</li><li>父进程执行fork创建子进程</li><li><ul><li>主进程fork操作完成后，继续响应其它命令。所有修改命令依然可以写入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性 </li><li>由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据</li></ul></li><li>子进程根据内存快照，按照命令合并规则写入到新AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞</li><li><ul><li>新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见info persistence下的aod_*相关统计</li><li>父进程把AOF重写缓冲区的数据写到新的AOF文件</li><li>使用新AOF文件替换老文件，完成AOF重写</li></ul></li></ol><h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><p>AOF和RDB文件都可以用于服务器重启时的数据恢复。如下图所示，表示Redis持久化文件加载流程。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/redis/redis-load.png" alt="Redis持久化文件加载流程"></p><p>Redis持久化文件加载流程说明：</p><ol><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件</li><li>AOF关闭或AOF文件不存在时，加载RDB文件</li><li>加载AOF/RDB文件成功后，Redis启动成功</li><li>加载AOF/RDB文件存在错误时，Redis启动失败</li></ol><h2 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h2><p>加载损坏的AOF文件时Redis会拒绝启动，并打印如下日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></tbody></table></figure><p>对于错误格式的AOF文件，先进行备份，然后使用redis-check-aof –fix命令进行修复，修复后使用diff -u对比数据的差异，找到丢失的数据，有些可以人工修改补全。</p><p>AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部文件命令写入不全。Redis提供了aof-load-truncated配置来兼容这种情况，默认开启。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis支持RDB和AOF两种持久化机制，持久化功能可以有效的避免因进程退出造成的数据丢失，当下次重启时利用之前持久化的文件即可实现数据恢复。&lt;/p&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】附加功能</title>
    <link href="https://haifuns.com/2021/01/17/redis-02/"/>
    <id>https://haifuns.com/2021/01/17/redis-02/</id>
    <published>2021-01-17T15:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<p>Redis除了提供5种基本数据结构外，还提供了一些附加功能：</p><ul><li>慢查询分析</li><li>Redis Shell</li><li>Pipeline</li><li>事务与Lua</li><li>Bitmaps</li><li>HyperLogLog</li><li>发布订阅</li><li>GEO</li></ul><span id="more"></span><h1 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h1><p>Redis客户端执行一条命令分为4个部分：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>慢查询只统计步骤3的时间，没有慢查询并不代表没有超时问题。</p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>Redis提供<code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>两个配置。其中<code>slowlog-log-slower-than</code>用来设置阈值，单位时间是微秒，默认值是10000，执行时间超过10000微秒的命令会被记录在慢查询日志中。</p><p>Redis使用了一个列表来存储慢查询日志，<code>slowlog-max-len</code>是列表的最大长度。</p><p>Redis中有两种方法修改配置：</p><ul><li>修改配置文件</li><li>使用<code>config set</code>命令动态修改</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000 # 将阈值设置为20000微秒</span><br><span class="line">config set slowlog-max-len 1000 # 将列表长度设置为1000</span><br><span class="line">config rewrite # 将配置文件持久化到本地配置文件</span><br></pre></td></tr></tbody></table></figure><h2 id="查看慢查询"><a href="#查看慢查询" class="headerlink" title="查看慢查询"></a>查看慢查询</h2><ul><li>获取慢查询日志</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog get [n] # 可选参数n可以指定条数</span><br></pre></td></tr></tbody></table></figure><p>慢查询日志由四个属性组成：</p><ol><li>慢查询标识id</li><li>发生时间戳</li><li>命令耗时</li><li>执行命令和参数</li></ol><ul><li>获取慢查询日志列表当前长度</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></tbody></table></figure><ul><li>慢查询日志重置</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></tbody></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>slowlog-max-len配置建议：线上设置1000以上。记录慢查询时Redis会对长命令做截断处理，不会占用大量内存。</li><li>slowlog-log-slower-than配置建议：默认超过10ms判定为慢查询，需要根据Redis并发量调整该值。对于高流量的场景，如果命令执行时间在1ms以上，那么Redis最多可支撑OPS不到1000。对于高OPS场景Redis建议设置为1ms。</li></ul><p>由于慢查询日志是一个先进先出的队列，在慢查询较多时会丢失部分日志，所以可以定时执行<code>slow get</code>命令将慢查询日志持久化到其他存储中（MySQL等）。</p><h1 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h1><p>Redis提供了redis-cli、redis-server、redis-benchmarl等shell工具。</p><h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h2><p>redis-cli可选参数如下：</p><ul><li>-h：host，主机地址</li><li>-p：port，端口</li><li>-r：repeat，将命令执行多次</li><li>-i：interbval，每隔几秒执行一次命令，与-r配合使用</li><li>-x：从标准输入（stdin）读取数据作为最后一个参数，例如：<code>echo "world" | redis-cli -x set hello</code></li><li>-c：cluster，连接Redis Cluster节点，防止moved和ask异常</li><li>-a：auth，指定密码</li><li>–scan和–pattern：用于扫描指定模式的键</li><li>–slave：把客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作</li><li>–rdb，请求Redis实例生成并发送RDB持久化文件，保存在本地</li><li>–pipe，将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行</li><li>–bigkeys，使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值</li><li>–eval，执行指定Lua脚本</li><li>–latency<ul><li>–latency：测试客户端到目标Redis的网络延迟</li><li>–latency-history：分时段输出网络延迟</li><li>–latency-dist：使用统计图表输出网络延迟统计信息</li></ul></li><li>–stat：实时获取Redis的重要统计信息</li><li>–raw和–no-raw：–no-raw要求返回结果必须是原始格式，–raw返回格式化后的结果</li></ul><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h2><p>redis-sever除了用来启动Redis外，还有一个<code>--test-memory</code>选项可以用来检测当前操作系统能否稳定分配指定容量的内存给Redis，通过检测可以有效避免因为内存问题造成Redis崩溃。</p><p>例如，检测当前操作系统是否能提供1G内存给Redis：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --test-memery 1024</span><br></pre></td></tr></tbody></table></figure><h2 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h2><p>redis-benchmark可以为Redis做基准性能测试，可选参数如下：</p><ul><li>-c：client，客户端的并发数量，默认50</li><li>-n：num，客户端请求总数量，默认100000</li><li>-q：输出requests per second信息</li><li>-r：random，随机插入键</li><li>-P：每个请求的pipeline的数据量，默认1</li><li>-k：keepalive，1使用，0不使用，默认1</li><li>-t：对指定命令进行基准测试</li><li>–csv：结果按照csv格式输出</li></ul><h1 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h1><p>Redis客户端执行一次命令需要经过发送、排队、执行、返回四个过程，其中发送和返回过程称为Round Trip Time（RTT，往返时间）。</p><p>Redis中大部分命令不支持批量操作，那么每个命令都要消耗一次RTT。Pipeline（流水线）机制可以改善这类问题，它可以将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。使用Pipeline执行多条命令只需要一次RTT。</p><p>redis-cli的–pipe选项实际上就是使用了Pipeline机制，例如，下面将set hello world和incr counter两条命令组装：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -en '*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n*2\r\n$4\r\nincr\r\n$7\r\ncounter\r\n' | redis-cli --pipe</span><br></pre></td></tr></tbody></table></figure><h2 id="原生批量命令与Pipeline对比"><a href="#原生批量命令与Pipeline对比" class="headerlink" title="原生批量命令与Pipeline对比"></a>原生批量命令与Pipeline对比</h2><ul><li>原生批量任务是原子的，Pipeline是非原子的</li><li>原生批量任务是一个命令对应多个key，Pipeline支持多个命令</li><li>原生批量任务是Redis服务端支持实现的，Pipeline需要服务端和客户端共同实现</li></ul><h1 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h1><p>为了保证多条命令组合的原子性，Redis提供简单的事务功能以及集成Lua脚本来解决这个问题。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis提供简单的事务功能，将需要一起执行的命令放到<code>multi</code>和<code>exec</code>两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子性执行的。</p><p><code>discard</code>命令用来停止事务执行。</p><p>如果事务中的命令出现错误，不同情况下Redis的处理机制也不相同：</p><ul><li>命令错误：语法错误会造成整个事务无法执行</li><li>运行时错误：Redis并不支持回滚功能，未发生错误的命令会正常执行</li></ul><p>有些应用场景需要在执行事务之前，确保事务中的key没有被其他客户端修改过才执行事务，否则不执行。Redis提供了<code>watch</code>命令来解决这类问题。（在multi命令前执行watch key，在执行exec时，如果key被修改了事务不会执行，结果为nil）</p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>Lua语言于1993年诞生，设计目标是作为嵌入式程序移植到其他应用程序。由C语言实现，作为脚本语言被应用于游戏领域、Web服务器Nginx等地方。</p><p>Redis将Lua作为脚本语言，通过修改源码可实现定制命令。</p><p>在Redis中使用Lua脚本功能有如下优点：</p><ul><li>Lua脚本在Redis中是原子执行的，执行过程中不会插入其它命令</li><li>基于Lua脚本可以创造出定制命令，并且可以将这些命令常驻在内存中，实现复用</li><li>Lua脚本可以将多条命令打包，有效较少网络开销</li></ul><h3 id="使用Lua"><a href="#使用Lua" class="headerlink" title="使用Lua"></a>使用Lua</h3><p>在Redis中执行Lua脚本有两种方法：eval和evalsha。</p><ul><li>eval</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval 脚本内容 key个数 key列表 参数列表</span><br></pre></td></tr></tbody></table></figure><p>如果Lua脚本比较长，可以使用redis-cli –eval直接执行文件。</p><ul><li>evalsha</li></ul><p>Redis还提供evalsha命令来执行Lua脚本。首先将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和，evalsha命令使用SHA1作为参数可以直接执行对应的Lua脚本，避免每次发送Lua脚本的开销。脚本会常驻在服务端得到复用。</p><p>加载脚本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli script load "$(cat lua_get.lua)" # 将lua_get.lua加载到内存中，返回SHA1</span><br></pre></td></tr></tbody></table></figure><p>执行脚本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evalsha 脚本SHA1值 key个数 key列表 参数列表</span><br></pre></td></tr></tbody></table></figure><h3 id="redis-api"><a href="#redis-api" class="headerlink" title="redis api"></a>redis api</h3><p>Lua可以使用redis.call函数实现对Redis的访问，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.call("set", "hello", "world")</span><br><span class="line">redis,call("get", "hello")</span><br></pre></td></tr></tbody></table></figure><p>在Redis中执行效果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ eval 'return redis.call("get", "KEY[1]")' 1 hello</span><br><span class="line">"world"</span><br></pre></td></tr></tbody></table></figure><p>除redis.call外，Lua还可以使用redis.pcall函数实现对Redis的调用。区别在于，redis.call执行失败时，脚本执行结束会直接返回错误，而redis.pcall会忽略错误继续执行脚本。</p><h3 id="管理Lua脚本"><a href="#管理Lua脚本" class="headerlink" title="管理Lua脚本"></a>管理Lua脚本</h3><ul><li><code>script load script</code>：加载脚本到内存中</li><li><code>script exists sha1 [sha1 ...]</code>：判断sha1是否已经加载到内存</li><li><code>script flush</code>：清除内存中的Lua脚本</li><li><code>script kill</code>：杀掉正在执行的Lua脚本。Redis提供lua-time-limit参数，默认5s，当脚本执行时间超过lua-time-limit后，会向其它命令调用发送BASY信号并提示使用script kill或shutdown nosave命令杀到busy脚本，但是不会停止服务端或客户端脚本执行</li></ul><h1 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h1><p>合理地使用位操作能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps，可以实现对位的操作。Bitmaps不是一种数据结构，其本身就是字符串，但是可以对字符串的位进行操作。</p><p>Bitmaps单独提供了一套命令，可以把Bitmaps看做成以位为单位的数组，数据每个单元只能存放1和0，数组的下标为偏移量。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value # 设置值</span><br><span class="line"></span><br><span class="line">getbit key offset # 获取值</span><br><span class="line"></span><br><span class="line">bitcount [start] [end] # 获取Bitmaps指定范围值为1的个数</span><br><span class="line"></span><br><span class="line">bitop op destkey key [key ...] # 对多个Bitmaps操作，op：and(交集)、or(并集)、not(非)、xor(异或)</span><br><span class="line"></span><br><span class="line">bitpos key targetBit [start] [end] # 计算Bitmaps中第一个值为targetBit的偏移量</span><br></pre></td></tr></tbody></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 并不是一种新的数据结构（实际类型为字符串类型），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p><p>HyperLogLog内存占用量非常小，但是存在错误率，在进行数据结构选型时只需要确认以下两条：</p><ol><li>只为了计算独立总数，不需要获取单条数据</li><li>可以容忍一定误差率</li></ol><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...] # 添加元素</span><br><span class="line"></span><br><span class="line">pfcount key [key ...] # 计算独立用户数</span><br><span class="line"></span><br><span class="line">pfmerge destkey sourcekey [sourcekey] # 求多个HyperLogLog并集，并赋值给destkey</span><br></pre></td></tr></tbody></table></figure><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis提供了基于“发布/订阅”模式的消息机制，此模式下，消息发布者与订阅者不需要直接通信，发布者客户端向指定的频道（channel）发布消息，订阅该频道的每个客户端都能收到消息。</p><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">publish channel message # 发布消息</span><br><span class="line"></span><br><span class="line">subscribe channel [channel ...] # 订阅消息</span><br><span class="line">    # 客户端在执行订阅命令后进入订阅状态，只能接受subscribe、psubscribe、unsubscribe、punsubscribe的四个命令</span><br><span class="line">    # 新开启的订阅客户端无法收到频道之前的消息，因为Redis不会对发布的消息进行持久化</span><br><span class="line"></span><br><span class="line">unsubscribe [channel [channel ...]] # 取消订阅</span><br><span class="line"></span><br><span class="line">psubscribe pattern [pattern ...] # 按照模式订阅</span><br><span class="line">punsubscribe [pattern [pattern ...]] # 按照模式取消订阅</span><br><span class="line"></span><br><span class="line">pubsub channels [pattern] # 查看活跃的频道</span><br><span class="line">pubsub numsub [channel ...] # 查看频道订阅数</span><br><span class="line">pubsub numpat # 查看模式订阅数</span><br></pre></td></tr></tbody></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>聊天室、公告牌、服务之间都可以使用发布订阅模式实现消息解耦。</p><blockquote><p>和很多专业的消息队列系统（例如Kafka、RocketMQ等）相比，Redis的发布订阅略显粗糙，例如无法实现消息堆积和回溯。但胜在足够简单，如果当前场景可以容忍的这些缺点，也不失为一个不错的选择。</p></blockquote><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><p>Redis3.2版本开始提供了GEO（地理信息定位）功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p><p>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中。</p><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitube latitude member [longitude latitude member ...] # 增加地理位置信息</span><br><span class="line">            # longitube：经度</span><br><span class="line">            # latitude：维度</span><br><span class="line">            # member：成员</span><br><span class="line">            </span><br><span class="line">geopos key member [member ...] # 获取地理位置信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit] # 获取两个地理位置的距离</span><br><span class="line">            # unit：表示返回结果的单位，包含以下四种</span><br><span class="line">                # m (meters)：米</span><br><span class="line">                # km (kilometers)：公里</span><br><span class="line">                # mi (miles)：英里</span><br><span class="line">                # ft (feet)：尺</span><br><span class="line">                            </span><br><span class="line"># 获取指定位置范围内的地理信息位置集合</span><br><span class="line">georadius key longitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key] </span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br><span class="line"></span><br><span class="line">            # withcoord：返回结果中包含经纬度</span><br><span class="line">            # withdist：返回结果中包含离中心节点位置的距离</span><br><span class="line">            # withhash：返回结果中包含geohash</span><br><span class="line">            # COUNT count：指定返回结果的数量</span><br><span class="line">            # asc|desc：返回结果按照离中心节点的距离做升序或者降序</span><br><span class="line">            # store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line"></span><br><span class="line">geohash key member [member ...] # 获取geohash。Redis使用geohash将二维经纬度转换为一维字符串</span><br><span class="line"></span><br><span class="line">zrem key member # 删除地理位置信息</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis除了提供5种基本数据结构外，还提供了一些附加功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢查询分析&lt;/li&gt;
&lt;li&gt;Redis Shell&lt;/li&gt;
&lt;li&gt;Pipeline&lt;/li&gt;
&lt;li&gt;事务与Lua&lt;/li&gt;
&lt;li&gt;Bitmaps&lt;/li&gt;
&lt;li&gt;HyperLogLog&lt;/li&gt;
&lt;li&gt;发布订阅&lt;/li&gt;
&lt;li&gt;GEO&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】内存模型</title>
    <link href="https://haifuns.com/2021/01/15/redis-01/"/>
    <id>https://haifuns.com/2021/01/15/redis-01/</id>
    <published>2021-01-15T15:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>Redis可以存储键与5 种数据结构类型之间的映射，分别为：</p><ul><li>STRING 字符串</li><li>LIST 列表</li><li>SET 集合</li><li>HASH 哈希</li><li>ZSET 有序集合</li></ul><span id="more"></span><p>下表对比了Redis 提供的5 种结构，说明结构存储值并简单介绍其语义：</p><table><thead><tr><th>结构类型</th><th>结构类型的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>STRING(字符串)</td><td>字符串、整数、浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数或浮点数执行自增(increment)或自减(decrement)操作</td></tr><tr><td>LIST(列表)</td><td>一个链表，链表上每个节点都包含一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或多个元素；根据值查找或获取元素</td></tr><tr><td>SET(集合)</td><td>包含字符串的无序收集器(unordered collection)，并且被包含的每个字符串都是独一无二、各不相同的</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里随机获取元素</td></tr><tr><td>HASH(哈希)</td><td>包含键值对的无序哈希表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>ZSET(有序集合)</td><td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td></tr></tbody></table><h1 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h1><p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，Redis会在合适的场景选择合适的内部编码。对应关系如下表所示：</p><table><thead><tr><th>数据结构</th><th>内部编码</th></tr></thead><tbody><tr><td>string</td><td>raw、int、embstr</td></tr><tr><td>hash</td><td>hashtable、ziplist</td></tr><tr><td>list</td><td>linkedlist、ziplist</td></tr><tr><td>set</td><td>hashtable、intset</td></tr><tr><td>zset</td><td>skiplist、ziplist</td></tr></tbody></table><p>通过<code>object encoding [key]</code>命令可以查询key内部编码</p><h1 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h1><p>字符串类型是Redis最基础的数据结构。字符串类型的值实际可以是字符串、数字（整数、浮点数），甚至是二进制，但是值最大不能超过512MB。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br></pre></td></tr></tbody></table></figure><p>set命令选项如下：</p><ul><li>ex seconds：为键设置秒级过期时间</li><li>px milliseconds：为键设置毫秒级过期时间</li><li>nx：键必须不存在才可以设置成功，用于添加</li><li>xx：与nx相反，键必须存在才可以设置成功，用于更新</li></ul><p>除set选项外，Redis还提供了setex和setnx两个命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value # 更新value并重新设置过期时间，此命令可保证原子性操作</span><br><span class="line">setnx key value # set if not exists，key不存在则set，存在无操作</span><br></pre></td></tr></tbody></table></figure><blockquote><p>setnx可以作为分布式锁的一种实现方案，官方实现：<a href="http://redis.io/topics/distlock">http://redis.io/topics/distlock</a></p></blockquote><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></tbody></table></figure><h3 id="批量设置值"><a href="#批量设置值" class="headerlink" title="批量设置值"></a>批量设置值</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></tbody></table></figure><h3 id="批量获取值"><a href="#批量获取值" class="headerlink" title="批量获取值"></a>批量获取值</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></tbody></table></figure><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key # 自增</span><br><span class="line">decr key # 自减</span><br><span class="line">incrby key increment # 自增指定数字</span><br><span class="line">decrby key decrement # 自减指定数字</span><br><span class="line">incrbyfloat key increment # 自增浮点数</span><br></pre></td></tr></tbody></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">append key value # 追加值</span><br><span class="line">strlen key # 字符串长度</span><br><span class="line">getset key value # 设置并返回原值</span><br><span class="line">setrange key offeset value # 设置指定位置的字符</span><br><span class="line">getrange key start end # 获取部分字符串</span><br></pre></td></tr></tbody></table></figure><h2 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h2><p>字符串类型的内部编码有三种：</p><ul><li>int：8个字节的长整形</li><li>embstr：小于等于39个字节的字符串</li><li>raw：大于39个字节的字符串</li></ul><p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>缓存功能</li><li>计数</li><li>共享session</li><li>限速</li></ul><h1 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h1><p>Redis 的哈希可以存储多个键值对之间的映射，和字符串一样，哈希存储的值可以是字符串也可以是数字，并且可以对哈希存储的数字值执行自增或者自减操作。</p><blockquote><p>哈希类型中的映射关系是field -&gt; value</p></blockquote><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hset key field value # 设置值</span><br><span class="line">hget key field # 获取值</span><br><span class="line">hdel key field [field] # 删除一个或多个值</span><br><span class="line"></span><br><span class="line">hlen key # 计算field个数</span><br><span class="line"></span><br><span class="line">hmget key field [field] # 批量获取field值</span><br><span class="line">hmset key field value [field value] # 批量设置field</span><br><span class="line"></span><br><span class="line">hexists key field # 判断field是否存在</span><br><span class="line"></span><br><span class="line">hkeys key # 获取所有field</span><br><span class="line">hvals key # 获取所有value</span><br><span class="line">hgetall key # 获取所有field-value</span><br><span class="line"></span><br><span class="line">hincrby key field increment # field值增加increment</span><br><span class="line">hincrbyfloat key field increment # field值加上浮点数增量increment</span><br><span class="line"></span><br><span class="line">hstrlen key field # 计算value的字符串长度</span><br></pre></td></tr></tbody></table></figure><h2 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h2><p>哈希类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值小于hash-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist作为哈希内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，更加节省内存。</li><li>hashtable（哈希表）：当哈希类型无法满足ziplist条件时，Redis会使用hashtable作为哈希内部实现，因为此时ziplist的读写效率会下降，而hashtable读写时间复杂度是O(1)。</li></ul><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>存储对象信息</li></ul><p>哈希类型与关系型数据库不同之处：</p><ul><li>哈希类型是稀疏的，关系型数据库是完全结构化的。例如哈希类型可以每个键有不同的field，而关系型数据库每行列一致。</li><li>关系型数据库可以做复杂的关系查询，而Redis模拟关系型复杂查询开发困难，维护成本高。</li></ul><h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h1><p>列表（list）类型用来存储多个有序的字符串。列表中每个字符串称为元素，一个列表最多可以存储2^32-1个元素。在Redis中，可以对列表两端插入(push)和弹出(pop)，还可以获取指定范围的元素列表、获取指定索引下标的元素等。</p><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...] # 从右边插入元素</span><br><span class="line">lpush key value [value ...] # 从左边插入元素</span><br><span class="line">linsert key before|after pivot value # 查找等于pivot的元素，在其前/后插入新元素</span><br></pre></td></tr></tbody></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end # 获取指定范围内的元素列表，从左到右是0 ~ (N-1)，从右到左是-1 ~ -N，lrange key 0 -1 查询所有</span><br><span class="line">lindex key index # 获取列表指定索引下标的元素</span><br><span class="line">llen key # 获取列表长度</span><br></pre></td></tr></tbody></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpop key # 从列表左侧弹出元素</span><br><span class="line">rpop key # 从列表右侧弹出元素</span><br><span class="line"></span><br><span class="line">lrem key count value # 删除指定元素</span><br><span class="line">                     # count &gt; 0，从左到右删除最多count个元素</span><br><span class="line">                     # count &lt; 0，从右到左删除最多count绝对值的元素</span><br><span class="line">                     # count = 0，删除所有</span><br><span class="line"></span><br><span class="line">ltrim key start end # 按照索引范围修剪列表</span><br></pre></td></tr></tbody></table></figure><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue # 修改指定索引下标的元素</span><br></pre></td></tr></tbody></table></figure><h3 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br></pre></td></tr></tbody></table></figure><p>blpop和brpop是lpop和rpop的阻塞版本，它们除了弹出方向不同，使用方法基本相同，所以下面以brpop命令进行说明，brpop命令包含两个参数：</p><ul><li>key [key…]：多个列表的键</li><li>timeout：阻塞时间（单位：秒）</li></ul><p>如果blpop/brpopkey时，key对应的列表为空，timeout=n，则客户端等待n秒后返回，如果timeout=0，则客户端一直阻塞，直到列表中被添加元素。如果列表不为空则直接返回。</p><p>如果使用的是多个键，redis会从左到右遍历键，一旦有一个键可以弹出元素，则客户端立即返回。</p><h2 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h2><p>列表类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当列表元素个数小于hash-max-ziplist-entries配置（默认512个）、同时列表中每个元素值都小于hash-max-ziplist-value配置（默认64字节）时，Redis会选用ziplist作为列表的内部实现来减少内存的使用。</li><li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li></ul><h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>消息队列：Redis的lpush+brpop命令组合即可实现阻塞队列，生产者使用lpush从列表左侧插入元素，多个消费者使用brpop命令阻塞式“抢”列表尾部的元素。</li><li>文章列表</li></ul><p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush + lpop = Stack(栈)</span><br><span class="line">lpush + rpop = Queue(队列)</span><br><span class="line">lpush + ltrim = Capped Collection(有限集合)</span><br><span class="line">lpush + brpop = Message Queue(消息队列)</span><br></pre></td></tr></tbody></table></figure><h1 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h1><p>集合(set)类型也是用来存储多个字符串元素，集合与列表的区别在于集合中不允许有重复元素，并且集合中的元素是无序的，不能使用索引下标获取元素。</p><p>一个集合中最多可以存储2^32-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><h3 id="集合内操作"><a href="#集合内操作" class="headerlink" title="集合内操作"></a>集合内操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...] # 添加元素，结果为成功添加个数</span><br><span class="line">srem key element [element ...] # 删除元素，结果为成功删除个数</span><br><span class="line"></span><br><span class="line">scard key # 计算元素个数</span><br><span class="line">sismember key element # 判断元素是否在集合中</span><br><span class="line"></span><br><span class="line">srandmember key [count] # 随机从集合返回指定个数元素，count默认值为1，仅返回不删除</span><br><span class="line">spop key # 从集合随机弹出一个元素，并删除</span><br><span class="line"></span><br><span class="line">smember key # 获取所有元素</span><br></pre></td></tr></tbody></table></figure><h3 id="集合间操作"><a href="#集合间操作" class="headerlink" title="集合间操作"></a>集合间操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...] # 求多个集合的交集</span><br><span class="line">suinon key [key ...] # 求多个集合的并集</span><br><span class="line">sdiff key [key ...] # 求多个集合的差集</span><br></pre></td></tr></tbody></table></figure><h2 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h2><p>集合类型的内部编码有两种：</p><ul><li>intset（整数集合）：当集合中元素都是整数且元素个数小于set-max-intset-enties配置（默认512个）时，Redis会选用intset作为集合的内部实现，从而减少内存的使用。</li><li>hashtable（哈希表）：当集合类型无法满足intset条件时，Redis会使用hashtable作为集合内部实现。</li></ul><h1 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h1><p>有序集合和集合一样也是字符串类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数(score)。Redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>列表、集合、有序集合三者异同点如下表所示：</p><table><thead><tr><th>数据结构</th><th>是否允许重复元素</th><th>是否有序</th><th>有序实现方式</th><th>应用场景</th></tr></thead><tbody><tr><td>列表</td><td>是</td><td>是</td><td>索引下标</td><td>时间轴、消息队列等</td></tr><tr><td>集合</td><td>否</td><td>否</td><td>-</td><td>标签、社交等</td></tr><tr><td>有序集合</td><td>否</td><td>是</td><td>分值</td><td>排行榜系统、社交等</td></tr></tbody></table><h2 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h2><h3 id="集合内操作-1"><a href="#集合内操作-1" class="headerlink" title="集合内操作"></a>集合内操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...] # 添加元素，返回成功添加的成员个数</span><br><span class="line">zcard key # 计算成员个数</span><br><span class="line">zscore key member # 计算某个成员的分数</span><br><span class="line"></span><br><span class="line">zrank key member # 计算成员排名，分数从低到高</span><br><span class="line">zrevrank key member # 计算成员排名，分数从高到低</span><br><span class="line"></span><br><span class="line">zrem key member [member ...] # 删除成员</span><br><span class="line"></span><br><span class="line">zincrby key increment member # 增加成员的分数</span><br><span class="line"></span><br><span class="line">zrange key start end [withscores] # 返回指定排名范围的成员，分数从低到高，加withscores选项会返回成员的分数</span><br><span class="line">zrevrange key start end [withscores] # 返回指定排名范围的成员，分数从高到低</span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [withscores] [limit offset count] # 返回指定分数范围的成员，按分数从低到高返回</span><br><span class="line">                        # withscores选项会同时返回分数，</span><br><span class="line">                        # [limit offset count]选项可以限制输出的起始位置和个数</span><br><span class="line">                        # min和max还支持开区间（小括号）和闭区间（中括号），-inf和+inf分别代表无限小和无限大</span><br><span class="line">zrevrangebyscore key max min [withscores] [limit offset count] # 返回指定分数范围的成员，按分数从高到低返回</span><br><span class="line"></span><br><span class="line">zcount key min max # 返回指定分数范围成员个数</span><br><span class="line">zremrangebyrank key start end # 删除指定排名内的升序元素</span><br><span class="line">zremrangebyscore key min max # 删除指定分数范围的成员</span><br></pre></td></tr></tbody></table></figure><h3 id="集合间操作-1"><a href="#集合间操作-1" class="headerlink" title="集合间操作"></a>集合间操作</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] # 交集</span><br><span class="line">    # destination：交集计算结果保存到这个键</span><br><span class="line">    # numkeys：需要做交集计算键的个数</span><br><span class="line">    # key [key ...]：需要做交集计算的键</span><br><span class="line">    # weights weight [weight ...]：每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1</span><br><span class="line">    # aggregate sum|min|max：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum</span><br><span class="line">            </span><br><span class="line">zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] # 并集</span><br></pre></td></tr></tbody></table></figure><h2 id="内部编码-5"><a href="#内部编码-5" class="headerlink" title="内部编码"></a>内部编码</h2><p>有序集合类型的内部编码有两种：</p><ul><li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li><li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul><h2 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h2><p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。本节使用赞数这个维度，记录每天用户上传视频的排行榜。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a&gt;内存模型&lt;/h1&gt;&lt;p&gt;Redis可以存储键与5 种数据结构类型之间的映射，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STRING 字符串&lt;/li&gt;
&lt;li&gt;LIST 列表&lt;/li&gt;
&lt;li&gt;SET 集合&lt;/li&gt;
&lt;li&gt;HASH 哈希&lt;/li&gt;
&lt;li&gt;ZSET 有序集合&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="https://haifuns.com/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://haifuns.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：CountDownLatch&amp;CyclicBarrier&amp;Semaphore</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-14/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-14/</id>
    <published>2020-12-26T09:58:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 适用于需要在主线程中开启多个线程去并行执行任务并且主线程需要等待所有子线程执行完后再进行汇总的场景。</p><span id="more"></span><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>实例代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatch</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个CountDownLatch 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch countDownLunch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span>(InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    countDownLunch.countDown();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"child threadOne over!"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span>(InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    countDownLunch.countDown();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"child threadTwo over!"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"wait all child thread over!"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待子线程执行完毕</span></span><br><span class="line">        countDownLunch.await();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"all child thread over!"</span>);</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait all child thread over!</span><br><span class="line">child threadOne over!</span><br><span class="line">child threadTwo over!</span><br><span class="line">all child thread over!</span><br></pre></td></tr></tbody></table></figure><p><strong>CountDownLatch 与join 方法的区别：</strong></p><ol><li>调用一个子线程的join() 方法后，该线程会一直被阻塞直到子线程运行完毕，而CountDownLatch 使用计数器来允许子线程运行完毕或者在运行中递减计数，也就是CountDownLatch 可以在子线程运行的任何时候让await 方法返回而不一定必须等到线程结束。</li><li>使用线程池来管理线程时一般都是直接添加Runable 到线程池，这时候就没有办法再调用线程的join 方法，CountDownLatch 相比join 对线程同步控制更加灵活。</li></ol><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/CountDownLatch-uml.png" alt="image"></p><p>从类图可以看出，CountDownLatch 是使用AQS 实现的。通过下面的构造函数可知，实际上是把计数器的值赋给了AQS 的状态变量state ，也就是使用AQS 状态值来表示计数器值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> count) {</span><br><span class="line">    setState(count);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-await-方法"><a href="#void-await-方法" class="headerlink" title="void await 方法"></a>void await 方法</h4><p>当线程调用CountDownLatch 对象的await 方法后，当前线程会被阻塞，直到下面的情况之一发生才会返回：</p><ul><li>当所有线程都调用了CountDownLatch 对象的 countDown 方法后，也就是计数器值为0 时</li><li>其他线程调用了当前线程的interrupt() 方法中断了当前线程，当前线程抛出InterruptedException 异常返回</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 调用AQS acquireSharedInterruptibly 方法，其内使用了模板方法，调用tryAcquireShared 实现</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">// 计数器是0直接返回，不是0则需要阻塞当前线程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit-方法"><a href="#boolean-await-long-timeout-TimeUnit-unit-方法" class="headerlink" title="boolean await(long timeout, TimeUnit unit) 方法"></a>boolean await(long timeout, TimeUnit unit) 方法</h4><p>当前线程会被阻塞，直到下面的情况之一发生才会返回：</p><ul><li>当所有线程都调用了CountDownLatch 对象的 countDown 方法后，也就是计数器值为0 时，返回true</li><li>设置的timeout 时间到了，超时返回false</li><li>其他线程调用了当前线程的interrupt() 方法中断了当前线程，当前线程抛出InterruptedException 异常返回</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-countDown-方法"><a href="#void-countDown-方法" class="headerlink" title="void countDown 方法"></a>void countDown 方法</h4><p>线程调用该方法后，计数器的值递减，递减后如果计数器值为0，则唤醒所有因调用await 法而被阻塞的线程，否则什么都不做。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        <span class="comment">// AQS 释放资源</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="comment">// 循环进行CAS，直到当前线程成功完成CAS使计数器值（状态值state ）减1 并更新到state</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 如果计数器为0直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// CAS让state减1</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="long-getCount-方法"><a href="#long-getCount-方法" class="headerlink" title="long getCount 方法"></a>long getCount 方法</h4><p>获取当前计数器的值，也就是AQS state 值，一般在测试时使用该方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="回环屏障-CyclicBarrier"><a href="#回环屏障-CyclicBarrier" class="headerlink" title="回环屏障 CyclicBarrier"></a>回环屏障 CyclicBarrier</h2><p>由于CountDownLatch 计数器是一次性的，计数器值变为0 后，再调用await 和countDown 方法都会立刻返回。为了满足计数器可以重置的需要，JDK 提供了CyclicBarrier，但CyclicBarrier 类的功能并不限于CountDownLatch 的功能。</p><p>从字面意思理解，CyclicBarrier 是回环屏障的意思，CyclicBarrier 可以让一组线程全部达到一个状态后再全部同时执行，之所以叫作回环是因为当所有等待线程执行完毕，并重置CyclicBarrier 的状态后它可以被重用。之所以叫作屏障是因为线程调用await 方法后就会被阻塞，这个阻塞点就称为屏障点，等所有线程都调用了await 方法后，线程们就会冲破屏障，继续向下运行。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task merge result"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    </span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executorService.execute(() - &gt; {</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-1 start"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-1 enter in barrier"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span>(InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-1 enter out barrier"</span>);</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        executorService.execute(() - &gt; {</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-2 start"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-2 enter in barrier"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            } <span class="keyword">catch</span>(InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task-2 enter out barrier"</span>);</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-1,5,main] task-1 start</span><br><span class="line">Thread[pool-1-thread-1,5,main] task-1 enter in barrier</span><br><span class="line">Thread[pool-1-thread-2,5,main] task-2 start</span><br><span class="line">Thread[pool-1-thread-2,5,main] task-2 enter in barrier</span><br><span class="line">Thread[pool-1-thread-2,5,main] task merge result</span><br><span class="line">Thread[pool-1-thread-2,5,main] task-2 enter out barrier</span><br><span class="line">Thread[pool-1-thread-1,5,main] task-1 enter out barrier</span><br></pre></td></tr></tbody></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="UML-1"><a href="#UML-1" class="headerlink" title="UML"></a>UML</h4><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/CyclicBarrier-uml.png" alt="image"></p><p>由类图可知，CyclicBarrier 基于独占锁实现，其底层还是基于AQS 的。parties 用来记录线程个数，这里表示多少线程调用await 后，所有线程才会冲破屏障。而count 一开始等于parties ，每当有线程调用await 就减1 ，当count 为0 表示所有线程都到了屏障点。</p><p>barrierCommand 任务，这个任务的执行时机是当所有线程都到达屏障点后。</p><p>在变量 generation 部有一 变量 broken ，其用来记录当前屏障是否被打破。</p><h4 id="int-await-方法"><a href="#int-await-方法" class="headerlink" title="int await 方法"></a>int await 方法</h4><p>当前线程调用CyclicBarrier 该方法后会被阻塞，直到满足下面条件之一才会返回：</p><ul><li>parties 个线程都调用了await 方法，也就是线程都达到了屏障点</li><li>其他线程调用了当前线程的interrupt 方法中断了当前线程，则当前线程会抛出InterruptedException 异常而返回</li><li>与当前屏障点关联的Generation 对象的broken 标志被设置true 时，会抛BrokenBarrierException 异常后返回</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (TimeoutException toe) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit-方法-1"><a href="#boolean-await-long-timeout-TimeUnit-unit-方法-1" class="headerlink" title="boolean await(long timeout, TimeUnit unit) 方法"></a>boolean await(long timeout, TimeUnit unit) 方法</h4><p>当前线程调用CyclicBarrier 该方法后会被阻塞，直到满足下面条件之一才会返回：</p><ul><li>parties 个线程都调用了await 方法，也就是线程都达到了屏障点，返回true</li><li>设置的超时时间到了后返回false</li><li>其他线程调用了当前线程的interrupt 方法中断了当前线程，则当前线程会抛出InterruptedException 异常而返回</li><li>与当前屏障点关联的Generation 对象的broken 标志被设置true 时，会抛BrokenBarrierException 异常后返回</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>{</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="int-dowait-boolean-timed-long-nanos-方法"><a href="#int-dowait-boolean-timed-long-nanos-方法" class="headerlink" title="int dowait(boolean timed, long nanos) 方法"></a>int dowait(boolean timed, long nanos) 方法</h4><p>该方法实现了CyclicBarrer 的核心功能，其代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {  <span class="comment">// index==0说明所有线程都到了屏障点，此时执行初始化时传递的任务</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run(); <span class="comment">// 执行任务</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration(); <span class="comment">// 激活其他因调用await方法而阻塞的线程，并重置CyclicBarrier</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// index != 0</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!timed) <span class="comment">// 没有设置超时时间</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) <span class="comment">// 设置了超时时间</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException ie) {</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) {</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) {</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll(); <span class="comment">// 唤醒条件队列中的阻塞队列</span></span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties; <span class="comment">// 重置CyclicBarrier</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>Semaphore 信号量也是Java 中的一个同步器，与CountDownLatch 和CycleBarrier 不同的是，它内部的计数器是递增的，并且在一开始初始化Semaphore 时可以指定一个初始值，但是并不需要知道需要同步的线程个数，而是在需要同步的地方调用acquire 方法时指定需要同步的线程个数。</p><h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><p>在主线程中开启两个子线程让它们执行，等所有子线程执行完毕后主线程再继续向下运行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建信号量示例，参数0 表示当前信号量计数器值为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        </span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        executorService.execute(() - &gt; {</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" over"</span>);</span><br><span class="line">            semaphore.release(); <span class="comment">// 信号量计数器加1</span></span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        executorService.execute(() - &gt; {</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" over"</span>);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 阻塞直到信号量计数为2</span></span><br><span class="line">        semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"all child thread over"</span>);</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] over</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main] over</span><br><span class="line">all child thread over</span><br></pre></td></tr></tbody></table></figure><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="UML-2"><a href="#UML-2" class="headerlink" title="UML"></a>UML</h4><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/Semaphore-uml.png" alt="image"></p><p>由类图可知，Semaphor 还是使用AQS 实现的。 Sync 只是对AQS 的一个修饰，并且Sync 有两个实现类，用来指定获取信号量时是否采用公平策略。例如，下面的代码在创建Semaphore 时会使用一个变量指定是否使用非公平策略。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) {</span><br><span class="line">    setState(permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在如上代码中Semaphore 默认采用非公平策略，如果需要使用公平策略则可以使用带两个参数的构造函数来构造Semaphore 对象。另外，如CountDownLatch 构造函数传递的初始化信号量permits 被赋给了AQS state 状态变量一样，这里AQS state 表示当前持有的信号量个数。</p><h4 id="void-acquire-方法"><a href="#void-acquire-方法" class="headerlink" title="void acquire 方法"></a>void acquire 方法</h4><p>当前线程调用该方法的目的是希望获取一个信号量资源。 如果当前信号量个数大于0，则信号量的个数会减1，然后该方法直接返回。否则如果当前信号量个数等于0 ，则当前线程会被放入AQS 的阻塞队列。当其他线程调用了当前线程interrupt 方法中断了当前线程时，则当前线程会抛出InterruptedEception 异常返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">// AQS 内部调用tryAcquireShared</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平策略 NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> available = getState(); <span class="comment">// 当前信号量值</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 剩余值</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining)) <span class="comment">// 如果当前剩余值小于0或者CAS设置成功则返回</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平策略 FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors()) <span class="comment">// 公平策略，看当前线程节点的前驱节点是否也在等待获取此资源，如果是则当前线程会被放到AQS阻塞队列，否则直接获取</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-acquire-int-permits-方法"><a href="#void-acquire-int-permits-方法" class="headerlink" title="void acquire(int permits) 方法"></a>void acquire(int permits) 方法</h4><p>该方法与acquire方法不同，后者只需要获取一个信号量值，而前者则获取permits 个。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-acquireUninterruptibly-方法"><a href="#void-acquireUninterruptibly-方法" class="headerlink" title="void acquireUninterruptibly() 方法"></a>void acquireUninterruptibly() 方法</h4><p>该方法与acquire 方法相似，不同之处在于该方法对中断不响应。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-acquireUninterruptibly-int-permits-方法"><a href="#void-acquireUninterruptibly-int-permits-方法" class="headerlink" title="void acquireUninterruptibly(int permits) 方法"></a>void acquireUninterruptibly(int permits) 方法</h4><p>该方法与acquire(int permits) 方法的不同之处在于该方法对中断不响应。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-release-方法"><a href="#void-release-方法" class="headerlink" title="void release() 方法"></a>void release() 方法</h4><p>该方法的作用是把当前Semaphore 信号量值增加1 ，如果当前有线程因为调用aquire 方法被阻塞而被放入了AQS 阻塞队列，则会根据公平策略选择一个信号量个数能被满足的线程进行激活，激活的线程会尝试获取刚增加的信号。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) { <span class="comment">// 尝试释放资源</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 资源释放后调用park方法唤醒AQS队列中最先挂起的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> current = getState(); <span class="comment">// 当前信号量值</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases; <span class="comment">// 当前信号量+1</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// CAS修改信号量值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-release-int-permits-方法"><a href="#void-release-int-permits-方法" class="headerlink" title="void release(int permits) 方法"></a>void release(int permits) 方法</h4><p>该方法与不带参数的release 方法的不同之处在于，前者每次调用会在原信号量值的基础上增加 permit ，而后者每次增加1 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;CountDownLatch 适用于需要在主线程中开启多个线程去并行执行任务并且主线程需要等待所有子线程执行完后再进行汇总的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：ThreadPoolExecutor</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-13/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-13/</id>
    <published>2020-12-26T09:57:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>线程池主要解决以下两个问题：</strong></p><ol><li>当执行大量异步任务时线程池能够提供较好的性能。线程是可复用的，减少创建和销毁开销。</li><li>线程池也提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。</li></ol><p><strong>线程池状态含义如下：</strong></p><ul><li>RUNNING：接受新任务并处理阻塞队列里的任务</li><li>SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务</li><li>STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务</li><li>TIDYING：所有任务都执行完后当前线程池活动线程数为0，将要调用terminated 方法</li><li>TERMINATED：终止状态</li></ul><span id="more"></span><p><strong>线程池状态转换列举如下：</strong></p><ul><li>RUNNING -&gt; SHUTDOWN：显示调用shutdown() 方法或隐式调用finalize() 方法里面的shutdown() 方法</li><li>RUNNING/SHUTDOWN -&gt; STOP：显示调用shutdownNow() 方法</li><li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时</li><li>STOP -&gt; TIDYING：当线程池为空时</li><li>TIDYING -&gt; TERMINATED：当terminated() hook 方法执行完成时</li></ul><p><strong>线程池参数如下：</strong></p><ul><li>corePoolSize：线程池核心线程个数</li><li>workQueue：任务阻塞队列（比如基于数组的有界阻塞ArrayBlockingQueue、基于链表的无界阻塞LinkedBlockingQueue、最多只有一个元素的同步队列SynchronousQueue以及优先级队列PriorityBlockingQueue等）</li><li>maximunPoolSize：线程池最大线程数量</li><li>ThreadFactory：线程创建工厂</li><li>RejectedExecutionHandler：饱和策略，当队列满并且队列个数达到maximunPoolSize后采取的策略，比如AbortPolicy（抛出异常）、CallerRunsPolicy（使用调用者所在线程来运行任务）、DiscardOldestPolicy（调用poll丢弃一个任务，执行当前任务）以及DiscardPolicy（丢弃且不抛异常）</li><li>keeyAliveTime：存活时间，如果当前线程池中的线程数量比核心线程数量多并且是闲置状态，则这些闲置线程的最大存活时间</li><li>TimeUnit：存活时间单位</li></ul><p><strong>线程池类型如下：</strong></p><ul><li>newFixedThreadPool：创建一个核心线程个数和最大线程个数都是nThread 的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keeyAliveTime=0 说明只要线程个数比核心线程数多并且当前空闲则回收。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>newSingleThreadExecutor：创建一个核心线程数和最大线程数都是1的线程池，阻塞队列长度为Interger.MAX_VALUE，keeyAliveTime=0 说明只要线程个数比核心线程数多并且当前空闲则回收。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>newCachedThreadPool：创建一个按需创建线程的线程池，初始线程数是0，最多线程个数为Integer.MAX_VALUE，并且阻塞队列为同步队列。keeyAliveTime=60 说明只要当前线程在60s 内空闲则回收。此线程池的特殊之处在于，加入同步队列的任务会被马上执行，同步队列里最多只能有一个任务。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>newScheduledThreadPool：创建一个周期线程池，支持定时及周期性任务执行。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ThreadPoolExecutor-uml.png" alt="image"></p><p>如上ThreadPoolExecutor 类图所示，其中：</p><ul><li>mainLock 是独占锁，用来控制新增Worker 线程操作的原子性</li><li>termination 是mainLock锁对应条件队列，线程调用 awaitTermination 时用来存放阻塞线程</li><li>Worker 继承AQS 和Runnable 接口，是具体承载任务的对象。 Worker继承AQS,<br>实现了简单不可重入独占锁，其中<ul><li>state=0 表示锁未被获取</li><li>state=1 表示锁已经被获取的状态，</li><li>state=-1是创建Worker 默认的状态，创建时状态值设置为-1 是为了避免线程在 runWorker 方法前被中断</li><li>firstTask 记录该工作线程执行的第一个任务</li><li>thread 是具体执行任务的线程</li></ul></li><li>DefaultThreadFactory 是线程工厂，newThread 方法是对线程的一个修饰，其中<ul><li>poolNumber 是静态原子变量，用来统计线程工厂的个数</li><li>threadNumber 记录每个线程工厂创建的线程数</li></ul></li></ul><h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="public-void-execute-Runable-command"><a href="#public-void-execute-Runable-command" class="headerlink" title="public void execute(Runable command)"></a>public void execute(Runable command)</h4><p>提交非空任务command 到线程池进行执行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">// 获取当前线程池的状态+线程个数变量的组合值</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) { <span class="comment">// 当前线程池中线程个数小于corePoolSize则开启新线程运行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) { <span class="comment">// 线程池处于RUNNABLE状态则添加任务到阻塞队列</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 二次检查</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 如果当前线程池状态不是RUNNABLE则从队列删除任务并执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 如果当前线程池为空则添加一个线程</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 如果队列满，则新增线程，新增失败则执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>{</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列是否只在必要时为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环CAS增加线程个数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果线程个数超限则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// CAS增加线程个数</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果CAS失败则检查线程池状态是否变化，变化则调到外层循环重新尝试获取线程池状态，否则循环CAS</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS成功后</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 创建worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) {</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 加独占锁，实现workers同步</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 重新检查线程池状态，避免在获取锁前被调用shutdown</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 添加任务</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加任务成功后则启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="shutdown操作"><a href="#shutdown操作" class="headerlink" title="shutdown操作"></a>shutdown操作</h4><p>调用此方法后，线程池就不会再接受新的任务了，但是工作队列里面的任务还是要执行的。该方法会立刻返回，并不等待队列任务完成再返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess(); <span class="comment">// 权限检查</span></span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// 设置当前线程池状态是SHUTDOWN，如果已经是SHUTDOWN状态则直接返回</span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">// 设置中断标志</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate(); <span class="comment">// 尝试将状态变为TERMINATED</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置中断标志</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>{</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) {</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 如果工作线程没有被中断并且没有在运行则设置中断状态</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将状态变为TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) { <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) { <span class="comment">// 设置线程池状态为TIDYING</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    terminated();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">// 设置线程池状态为TERMINATED</span></span><br><span class="line">                    termination.signalAll(); <span class="comment">// 激活因调用条件变量termination的await系列方法而被阻塞的所有线程</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="shutdownNow操作"><a href="#shutdownNow操作" class="headerlink" title="shutdownNow操作"></a>shutdownNow操作</h4><p>调用shutdownNow 方法后，线程池不会再接受新的任务，并且会丢弃工作队列里面的任务，正在执行的任务会被中断，该方法会立刻返回。返回值为队列里面被丢弃的任务列表。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>{</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess(); <span class="comment">// 权限检查</span></span><br><span class="line">        advanceRunState(STOP); <span class="comment">// 设置线程池状态为STOP</span></span><br><span class="line">        interruptWorkers(); <span class="comment">// 中断所有线程</span></span><br><span class="line">        tasks = drainQueue(); <span class="comment">// 将队列任务移动到tasks</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate(); <span class="comment">// 尝试将状态变为TERMINATED</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="awaitTermination操作"><a href="#awaitTermination操作" class="headerlink" title="awaitTermination操作"></a>awaitTermination操作</h4><p>调用此方法后，当前线程会被阻塞，直到线程池状态变为TERMINATED 才返回，或者等待时间 超时才返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor是一个可以在指定一定延迟时间后或者定时进行任务调度执行的线程池。</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ScheduledThreadPoolExecutor-uml.png" alt="image"></p><p>ScheduledFutureTask 是具有返回值的任务，继承自FutureTask 。FutureTask 的内部有一个变量state 用来表示任务的状态，一开始状态为NEW ，所有状态为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>; <span class="comment">// 初始状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; <span class="comment">// 执行中状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; <span class="comment">// 正常运行结束状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; <span class="comment">// 运行中异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; <span class="comment">// 任务被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">// 任务正在被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>; <span class="comment">// 任务已经被中断</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可能的任务状态转换路径为：</p><ul><li>NEW -&gt; COMPLETING -&gt; NORMAL ：初始状态 -&gt; 执行中 -&gt; 正常结束</li><li>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL ：初始状态 -&gt; 执行中 -&gt; 执行异常</li><li>NEW -&gt; CANCELLED ：初始状态 -&gt; 任务取消</li><li>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED ：初始状态 -&gt; 被中断中 -&gt; 被中断</li></ul><p>ScheduledFutureTask 内部还有一个变量period 用来表示任务的类型，任务类型如下：</p><ul><li>period=0 说明当前任务是一次性的，执行完毕后退出</li><li>period 为负数，说明当前任务是fixed-delay 任务，是固定延迟的定时可重复执行任务</li><li>period 为正数，说明当前任务是fixed-rate 任务，是固定频率的定时可重复执行任务</li></ul><p>ScheduledThreadPoolExecutor的一个构造函数如下，有构造函数可知线程池队列是DelayedWorkQueue</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用改造后的DelayQueue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="comment">// 调用父类ThreadPoolExecutor构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="原理剖析-1"><a href="#原理剖析-1" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="schedule-command-Runnable-delay-long-unit-TimeUnit"><a href="#schedule-command-Runnable-delay-long-unit-TimeUnit" class="headerlink" title="schedule(command: Runnable, delay: long, unit: TimeUnit)"></a>schedule(command: Runnable, delay: long, unit: TimeUnit)</h4><p>提交一个延迟执行的任务，从提交时间算起延迟单位为unit 的delay 时间后开始执行。任务只会执行一次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) {</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务转换</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">                                      </span><br><span class="line">    <span class="comment">// 添加任务到延迟队列</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduledFutureTask构造函数</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) {</span><br><span class="line">    <span class="keyword">super</span>(r, result); <span class="comment">// 调用父类FutureTask构造函数，通过适配器把runnable转换为callable</span></span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>; <span class="comment">// 标记为一次性任务</span></span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加任务到延迟队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task); <span class="comment">// 如果线程池关闭则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task); <span class="comment">// 添加任务到延迟队列</span></span><br><span class="line">        <span class="comment">// 检查线程池状态</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart(); <span class="comment">// 确保至少一个线程正在处理任务</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面看一下线程池中的线程如何获取并执行任务：</p><p>具体执行任务的线程是Worker，Worker调用任务的run 方法来执行，这里的任务是ScheduledFutureTask，其run 方法源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 是否只执行一次</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 是否取消任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 任务是否可重复执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 单次任务执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) {</span><br><span class="line">        <span class="comment">// 设置time=time+period</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 重新把任务放到delay队列</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="scheduleWithFixedDelay-command-Runnable-initialDelay-long-delay-long-unit-TimeUnit"><a href="#scheduleWithFixedDelay-command-Runnable-initialDelay-long-delay-long-unit-TimeUnit" class="headerlink" title="scheduleWithFixedDelay(command: Runnable, initialDelay: long, delay: long, unit: TimeUnit)"></a>scheduleWithFixedDelay(command: Runnable, initialDelay: long, delay: long, unit: TimeUnit)</h4><p>当任务执行完毕后，让其延迟固定时间后再次运行（fixed-delay 任务）。其中initialDelay 表示提交任务后延迟多少时间开始执行任务command ，delay 表示当任务执行完毕后延长多少时间后再次运行command 任务，unit 是initialDelay 和delay 的时间单位。任务会一直重复运行直到任务运行中抛出了异常、被取消或者关闭了线程池。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) {</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 任务转换，period=-delay&lt;0表示可重复执行的任务</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t); <span class="comment">// 添加任务到队列</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>fixe-delay 类型的任务的执行原理为，当添加一个任务到延迟队列后，等待 initialDelay 时间，任务就会过期，过期的任务就会被从队列移除，并执行。执行完毕后，会重新设置任务的延迟时间，然后再把任务放入延迟队列，循环往复。需要注意的是，如果一个任务在执行中抛出了异常，那么这个任务就结束了，但是不影响其他任务的执行。</p><h4 id="scheduleAtFixedRate-command-Runnable-initialDelay-long-delay-long-unit-TimeUnit"><a href="#scheduleAtFixedRate-command-Runnable-initialDelay-long-delay-long-unit-TimeUnit" class="headerlink" title="scheduleAtFixedRate(command: Runnable, initialDelay: long, delay: long, unit: TimeUnit)"></a>scheduleAtFixedRate(command: Runnable, initialDelay: long, delay: long, unit: TimeUnit)</h4><p>该方法相对起始时间点以固定频率调用指定的任务（fixed-rate 任务）。当把任务提交到线程池并延迟initialDelay 时间，时间单位为unit 后开始执行任务 command 。然后initialDelay+period 时间点再次执行，而后在 initialDelay + 2 * period 时间点再次执行，循环往复，直到抛出异常或者调用了任务的cancel方法取消了任务，或者关闭了线程池。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) {</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 装饰任务类，注意period=period&gt;0，非负</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>相对于 fixed-delay 任务来说，fixed-rate 方式执行规则为，时间为 initialDelay + n * period 时启动任务，但是如果当前任务还没有执行完，下次要执行任务的时间到了则不会并发执行，下次要执行的任务会延迟执行，要等到当前任务执行完毕后再执行。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线程池主要解决以下两个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当执行大量异步任务时线程池能够提供较好的性能。线程是可复用的，减少创建和销毁开销。&lt;/li&gt;
&lt;li&gt;线程池也提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;线程池状态含义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RUNNING：接受新任务并处理阻塞队列里的任务&lt;/li&gt;
&lt;li&gt;SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务&lt;/li&gt;
&lt;li&gt;STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务&lt;/li&gt;
&lt;li&gt;TIDYING：所有任务都执行完后当前线程池活动线程数为0，将要调用terminated 方法&lt;/li&gt;
&lt;li&gt;TERMINATED：终止状态&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：Queue</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-12/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-12/</id>
    <published>2020-12-26T09:56:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 线程安全的<strong>无界非阻塞</strong>队列，其底层数据结构使用单向链表实现，对于入队和出队操作使用 CAS 来实现线程安全。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ConcurrentLinkedQueue-uml.png" alt="image"></p><p>ConcurrentLinkedQueue 内部的队列使用单向链表的方式实现，其中有两个volatile 类型的Node 节点分别用来存放队列首、尾节点。</p><p>Node 内部则维护一个使用volatile 修饰的item，用来存放节点的值；next 用来存放链表的下一个节点；其内部使用UNSafe 工具类提供的CAS 算法来保证入队时操作链表的原子性。</p><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="offer-操作"><a href="#offer-操作" class="headerlink" title="offer 操作"></a>offer 操作</h4><p>在队列末尾添加一个元素，如果传递的参数是null 则抛出NPE 异常，否则由于 ConcurrentLinkedQueue 是无界队列，该方法一直会返回true 。另外，由于使用CAS 无阻塞算法，因此方法不会阻塞挂起调用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    checkNotNull(e); <span class="comment">// e为空抛出空指针异常</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e); <span class="comment">// 构造Node节点，构造函数内部调用unsafe.putObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) { <span class="comment">// 从尾节点进行插入</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) { <span class="comment">// 如果q是空说明p是尾节点，则执行插入</span></span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) { <span class="comment">// 使用cas设置p节点的next节点</span></span><br><span class="line">                <span class="comment">// CAS成功，则说明新增节点已经被放入链表</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 多线程操作时，由于poll操作移除元素后可能会把head变为自引用，也就是head的next变成了head，所以这里需要重新找新的head</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 寻找尾节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="add-操作"><a href="#add-操作" class="headerlink" title="add 操作"></a>add 操作</h4><p>add 操作是在链表末尾添一个元素，其实在内部调用的还是 offer 操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="poll-操作"><a href="#poll-操作" class="headerlink" title="poll 操作"></a>poll 操作</h4><p>poll 操作是在队列头部获取并移除一个元素 如果队列为空则返回 null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    restartFromHead: <span class="comment">// goto标记</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) {</span><br><span class="line">            E item = p.item; <span class="comment">// 保存当前节点值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) { <span class="comment">// 当前节点有值则CAS变为null</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// CAS成功则标记当前节点并从链表删除</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) { <span class="comment">// 当前队列为空则返回null</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// 如果当前节点被自引用，则重新寻找新的队列头节点</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="peek-操作"><a href="#peek-操作" class="headerlink" title="peek 操作"></a>peek 操作</h4><p>获取队列头部一个元素（只获取不移除），如果队列为空则返回 null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) {</span><br><span class="line">            E item = p.item; <span class="comment">// 保存当前节点值</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> || (q = p.next) == <span class="keyword">null</span>) { </span><br><span class="line">                updateHead(h, p);  <span class="comment">// 在第一次调peek操作时，会删除哨兵节点，并让队列的head节点指向队列里面第一个元素或者null</span></span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">// 如果当前节点被自引用，则重新寻找新的队列头节点</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h4><p>计算当前队列元素个数，在并发环境下不是很有用，因为CAS 没有加锁，所以从调用size 函数到返回结果期间有可能增删元素，导致统计的元素个数不精确。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 最大值Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个队列元素（哨兵元素不算），没有则返回null</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>{</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) {</span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前节点的next元素，如果是自引入节点则返回真正的头节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>{</span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove 操作"></a>remove 操作</h4><p>如果队列里面存在该元素则删除该元素，如果存在多个则删除第一个，并返回true，否则返回false。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) {</span><br><span class="line">        Node&lt;E&gt; next, pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; pred = p, p = next) {</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (!o.equals(item)) {</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                removed = p.casItem(item, <span class="keyword">null</span>); <span class="comment">// 相等则使用CAS设置为null，同时一个线程操作成功，失败的线程循环查找队列中是否有匹配的其他元素</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            next = succ(p); <span class="comment">// 获取next元素</span></span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) <span class="comment">// 如果有前驱节点，并且next不为空则链接前驱节点到next</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">if</span> (removed)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 为空返回false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="contains操作"><a href="#contains操作" class="headerlink" title="contains操作"></a>contains操作</h4><p>判断队列里面是否含有指定对象，由于是遍历整个队列，所以像size 操作一样结果也不是那么精确，有可能调用该方法时元素还在队列里面，但是遍历过程中其他线程才把该元素删除了，那么就会返回 false。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) {</span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; o.equals(item))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是使用独占锁实现的<strong>无界（可指定有界）阻塞</strong>队列。</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/LinkedBlokingQueue-uml.png" alt="image"></p><p>LinkedBlockingQueue 也是使用单向链表实现的，其也有两个Node ，分别用来存放首、尾节点，并且还有一个初始值为 0 的原子变量count ，用来记录队列元素个数。</p><p>还有两个ReentrantLock 的实例，分别用来控制元素入队和出队的原子性，其中takeLock 用来控制同时只有一个线程可以从队列头获取元素，其他线程必须等待。putLock 控制同时只能有一个线程可以获取锁，在队列尾部添加元素，其他线程必须等待。</p><p>另外，notEmpty 和notFull 是条件变量，它们内部都有一个条件队列用来存放进队和出队时被阻塞的线程，其实这是生产者-消费者模型。</p><p>从LinkedBlockingQueue 的构造函数可知，其默认容量是0x7fffffff，用户也可以自定义容量，所以从一定程度上可以说从LinkedBlockingQueue 是有界阻塞队列。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>); <span class="comment">// 初始化首、尾节点，让他们指向哨兵节点</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="offer操作"><a href="#offer操作" class="headerlink" title="offer操作"></a>offer操作</h4><p>向队列尾部插入一个元素，如果队列中有空闲则插入成功后返回true ，如果队列己满则丢弃当前元素然后返回false 。此方法是非阻塞。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// e为空元素则抛空指针异常</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity) <span class="comment">// 如果队列已满则丢弃并返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e); <span class="comment">// 构造新节点</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock; <span class="comment">// 获取putLock独占锁</span></span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) { <span class="comment">// 如果队列不满则进队列，并递增元素计数</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果新元素入队后还有空闲空间则唤醒一个入队线程</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        putLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty(); <span class="comment">// 唤醒notEmpty条件队列中因为调用notEmpty的await方法（比如调用take方法时队列为空）而被阻塞的线程</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>向队列尾部插入一个元素，如果队列中有空闲则插入后直接返回，如果队列已满则阻塞当前线程，直到队列有空闲插入成功后返回。如果在阻塞时被其他线程设置了中断标志，被阻塞线程会抛出InterruptedException 异常而返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put操作代码与offer类似</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="comment">// 非空校验</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 构建新节点，并获取独占锁putLock</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果队列已满则等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) { <span class="comment">// 此处循环检查防止虚假唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 进队列并递增计数</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 还有剩余空间则唤醒入队线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 入队成功唤醒出队线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="poll操作"><a href="#poll操作" class="headerlink" title="poll操作"></a>poll操作</h4><p>从队列头部获取并移除一个元素 如果队列为空则返回null 。此方法是不阻塞的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">// 计数为0直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock; <span class="comment">// 获取独占锁</span></span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) { <span class="comment">// 队列不为空</span></span><br><span class="line">            x = dequeue(); <span class="comment">// 出队</span></span><br><span class="line">            c = count.getAndDecrement(); <span class="comment">// 递减计数</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal(); <span class="comment">// 还有元素则唤醒下一个出队线程</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull(); <span class="comment">// 当前线程已满，移除元素后唤醒一个因调用put而被阻塞到notFull条件队列的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="peek操作"><a href="#peek操作" class="headerlink" title="peek操作"></a>peek操作</h4><p>获取队列头部元素但是不从队列里面移除它，如果队列为空返回null 。此方法是不阻塞的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">// 无元素直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock; <span class="comment">// 获取takeLock</span></span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) <span class="comment">// 防止其他线程执行了poll或take操作导致线程变为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><p>获取当前队列头部元素并从队列里移除它，如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞时被其他线程设置了中断标志，则阻塞线程会抛出InterruptedException 异常而返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock; <span class="comment">// 获取锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) { <span class="comment">// 当前队列为空则阻塞挂起</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        }</span><br><span class="line">        x = dequeue(); <span class="comment">// 出队</span></span><br><span class="line">        c = count.getAndDecrement(); <span class="comment">// 递减计数</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 唤醒出队线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull(); <span class="comment">// 唤醒入队线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h4><p>删除队列里面指定的元素，有则删除并返回true ，没有则返回 false。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock(); <span class="comment">// 双重加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next; <span class="comment">// 遍历队列找到则删除并返回true</span></span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) {</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) {</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        fullyUnlock(); <span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node&lt;E&gt; p, Node&lt;E&gt; trail)</span> </span>{</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    trail.next = p.next;</span><br><span class="line">    <span class="keyword">if</span> (last == p)</span><br><span class="line">        last = trail;</span><br><span class="line">    <span class="keyword">if</span> (count.getAndDecrement() == capacity) <span class="comment">// 如果当前线程已满，删除后唤醒等待线程</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>{</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>{</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>获取当前队列元素个数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于进行入队和出队操作时的count加了锁，所以结果比ConcurentLinkedQueue的size 方法准确。</p><blockquote><p>ConcurentLinkedQueue中遍历链表获取size未使用原子变量保存是因为使用原子变量保存队列元素个数需要保证入队、出队和原子变量操作时原子性操作，而ConcurentLinkedQueue 使用的是CAS 无锁算法，所以无法实现。</p></blockquote><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是用<strong>有界数组</strong>方式实现的<strong>阻塞</strong>队列。</p><h3 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ArrayBlockingQueue-uml.png" alt="image"></p><p>ArrayBlockingQueue 内部结构如下：</p><ul><li>items： 数组，用来存放队列元素</li><li>putIndex：入队元素下标</li><li>takeIndex: 出队元素下标</li><li>count: 队列元素个数</li><li>lock: 独占锁，保证出、入操作的原子性</li><li>notEmpty: 出队条件变量 </li><li>notFull：入队条件变量</li></ul><p>构造函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ArrayBlockingQueue 是有界队列，构造函数必须传入队列大小参数。在默认情况下使用ReentrantLock 提供的非公平独占锁进行出、入队操作的同步。</p><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="offer操作-1"><a href="#offer操作-1" class="headerlink" title="offer操作"></a>offer操作</h4><p>向队列尾部插入一个非空元素，如果队列有空闲空间则插入成功后返回true ，如果队列已满则丢弃当前元素然后返回false 。此方法是不阻塞的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    checkNotNull(e); <span class="comment">// 非空校验</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 获取独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">// 如果队列已满返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            enqueue(e); <span class="comment">// 队列有空闲空间则插入元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items; <span class="comment">// 元素入队</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) <span class="comment">// 计算下一个元素应该存放的下标位置</span></span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal(); <span class="comment">// 唤醒出队阻塞线程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h4><p>向队列尾部插入一个非空元素，如果队列有空闲空间则插入后直接返回true ，如果队列已满则阻塞当前线程直到队列有空闲并插入成功后返回true ，如果在阻塞时被其他线程设置了中断标志， 则被阻塞线程会抛出InterruptedException 异常而返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取可中断锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列已满则把当前线程放入notFull管理的条件队列</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e); <span class="comment">// 插入元素</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="poll操作-1"><a href="#poll操作-1" class="headerlink" title="poll操作"></a>poll操作</h4><p>从队列头部获取一个元素，如果队列为空则返回null。此方法是不阻塞的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    E x = (E) items[takeIndex]; <span class="comment">// 获取元素值</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>; <span class="comment">// 获取后设置为空</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) <span class="comment">// 重置队列头下标</span></span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--; <span class="comment">// 队列元素个数减1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued(); </span><br><span class="line">    notFull.signal(); <span class="comment">// 唤醒入队阻塞的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="take操作-1"><a href="#take操作-1" class="headerlink" title="take操作"></a>take操作</h4><p>获取当前队列头部元素并从队列里面移除它。如果队列为空则阻塞当前线程直到队列不为空然后返回元素。此方法响应中断。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">// 获取队列头元素</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="peek操作-1"><a href="#peek操作-1" class="headerlink" title="peek操作"></a>peek操作</h4><p>获取队列头部元素但是不从队列里面移除它。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h4><p>计算当前队列元素个数（全局锁，结果精准）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue 是<strong>带优先级的无界阻塞</strong>队列，每次出队都返回优先级最高或者最低的元素。其内部是使用平衡二叉树堆实现的，所以直接遍历队列元素不保证有序。默认使用对象的CompareTo 方法提供比较规则，如果需要自定义比较规则则可以自定义comparators。</p><h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/PriorityBlockingQueue-uml.png" alt="image"></p><p>PriorityBlockingQueue 内部结构如下：</p><ul><li>queue：数组，用来存放队列元素</li><li>size：队列元素个数</li><li>allocationSpinLock：自旋锁，使用CAS 操作保证只有一个线程可以进行扩容，0表示当前没有进行扩容，1表示正在扩容</li><li>lock: 独占锁，保证同时只有一个线程可以进行入队、出队操作</li><li>notEmpty：出队条件变量</li></ul><p>构造函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PriorityBlockingQueue 默认队列容量为11，默认比较器为null，也就是使用元素的compareTo方法确认优先级（元素必须实现Comparable接口）。</p><h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="offer操作-2"><a href="#offer操作-2" class="headerlink" title="offer操作"></a>offer操作</h4><p>在队列中插入一个元素，由于是无界队列所以一直返回true。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length)) <span class="comment">// 当前元素个数&gt;=队列容量则扩容</span></span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>) <span class="comment">// 默认比较器是null</span></span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp); <span class="comment">// 自定义比较器</span></span><br><span class="line">        size = n + <span class="number">1</span>; <span class="comment">// 将队列元素个数加1</span></span><br><span class="line">        notEmpty.signal(); <span class="comment">// 唤醒阻塞在出队的线程</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>{</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放获取的锁</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset, <span class="comment">// CAS更新扩容标记</span></span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// oldCap&lt;64，则扩容oldCap+2，否则扩容50%</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) {    <span class="comment">// 最大值Integer.MAX_VALUE - 8</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// CAS更新失败后，当前线程让出CPU，尽量让扩容成功的线程获取锁，但扩容线程并不一定能获取到锁</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) {</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树堆 建堆算法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>{</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="comment">// 队列元素个数&gt;0则判断插入位置，否则直接入队</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    array[k] = key;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="poll操作-2"><a href="#poll操作-2" class="headerlink" title="poll操作"></a>poll操作</h4><p>获取队列内部堆树的根节点元素。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Object[] array = queue; <span class="comment">// 获取队列头元素</span></span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        E x = (E) array[n]; <span class="comment">// 获取队列尾元素</span></span><br><span class="line">        array[n] = <span class="keyword">null</span>; <span class="comment">// 尾元素赋值为null</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="comment">// 重新调整堆</span></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="put操作-2"><a href="#put操作-2" class="headerlink" title="put操作"></a>put操作</h4><p>put 操作内部调用的是offer 操作，由于是无界队列，所以不需要阻塞。</p><h4 id="take操作-2"><a href="#take操作-2" class="headerlink" title="take操作"></a>take操作</h4><p>获取队列内部堆树的根节点元素，如果队列为空则阻塞，响应中断。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取可中断锁</span></span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>) <span class="comment">// 获取队列尾元素，如果队列为空则阻塞</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="size操作-2"><a href="#size操作-2" class="headerlink" title="size操作"></a>size操作</h4><p>计算队列元素个数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue 并发队列是一个<strong>无界阻塞延迟</strong>队列，队列中的每个元素都有个过期时间，当从队列获取元素时，只有过期元素才会出队列。队列头元素是最快要过期的元素。</p><h3 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/DelayQueue-uml.png" alt="image"></p><p>DelayQueue 内部使用PriorityQueue 存放数据，使用ReentrantLock 实现线程同步。队列中的元素需要实现Delayed 接口，实现比较接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>leader 变量的使用基于 Lead - Follower 模式的变体，用于尽量减少不必要的线程等待。当一个线程调用队列的take 方法变leader 线程后，它会调用条件变量available.awaitNanos(delay) 等待delay 时间，但是其他线程（follwer 线程）会调用available.await()进行无限等待。leader 线程延迟时间过期后，会退出take 方法，并通过调用available.signal()方法唤醒一个follwer 线程，被唤醒的follwer 线程被选举为新的leader 线程。</p><h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="offer操作-3"><a href="#offer操作-3" class="headerlink" title="offer操作"></a>offer操作</h4><p>插入非空元素到队列，由于是无界队列所以一直返回true 。插入元素要实现Delayed 接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) { <span class="comment">// 如果当前元素是最先过期则重置leader线程为null，并唤醒出队阻塞线程</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="take操作-3"><a href="#take操作-3" class="headerlink" title="take操作"></a>take操作</h4><p>获取并移除队列里面延迟时间过期的元素，如果队列里面没有过期元素则等待。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            E first = q.peek(); <span class="comment">// 获取但不移除队首元素</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await(); <span class="comment">// 如果队首元素为空则阻塞</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS); <span class="comment">// 元素剩余到期时间</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll(); <span class="comment">// 已经过期出队返回</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await(); <span class="comment">// leader不为空说明其他线程在执行take，当前线程阻塞等待</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread; <span class="comment">// 选择当前线程为leader线程</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// 执行等待delay时间（期间释放锁），超时重新竞争锁获取到期元素</span></span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="poll操作-3"><a href="#poll操作-3" class="headerlink" title="poll操作"></a>poll操作</h4><p>获取并移除队头过期元素。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) <span class="comment">// 队列为空或队首元素未过期直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="size操作-3"><a href="#size操作-3" class="headerlink" title="size操作"></a>size操作</h4><p>计算队列元素个数，包含过期的和没有过期的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ConcurrentLinkedQueue&quot;&gt;&lt;a href=&quot;#ConcurrentLinkedQueue&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentLinkedQueue&quot;&gt;&lt;/a&gt;ConcurrentLinkedQueue&lt;/h2&gt;&lt;p&gt;ConcurrentLinkedQueue 线程安全的&lt;strong&gt;无界非阻塞&lt;/strong&gt;队列，其底层数据结构使用单向链表实现，对于入队和出队操作使用 CAS 来实现线程安全。&lt;/p&gt;
&lt;h3 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ConcurrentLinkedQueue-uml.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentLinkedQueue 内部的队列使用单向链表的方式实现，其中有两个volatile 类型的Node 节点分别用来存放队列首、尾节点。&lt;/p&gt;
&lt;p&gt;Node 内部则维护一个使用volatile 修饰的item，用来存放节点的值；next 用来存放链表的下一个节点；其内部使用UNSafe 工具类提供的CAS 算法来保证入队时操作链表的原子性。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：Lock</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-11/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-11/</id>
    <published>2020-12-26T09:54:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是可重入的独占锁，同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的AQS 阻塞队列里。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>ReentrantLock 类图如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ReentrantLock-uml.png" alt="image"></p><span id="more"></span><p>从类图可以看到， ReentrantLock 最终还是使用AQS来实现的，并且根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中Sync 类直接继承自AQS ， 它的子类NonfairSync 和FairSync 分别实现了获取锁的非公平与公平策略。</p><p>在这里，AQS 的state 状态值表示线程获取该锁的可重入次数，在默认情况下，state 的值为0 表示当前锁没有被任何线程持有。当一个线程第一次获取该锁时会尝试使用CAS 设置state 的值为1 ，如果CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为2，这就是可重入次数。在该线程放该锁时，会尝试使用CAS 让状态值减1，如果减1 后状态值为0,则当前线程释放该锁。</p><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><h4 id="void-lock"><a href="#void-lock" class="headerlink" title="void lock()"></a>void lock()</h4><p>当一个线程调用该方法时，说明该线程希望获取该锁。如果锁当前没有被其他线程占用并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程， 并设置AQS 的状态值为1 ，然后直接返回。<br>如果当前线程之前己经获取过该锁，则这次只是简单地把AQS 的状态值加1 后返回。如果该锁己经被其他线程持有，则调用该方法的线程会被放入AQS 队列后阻塞挂起。</p><p>在如下代码中， ReentrantLock 的lock() 委托给了sync 类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.lock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>先来看NonfairSync的情况，即非公平锁</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// CAS 设置状态值</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 调用AQS acquire方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为默认AQS 的状态值为0，所以第一个调用Lock 的线程会通过CAS 设置状态值为1, CAS 成功则表示当前线程获取到了锁，然后setExclusiveOwnerThread 设置该锁持有者是当前线程。<br>如果这时候有其他线程调用lock 方法企图获取该锁，CAS 会失败，然后会调用AQS的acquire 方法，传递参数为1。</p><p>AQS 的acquire 核心代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用ReentrantLock重写的tryAcquire方法</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>非公平锁tryAcquire相关源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) { <span class="comment">// 当前AQS状态值为0</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 设置当前线程为锁持有者</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) { <span class="comment">// 当前线程是该锁持有者</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow 可重入次数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>再来看FairSync的情况，即公平锁</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) { <span class="comment">// 当前AQS状态值为0</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 公平性策略</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) { <span class="comment">// 当前线程是该锁持有者</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平性核心实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 如果h==t 则说明当前队列为空，直接返回false</span></span><br><span class="line">    <span class="comment">// 如果h!=t 并且s==null 则说明有一个元素将要作为AQS 的第一个节点入队列，返回true</span></span><br><span class="line">    <span class="comment">// 如果h!=t 并且s!=null和s.thread != Thread.cunentThread() 则说明队列里面的第一个元素不是当前线程，那么返回true</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-lockInterruptibly"><a href="#void-lockInterruptibly" class="headerlink" title="void lockInterruptibly()"></a>void lockInterruptibly()</h4><p>该方法与lock() 方法类似，不同在于它对中断进行响应，即当前线程在调用该方法时，如果其他线程调用了当前线程的interrupt() 方法， 则当前线程会抛出InterruptedException 异常，然后返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 如果当前线程被中断，则直接抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) <span class="comment">// 尝试获取资源</span></span><br><span class="line">        doAcquireInterruptibly(arg); <span class="comment">// 调用AQS可被中断方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-tryLock"><a href="#boolean-tryLock" class="headerlink" title="boolean tryLock()"></a>boolean tryLock()</h4><p>尝试获取锁，如果当前该锁没有被其他线程持有，则当前线程获取该锁并返回true,否则返回false。注意，该方法不会引起当前线程阻塞。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryLock() 使用的是非公平策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-tryLock-long-timeout-TimeUnit-unit"><a href="#boolean-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="boolean tryLock(long timeout, TimeUnit unit)"></a>boolean tryLock(long timeout, TimeUnit unit)</h4><p>尝试获取锁，与tryLock 的不同之处在于，它设置了超时时间，如果超时时间到没有获取到锁则返回false</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout)); <span class="comment">// 调用AQS tryAcquireNanos方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><h4 id="void-unlock"><a href="#void-unlock" class="headerlink" title="void unlock()"></a>void unlock()</h4><p>尝试释放锁，如果当前线程持有该锁， 则调用该方法会让该线程对该线程持有的AQS状态值减1 ， 如果减去1 后当前状态值为0 ，则当前线程会释放该锁，否则仅仅减1 而己。如果当前线程没有持有该锁而调用了该方法则会抛出IllegalMonitorStateException 异常。</p><p>代码如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 如果不是锁持有者调用unlock抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) { <span class="comment">// 如果当前可重入次数为0则清空锁持有线程</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    setState(c); <span class="comment">// 设置可重入次数为原始值-1</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 采用读写分离的策略，允许多个线程可以同时获取读锁。</p><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p>ReentrantReadWriteLock 类图如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ReentrantReadWriteLock-uml.png" alt="image"></p><p>读写锁的内部维护了一个ReadLock 和一个WriteLock ，它们依赖Sync 实现具体功能。而Sync 继承自AQS ，并且也提供了公平和非公平的实现。</p><ul><li>state 高16位表示读状态，也就是获取到读锁的次数；低16位表示获取到写锁的线程的可重入次数。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 共享锁（读锁）状态单位值65536</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">// 共享锁线程最大个数65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 排它锁（写锁）掩码， 二进制，15 个1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回读锁线程数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>{ <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; }</span><br><span class="line"><span class="comment">/** 返回写锁可重入个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>{ <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; }</span><br></pre></td></tr></tbody></table></figure><ul><li>firstReader 用来记录第一个获取到读锁的线程</li><li>firstReaderHoldCount 则记录第一个获取到读锁的线程获取读锁的可重入次数</li><li>cachedHoldCounter 用来记录最后一个获取读锁的线程获取读锁的可重入次数</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 线程id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>readHolds 是ThreadLocal 变量，用来存放除去第一个获取读锁线程外的其他线程获取读锁的可重入次数</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h3><p>ReentrantReadWriteLock 中写锁使用WriteLock 实现。</p><h4 id="void-lock-1"><a href="#void-lock-1" class="headerlink" title="void lock()"></a>void lock()</h4><p>写锁是个独占锁，某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁，则当前线程可以获取到写锁然后返回。如果当前己经有线程获取到读锁和写锁，则当前请求写锁的线程会被阻塞挂起。另外，写锁是可重入锁，如果当前线程己经获取了该锁，再次获取只是简单地把可重入次数加1 后直接返回。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用sync重写的tryAcquire方法</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) { <span class="comment">// c != 0 说明读锁或写锁已经被某个线程获取</span></span><br><span class="line">        <span class="comment">// w == 0 说明已经有线程获取了读锁；w != 0 并且当前线程不是写锁拥有者，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT) <span class="comment">// 当前线程获取了写锁，判断可重入次数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        </span><br><span class="line">        setState(c + acquires); <span class="comment">// 设置可重入次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c == 0; 第一个写线程获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于writeShoudBlock 方法，非公平实现为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时，线程抢占式执行CAS 尝试获取写锁，抢占成功后设置锁持有者为当前线程</p><p>公平锁实现为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>{</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>公平锁判断当前线程节点是否有前驱节点，如果有则当前线程放弃获取写锁的权限</p><h4 id="void-lockInterruptibly-1"><a href="#void-lockInterruptibly-1" class="headerlink" title="void lockInterruptibly()"></a>void lockInterruptibly()</h4><p>此方法对中断进行响应，也就是当其他线程调用了该线程的interrupt 方法中断了当前线程时，当前线程会抛出异常InterruptedException异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-tryLock-1"><a href="#boolean-tryLock-1" class="headerlink" title="boolean tryLock()"></a>boolean tryLock()</h4><p>尝试获取写锁，如果当前没有其他线程持有写锁或者读锁，则当前线程获取写锁会成功，然后返回true。如果当前己经有其他线程持有写锁或者读锁则该方法直接返回false,且当前线程并不会被阻塞。如果当前线程已经持有了该写锁则简单增加AQS 的状态值后直接返回true。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="boolean-tryLock-long-timeout-TimeUnit-unit-1"><a href="#boolean-tryLock-long-timeout-TimeUnit-unit-1" class="headerlink" title="boolean tryLock(long timeout, TimeUnit unit)"></a>boolean tryLock(long timeout, TimeUnit unit)</h4><p>相比tryAcquire 多了超时参数，尝试获取写锁失败后挂起指定时间后，线程会被激活，如果还是没有获取到写锁则直接返回false，此方法响应中断。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-unlock-1"><a href="#void-unlock-1" class="headerlink" title="void unlock()"></a>void unlock()</h4><p>尝试释放锁，如果当前线程持有该锁，调用该方法会让该线程对该线程持有的AQS<br>状态值减1 ，如果减去1 后当前状态值为0 则当前线程会释放该锁， 否则仅仅减1 而己。如果当前线程没有持有该锁而调用了该方法则会抛出IllegalMonitorStateException 异常</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) { <span class="comment">// 调用ReentrantReadWriteLock中sync实现的tryRelease方法</span></span><br><span class="line">        <span class="comment">// 激活阻塞队列中的一个线程</span></span><br><span class="line">        Node h = head; </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 看是否是写锁拥有者调用unlock</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// 获取可重入值，这里没有考虑高16位，因为获取写锁时读锁状态值一定是0</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free) <span class="comment">// 如果写锁可重入值为0则释放锁，否则只是简单更新状态值</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h3><p>ReentrantReadWriteLock 中的读锁是使用ReadLock 来实现的。</p><h4 id="void-lock-2"><a href="#void-lock-2" class="headerlink" title="void lock()"></a>void lock()</h4><p>获取读锁，如果当前没有其他线程持有写锁，则当前线程可以获取读锁，AQS 的状态值state 的高16 位的值会增加1 ，然后方法返回。否则如果其他一个线程持有写锁，则当前线程会被阻塞。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 调用ReentrantReadWriteLock中sync的tryAquireShared方法</span></span><br><span class="line">        doAcquireShared(arg); <span class="comment">// 调用AQS的doAcquireShared方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; <span class="comment">// 判断是否被写锁占用</span></span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁计数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 尝试获取锁，多个线程只有一个会成功，不成功的进入fullTryAcquireShire进行重试</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) {</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) { <span class="comment">// 第一个线程获取读锁</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) { <span class="comment">// 如果当前线程是第一个获取读锁的线程</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            HoldCounter rh = cachedHoldCounter; <span class="comment">// 记录第一个获取读锁的线程或记录其他线程读锁的可重入数</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current); <span class="comment">// 类似tryAcquireShared，但是是自旋获取</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>{</span><br><span class="line"> </span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock.</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) {</span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) {</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) {</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) {</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) {</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) {</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) {</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-lockInterruptibly-2"><a href="#void-lockInterruptibly-2" class="headerlink" title="void lockInterruptibly()"></a>void lockInterruptibly()</h4><p>类似于lock()，此方法响应中断</p><h4 id="boolean-tryLock-2"><a href="#boolean-tryLock-2" class="headerlink" title="boolean tryLock()"></a>boolean tryLock()</h4><p>尝试获取读锁，如果当前没有其他线程持有写锁，则当前线程获取读锁会成功，然后返回true 。如果当前己经有其他线程持有写锁则该方法直接返回false ，但当前线程并不会被阻塞。如果当前线程己经持有了该读锁则简单增加AQS 的状态值高16 位后直接返回true 。</p><h4 id="boolean-tryLock-long-timeout-TimeUNit-unit"><a href="#boolean-tryLock-long-timeout-TimeUNit-unit" class="headerlink" title="boolean tryLock(long timeout, TimeUNit unit)"></a>boolean tryLock(long timeout, TimeUNit unit)</h4><p>相比tryLock，增加了超时参数，获取读锁失败则会把当前线程挂起指定时间，待超时时间到后当前线程被激活，如果此时还没有获取到读锁则返回false 。此方法响应中断。</p><h4 id="void-unlock-2"><a href="#void-unlock-2" class="headerlink" title="void unlock()"></a>void unlock()</h4><p>尝试释放读锁（或减少重入次数），释放读锁后释放写锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) { <span class="comment">// 调用ReentrantReadWriteLock中sync的tryReleaseShared方法</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 释放一个由于获取写锁而被阻塞的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>{</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环直到自己的读计数-1，CAS更新成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>StampedLock 是并发包里面JDK8 版本新增的一个锁，该锁提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个long 型的变量，称为戳记(stamp),这个戳记代表了锁的状态。其中try 系列获取锁的函数，当获取锁失败后会返回为0 的stamp 值。当调用释放锁和转换锁的方法时需要传入获取锁时返回的stamp 值。</p><p>StampedLock 内部组成如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/StampedLock.png" alt="image"></p><p>StampedLock 提供的三种读写模式的锁分别如下：</p><ul><li>写锁 writeLock: 是一个排它锁或者独占锁</li><li>悲观读锁 readLock: 是一个共享锁，在没有线程获取独占写锁的情况下，多个线程可以同时获取该锁。</li><li>乐观读锁 tryOptimisticRead: 它是相对于悲观锁来说的，在操作数据前并没有通过CAS 设置锁的状态，仅仅通过位运算测试。如果当前没有线程持有写锁，则简单地返回一个非0 的stamp 版本信息。使用前还需要调用validate 方法验证stamp 是否可用。此锁适合读多写少场景。</li></ul><p>StampedLock 还支持这三种锁在一定条件下进行相互转换。</p><p>另外， StampedLock 的读写锁都是不可重入锁。当多个线程同时尝试获取读锁和写锁时，谁先获取锁没有一定的规则，完全都是尽力而为，是随机的。并且该锁不是直接实现Lock 或ReadWriteLock 接口，而是其在内部自己维护了一个双向阻塞队列。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h2 id=&quot;ReentrantLock&quot;&gt;&lt;a href=&quot;#ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock&quot;&gt;&lt;/a&gt;ReentrantLock&lt;/h2&gt;&lt;p&gt;ReentrantLock 是可重入的独占锁，同时只能有一个线程可以获取该锁，其他获取该锁的线程会被阻塞而被放入该锁的AQS 阻塞队列里。&lt;/p&gt;
&lt;h3 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h3&gt;&lt;p&gt;ReentrantLock 类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/ReentrantLock-uml.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：AQS</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-10/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-10/</id>
    <published>2020-12-26T09:52:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁的底层支持"><a href="#锁的底层支持" class="headerlink" title="锁的底层支持"></a>锁的底层支持</h2><p>AbstractQueuedSynchronizer 抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。</p><p>AQS 类图结构如图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/AQS-uml.png" alt="image"></p><span id="more"></span><p>由该图可以看到， AQS 是一个FIFO 的双向队列，其内部通过节点head 和tail 记录队首和队尾元素，队列元素的类型为Node 。其中Node 中的thread 变量用来存放进入AQS 队列里面的线程： Node 节点内部的SHARED 用来标记该线程是获取共享资源时被阻塞挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是获取独占资源时被挂起后放入AQS 队列的； waitStatus 记录当前线程等待状态，可以为CANCELLED（线程被取消了）、SIGNAL（ 线程需要被唤醒）、CONDITION （线程在条件队列里面等待）、PROPAGATE（释放共享资源时需要通知其他节点）；prev 记录当前节点的前驱节点， next 记录当前节点的后继节点。</p><p>在AQS 中维持了一个单一的状态信息state，可以通过getState 、setState 、compareAndSetState 函数修改其值。对于ReentrantLock 的实现来说，state 可以用来表示当前线程获取锁的可重入次数；对于读写锁ReentrantReadWriteLock 来说，state 的高16 位表示读状态，也就是获取该读锁的次数，低16 位表示获取到写锁的线程的可重入次数；对于semaphore 来说， state 用来表示当前可用信号的个数：对于CountDownlatch 来说，state 用来表示计数器当前的值。</p><p>AQS 内部类ConditionObject 用来结合锁实现线程同步。ConditionObject 是条件变量，每个条件变量对应一个条件队列（单向链表队列）用来存放调用条件的await 方法后被阻塞的线程。队列头、尾元素分别是firstWaiter 和lastWaiter。</p><p>对于AQS 来说，线程同步的关键是对状态值state 进行操作。根据state 是否属于一个线程，操作state 的方式分为独占方式和共享方式。</p><ul><li><strong>在独占方式下获取和释放资源使用的方法是：</strong></li></ul><table><thead><tr><th>独占方法</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进人同步队列等待</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回</td></tr><tr><td>boolean release(int)</td><td>独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td></tr></tbody></table><ul><li><strong>在共享方式下获取和释放资源使用的方法是：</strong></li></ul><table><thead><tr><th>共享方法</th><th>描述</th></tr></thead><tbody><tr><td>void acquireShared(int arg)</td><td>共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>与acquireShared(int )相同，该方法响应中断</td></tr><tr><td>void acquireShared(int)</td><td>共享式的释放同步状态</td></tr></tbody></table><p><strong>在独占方式下，获取与释放资源的流程如下：</strong></p><ol><li>当一个线程调用acquire(int arg)方法获取独占资源时，会首先使用tryAcquire 方法尝试获取资源，具体是设置状态变量state 的值，成功则直接返回，失败则将当前线程封装为类型为Node.EXCLUSIVE 的Node 节点后插入到AQS 阻塞队列的尾部，并调用LockSupport.park(this) 方法挂起自己。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>当一个线程调用release(int arg) 方法时会尝试使用tryRelease 操作释放资源，这里是设置状态变量state 的值，然后调用LockSupport.unpark(thread) 方法激活AQS 队列里面被阻塞的一个线程（thread）。被激活的线程则使用tryAcquire 尝试，看当前状态变量state 的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行，否则还是会被放入AQS 队列并被挂起。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>在共享方式下，获取与释放资源的流程如下：</strong></p><ol><li>当线程调用acquireShared(int arg) 获取共享资源时，会首先使用trγAcquireShared 尝试获取资源，具体是设置状态变量state 的值，成功则直接返回，失败则将当前线程封装为类型为Node.SHARED 的Node 节点后插入到AQS 阻塞队列的尾部，并使用LockSupport.park(this) 方法挂起自己。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>当一个线程调用releaseShared(int arg) 时会尝试使用tryReleaseShared 操作释放资源，这里是设置状态变量state 的值，然后使用LockSupport.unpark(thread) 激活AQS 队列里面被阻塞的一个线程（thread）。被激活的线程则使用tryReleaseShared 查看当前状态变量state 的值是否能满足自己的需要，满足则该线程被撤活，然后继续向下运行，否则还是会被放入AQS 队列并被挂起。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>最后，来看看如何维护AQS 提供的队列，主要看入队操作:</strong></p><p>当一个线程获取锁失败后该线程会被转换为Node 节点，然后就会使用enq(final Node node) 方法将该节点插入到AQS 的阻塞队列。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上代码，当要在AQS 队列尾部插入元素时， AQS 队列头、尾节点都指向null 时，使用CAS 算法设置一个哨兵节点为头节点，如果CAS 设置成功，则让尾部节点也指向哨兵节点，这时候队列状态如下图中（2）所示；<br>然后再插入node 节点，设置node 的前驱节点为尾部节点（4），然后通过CAS 算法设置node 节点为尾部节点（5），CAS 成功后再设置原来的尾部节点的后驱节点为node（6）。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/AQS-Queue.png" alt="image"></p><h2 id="条件变量的支持"><a href="#条件变量的支持" class="headerlink" title="条件变量的支持"></a>条件变量的支持</h2><p>类比配合synchronized 内置锁实现线程间同步的 notify 和wait ，条件变量的signal 和await 方法也是用来配合锁（使用AQS 实现的锁）实现线程间同步的基础设施。</p><p>它们的不同在于，synchronized 同时只能与一个共享变量的notify 或wait 方法实现同步， 而AQS 的一个锁可以对应多个条件变量。</p><p>使用方法示例如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"begin wait"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"end wait"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"begin signal"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(<span class="string">"end signal"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin wait</span><br><span class="line">begin signal</span><br><span class="line">end signal</span><br><span class="line">end wait</span><br></pre></td></tr></tbody></table></figure><p>在上面代码中， lock.newCondition() 的作用其实是new 了一个在AQS 内部声明的ConditionObject 对象， ConditionObject 是AQS 的内部类，可以访问AQS 内部的变量（例如状态变量state）和方法。在每个条件变量内部都维护了一个条件队列，用来存放调用条件变量的await() 方法时被阻塞的线程。注意这个条件队列和AQS 队列不是一回事。</p><p>ConditionObject 相关源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可中断条件等待</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 调用前必须先调用lock.lock()获取锁</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter(); <span class="comment">// 创建新的node节点，并插入到条件队列末尾</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">// 释放当前线程获取的锁</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) { <span class="comment">// 调用park方法阻塞挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将等待时间最长的线程(如果存在的话)从这个条件的等待队列移动到拥有锁的等待队列</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 调用前必须先调用lock.lock()获取锁</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first); <span class="comment">// 将条件队列列头元素移动到AQS队列</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>{</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">    </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION); <span class="comment">// 根据当前线程创建一个类型为Node.CONDITION 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node; <span class="comment">// 将新构建好的节点添加到单向条件队列末尾</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>当多个线程同时调用lock.lock() 法获取锁时，只有一个线程获取到了锁，其他线程会被转换为Node 节点插入到lock 锁对应的AQS 阻塞队列里面，并做自旋CAS 尝试获取锁。</p></li><li><p>如果获取到锁的线程又调用了对应的条件变量的await() 方法，则该线程会释放获取到的锁，并被转换为Node 节点插入到条件变量对应的条件队列里面。这时候因为调用lock.lock() 方法被阻塞到AQS 队列里面的一个线程会获取到被释放的锁，如果该线程也调用了条件变量的await() 方法则该线程也会被放入条件变量的条件队列里面。</p></li><li><p>当另外一个线程调用条件变量的signal() 或者signalAll() 方法时，会把条件队列里面的一个或者全部Node 节点移动到AQS 的阻塞队列里面，等待时机获取锁。</p></li></ul><p><strong>一个锁对应一个AQS 阻塞队列，对应多个条件变量， 每个条件变量有自己的一个条件队列。</strong></p><p>如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/AQS-Condition.png" alt="image"></p><h2 id="基于AQS实现自定义同步器"><a href="#基于AQS实现自定义同步器" class="headerlink" title="基于AQS实现自定义同步器"></a>基于AQS实现自定义同步器</h2><p>在如下代码中， NonReentrantLock为自定基于AQS的不可重入独占锁，其内部定义了一个Sync 用来实现具体的锁的操作， Sync 继承于AQS 。由于我们实现的是独占模式的锁，所以Sync重写了tryAcquire、tryRelease 和isHeldExclusively 3 个方法。另外， Sync 提供了newCondition 这个方法用来支持条件变量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于AQS的不可重入独占锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部帮助类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 锁是否已经被持有</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果state为0则尝试获取锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试释放锁，设置state为0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            }</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 提供条件变量接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Sync来做具体的工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;锁的底层支持&quot;&gt;&lt;a href=&quot;#锁的底层支持&quot; class=&quot;headerlink&quot; title=&quot;锁的底层支持&quot;&gt;&lt;/a&gt;锁的底层支持&lt;/h2&gt;&lt;p&gt;AbstractQueuedSynchronizer 抽象同步队列简称AQS，它是实现同步器的基础组件，并发包中锁的底层就是使用AQS 实现的。&lt;/p&gt;
&lt;p&gt;AQS 类图结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/AQS-uml.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：LockSupport</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-9/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-9/</id>
    <published>2020-12-26T09:50:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LockSupport 工具类的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。LockSupport 类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport 类的方法的线程是不持有许可证的。LockSupport 是使用Unsafe 类实现的。</p><span id="more"></span><h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="static-void-park"><a href="#static-void-park" class="headerlink" title="static void park()"></a>static void park()</h3><p>如果调用park 方法的线程已经拿到了与LockSupport 关联的许可证，则调用LockSupport.park() 时会马上返回，否则调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。</p><p>在如下代码中，在main 函数中直接调用park 方法，最终只会输出begin park!，然后当前线程被挂起，这是因为默认情况下调用线程是不持有许可证的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"begin park!"</span>);</span><br><span class="line"></span><br><span class="line">      LockSupport.park();</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"end park!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在其他线程调用unpark(Thread thread) 方法并且将当前线程作为参数时，调用park 方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的interrupt()方法，设置了中断标志或者线程被虚假唤醒，则阻塞线程也会返回。所以在调用park 方法时最好也使用循环条件判断方式。需要注意的是，因调用park() 方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException 异常。</p><h3 id="static-void-unpark-Thread-thread"><a href="#static-void-unpark-Thread-thread" class="headerlink" title="static void unpark(Thread thread)"></a>static void unpark(Thread thread)</h3><p>当一个线程调用unpark 时，如果参数thread 线程没有持有thread 与LockSupport 类关联的许可证， 则让thread 线程持有。如果thread 之前因调用park() 而被挂起，则调用unpark 后，该线程会被唤醒。如果thread 之前没有调用park ，则调用unpark 方法后， 再调用park 方法，其会立刻返回。</p><p>修改代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"begin park!"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使当前线程获得许可证</span></span><br><span class="line">      LockSupport.unpark(Thread.currentThread());</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 再次调用park方法</span></span><br><span class="line">      LockSupport.park();</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">"end park!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin park!</span><br><span class="line">end park!</span><br></pre></td></tr></tbody></table></figure><h3 id="static-void-parkNanos-long-nanos"><a href="#static-void-parkNanos-long-nanos" class="headerlink" title="static void parkNanos(long nanos)"></a>static void parkNanos(long nanos)</h3><p>如果调用park 方法的线程已经拿到了与LockSupport 关联的许可证，则调用LockSupport.parkNanos(long nanos) 方法后会马上返回。该方法的不同在于，如果没有拿到许可证，则调用线程会被挂起nanos 时间后修改为自动返回。</p><p>另外park 方法还支持带有blocker 参数的方法void park(Object blocker) 方法，当线程在没有持有许可证的情况下调用park 方法而被阻塞挂起时，这个blocker 对象会被记录到该线程内部。</p><p>使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用getBlocker(T hread) 方法来获取blocker 对象的，所以JDK 推荐我们使用带有blocker 参数的park 方法，并且blocker 被设置为this ，这样当在打印线程堆横排查问题时就能知道是哪个类被阻塞了。</p><p>例如下面的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkTest</span> </span>{</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parkTest</span><span class="params">()</span> </span>{</span><br><span class="line">            LockSupport.park(); <span class="comment">// 1</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">            ParkTest test = <span class="keyword">new</span> ParkTest();</span><br><span class="line">            test.parkTest();</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码后，使用jstack <pid> 命令查看线程堆栈可以看下如下结果：</pid></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x0000000003652800</span> nid=<span class="number">0x345c</span> waiting on condition [<span class="number">0x000000000341f000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">304</span>)</span><br><span class="line">        at ParkTest.parkTest(ParkTest.java:<span class="number">6</span>)</span><br><span class="line">        at ParkTest.main(ParkTest.java:<span class="number">11</span>)</span><br></pre></td></tr></tbody></table></figure><p>修改代码1 为LockSupport.park(this);后，再次输出线程堆栈结果如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x0000000002a12800</span> nid=<span class="number">0x2a28</span> waiting on condition [<span class="number">0x000000000247f000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000000d5bf4418</span>&gt; (a ParkTest)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">        at ParkTest.parkTest(ParkTest.java:<span class="number">6</span>)</span><br><span class="line">        at ParkTest.main(ParkTest.java:<span class="number">11</span>)</span><br></pre></td></tr></tbody></table></figure><p>使用带blocker 参数的park 方法，线程堆栈可以提供更多有关阻塞对象的信息。</p><h3 id="static-void-park-Object-blocker"><a href="#static-void-park-Object-blocker" class="headerlink" title="static void park(Object blocker)"></a>static void park(Object blocker)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取调用线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 设置此线程blocker变量</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 挂起线程</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 线程被激活后清除blocker变量，因为一般都是在线程阻塞时才分析原因</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Thread 类里面有个变量volatile Object parkBlocker ， 用来存放park 方法传递的blocker 对象，也就是把blocker 变量存放到了调用park 方法的线程的成员变量里面。</p><h3 id="static-void-parkNanos-Object-blocker-long-nanos"><a href="#static-void-parkNanos-Object-blocker-long-nanos" class="headerlink" title="static void parkNanos(Object blocker, long nanos)"></a>static void parkNanos(Object blocker, long nanos)</h3><p>相比park(Object blocker) 方法多了超时时间。</p><h3 id="static-void-parkUntil-Object-blocker-long-deadline"><a href="#static-void-parkUntil-Object-blocker-long-deadline" class="headerlink" title="static void parkUntil(Object blocker, long deadline)"></a>static void parkUntil(Object blocker, long deadline)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isAbsolute=true,time=deadline;表示到deadline 时间后返回</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中参数deadline 的时间单位为ms ，该时间是从1970 年到现在某一个时间点的毫秒值。这个方法和parkNanos(Object blocker, long nanos) 方法的区别是，后者是从当前算等待nanos 秒时间，而前者是指定一个时间点，比如需要等到2017.12.11 12:00:00 ，则把这个时间点转换为从1970 年到这个时间点的总毫秒数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;LockSupport 工具类的主要作用是挂起和唤醒线程，该工具类是创建锁和其他同步类的基础。LockSupport 类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport 类的方法的线程是不持有许可证的。LockSupport 是使用Unsafe 类实现的。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：CopyOnWriteArrayList</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-8/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-8/</id>
    <published>2020-12-26T09:48:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并发包中的并发List 只有CopyOnWriteArrayList 。CopyOnWriteArrayList 是一个线程安全的ArrayList ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了写时复制策略。</p><p>CopyOnWriteArrayList 类图结构如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/CopyOnWriteArrayList-uml.png" alt="image"></p><p>在CopyOnWriteArrayList 的类图中，每个CopyOnWriteArrayList 对象里面有一个array 数组对象用来存放具体元素， ReentrantLock 独占锁对象用来保证同时只有一个线程对array 进行修改。</p><span id="more"></span><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造函数，内部创建了一个大小为0 的Object 数组作为array 初始值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>{</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建一个list，内部元素为入参的副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>{</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入参为集合，将集合里的元素复制到array</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    }</span><br><span class="line">    setArray(elements);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>CopyOnWriteArrayList 中用来添加元素的函数有add(E e）、add(int index, E element）、addIfAbsent(E e)、addAllAbsent(Collection&lt;? extends E&gt; c)等，他们原理类似，以add(E e)为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取array</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制array到新数组，添加元素到新数组（CopyOnWriteArrayList是无界list）</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用新数组替换添加前的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取指定位置元素"><a href="#获取指定位置元素" class="headerlink" title="获取指定位置元素"></a>获取指定位置元素</h3><p>使用E get(int index)获取下标为index 的元素，如果元素不存在则抛出IndexOutOfBoundsException 异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤1，获取array数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 步骤2，通过下标获取指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于执行步骤1 和步骤2 没有加锁，这就可能导致在线程x 执行完步骤1 后执行步骤2 前， 另外一个线程y 进行了remove 操作，导致线程x 返回已被删除的元素，这就是写时复制策略产生的弱一致性问题。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>使用 E set(int index, E element)修改list 中指定位置元素的值，如果指定位置元素不存在抛出IndexOutOfBoundsException异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取独占锁，阻止其他线程对array数组修改</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取当前array数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取指定位置元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定位置元素与新值不一致则创建新数组并添加元素，重新设置到array</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) {</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 如果指定位置元素与新值一样，为保证volatile语义，还是需要重新设置array</span></span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除list 里面指定的元素，可以使用E remove(int index)、boolean remove(Object o）和 boolean remove(Object o, Object[] snapshot, int index)等方法，它们的原理一样。以remove(int ind ex）为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取指定元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果要删除的是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 复制其他元素到新数组并替代老数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 分两次复制删除后剩余的元素到新数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">                             </span><br><span class="line">            <span class="comment">// 使用新数组代替老数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="弱一致性迭代器"><a href="#弱一致性迭代器" class="headerlink" title="弱一致性迭代器"></a>弱一致性迭代器</h3><p>所谓弱一致性是指返回迭代器后，其他线程对list 的增删改对迭代器是不可见的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// array的快照版本，虽然传递的是引用，但CopyOnWriteArrayList增删改操作会替换原array</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>{</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否遍历结束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CopyOnWriteArrayList 使用写时复制的策略来保证list 的一致性，而获取 - 修改 - 写入三步操作并不是原子性的，所以在增删改的过程中都使用了独占锁，来保证在某个时间只有一个线程能对list 数组进行修改。另外CopyOnWriteArrayList 提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list 的修改是不可见的，迭代器遍历的数组是一个快照。另外，CopyOnWriteArraySet 的底层就是使用它实现的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;并发包中的并发List 只有CopyOnWriteArrayList 。CopyOnWriteArrayList 是一个线程安全的ArrayList ，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的，也就是使用了写时复制策略。&lt;/p&gt;
&lt;p&gt;CopyOnWriteArrayList 类图结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/CopyOnWriteArrayList-uml.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在CopyOnWriteArrayList 的类图中，每个CopyOnWriteArrayList 对象里面有一个array 数组对象用来存放具体元素， ReentrantLock 独占锁对象用来保证同时只有一个线程对array 进行修改。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：ThreadLocalRandom</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-4/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-4/</id>
    <published>2020-12-26T09:47:30.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Random-类及其局限性"><a href="#Random-类及其局限性" class="headerlink" title="Random 类及其局限性"></a>Random 类及其局限性</h2><p>java.util.Random 是使用较为广泛的随机数生成工具类，使用方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个默认种子的随机数生成器</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random() ;</span><br><span class="line">        <span class="comment">// 输出10个在0~5（包含0，不包含5）之间的随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p>Random 部分源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Random</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong seed; <span class="comment">// 种子原子变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>) <span class="comment">// 参数检查</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = next(<span class="number">31</span>); <span class="comment">// 根据老的种子生成新的种子</span></span><br><span class="line">        </span><br><span class="line">        ··· <span class="comment">// 根据新的种子计算随机数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">        AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            oldseed = seed.get(); <span class="comment">// 获取当前原子变量种子值</span></span><br><span class="line">            nextseed = (oldseed * multiplier + addend) &amp; mask; <span class="comment">// 根据当前种子值计算新的种子</span></span><br><span class="line">        } <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed)); <span class="comment">// CAS 更新老的种子，失败循环更新</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits)); <span class="comment">// 使用固定算法根据新的种子计算随机数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过阅读源码不难发现，每个Random 实例里都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这会降低并发性能，所以ThreadLocalRandom 应运而生。</p><h2 id="ThreadlocalRandom"><a href="#ThreadlocalRandom" class="headerlink" title="ThreadlocalRandom"></a>ThreadlocalRandom</h2><p>为了弥补多线程高并发情况下Random 的缺陷， 在JUC 包下新增了ThreadLocalRandom类，使用方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个随机数生成器</span></span><br><span class="line">    ThreadLocalRandom random2 = ThreadLocalRandom.current();</span><br><span class="line">    <span class="comment">// 输出10个在0~5（包含0，不包含5）之间的随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">          System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Unsafe-机制"><a href="#Unsafe-机制" class="headerlink" title="Unsafe 机制"></a>Unsafe 机制</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe(); <span class="comment">// 获取unsafe实例</span></span><br><span class="line">        Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">        SEED = UNSAFE.objectFieldOffset <span class="comment">// 获取Thread类里面threadLocalSeed变量在Thread实例里面的偏移量</span></span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">        PROBE = UNSAFE.objectFieldOffset <span class="comment">// 获取Thread类里面threadLocalRandomProbe变量在Thread实例里面的偏移量</span></span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        SECONDARY = UNSAFE.objectFieldOffset <span class="comment">// 获取Thread类里面threadLocalRandomSecondarySeed变量在Thread实例里面的偏移量</span></span><br><span class="line">            (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ThreadLocalRandom-current-方法"><a href="#ThreadLocalRandom-current-方法" class="headerlink" title="ThreadLocalRandom current() 方法"></a>ThreadLocalRandom current() 方法</h4><p>此方法获取ThreadLocalRandom 实例，并初始化调用线程中的threadLocalRandomSeed 和threadLocalRandomProbe 变量</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>) <span class="comment">// 当前线程threadLocalRandomProbe变量是否为0，判断是否第一次调用</span></span><br><span class="line">        localInit(); </span><br><span class="line">    <span class="keyword">return</span> instance; <span class="comment">// 返回ThreadLocalRandom 实例</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据probeGenerator计算当前线程中的threadLocalRandomProbe初始值，</span></span><br><span class="line"><span class="comment">// 然后根据seeder计算当前线程初始种子，并设置到当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>{ </span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="int-nextInt-int-bound-方法"><a href="#int-nextInt-int-bound-方法" class="headerlink" title="int nextInt(int bound) 方法"></a>int nextInt(int bound) 方法</h4><p>计算当前线程下一个随机数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>) <span class="comment">// 校验参数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">    <span class="keyword">int</span> r = mix32(nextSeed()); <span class="comment">// 根据当前线程中的种子计算新种子</span></span><br><span class="line">    </span><br><span class="line">    ··· <span class="comment">// 根据新种子和bound计算随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先使用r = UNSAFE.getLong(t, SEED) 获取当前线程中threadLocalRandomSeed 变量的值， </span></span><br><span class="line"><span class="comment">// 然后在种子的基础上累加GAMMA 值作为新种子，</span></span><br><span class="line"><span class="comment">// 而后使用UNSAFE.putLong 方法把新种子放入当前线程的threadLocalRandomSeed 变量中。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocalRandom 使用ThreadLocal 的原理，让每个线程都持有一个本地的种子变量，该种子变量只有在使用随机数时才会被初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新，从而避免了竞争。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Random-类及其局限性&quot;&gt;&lt;a href=&quot;#Random-类及其局限性&quot; class=&quot;headerlink&quot; title=&quot;Random 类及其局限性&quot;&gt;&lt;/a&gt;Random 类及其局限性&lt;/h2&gt;&lt;p&gt;java.util.Random 是使用较为广泛的随机数生成工具类，使用方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RandomTest&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建一个默认种子的随机数生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random() ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 输出10个在0~5（包含0，不包含5）之间的随机数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(random.nextInt(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】【J.U.C】：Atomic</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-7/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-7/</id>
    <published>2020-12-26T09:47:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JUC 包提供了Atomiclnteger 、AtomicLong 和AtomicBoolean等原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。原子性操作类的原理大致相同，本文只对AtomicLong 类的实现原理以及JDK 8 中新增的LongAdder 和 LongAccumulator 类的原理讲解。</p><span id="more"></span><h2 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>AtomicLong 是原子性递增或者递减类，其内部使用Unsafe 来实现，相关源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1927816293512124184L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 存放变量value的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="comment">// 判断JVM是否支持Long类型无锁CAS</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> VM_SUPPORTS_LONG_CAS = VMSupportsCS8();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取value在AtomicLong中的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) { <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际变量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>{</span><br><span class="line">        value = initialValue;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="递增和递减操作"><a href="#递增和递减操作" class="headerlink" title="递增和递减操作"></a>递增和递减操作</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用unsafe方法，原子性设置value值为原始值 + 1， 返回值为原始值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用unsafe方法，原子性设置value值为原始值 - 1，返回值为原始值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用unsafe 方法， 原子性设置value值为原始值 + l，返回值为递增后的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用unsafe方法，原子性设置value值为原始值 - 1，返回值为递减之后的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>) - <span class="number">1L</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在如上代码内部都是通过调用Unsafe 的getAndAddLong 方法来实现操作，这个函数是个原子性操作，这里第一个参数是AtomicLong 实例的引用， 第二个参数是value 变量在AtomicLong 中的偏移值，第三个参数是要设置的第二个变量的值。</p><p>其中，getAndIncrement 方法在JDK 7 中的实现逻辑为:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="keyword">long</span> current= get();</span><br><span class="line">        <span class="keyword">long</span> next = current + l ;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> current ;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，每个线程先拿到变量的当前值（由于value 是volatile 变量，所以这里拿到的是最新的值），然后在工作内存中对其进行增1 操作，而后使用CAS修改变量的值。如果设置失败，则循环继续尝试，直到设置成功。</p><p>而在JDK 8中的实现逻辑为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中JDK 8 中unsafe.getAndAddLong 的代码为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> var6;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">    } <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>JDK 7 AtomicLong 中的循环逻辑已经被JDK 8 中的原子操作类UNsafe 内置了，之所以内置应该是考虑到这个函数在其他地方也会用到，而内置可以提高复用性。</p><h4 id="boolean-compareAndSet-long-expect-long-update"><a href="#boolean-compareAndSet-long-expect-long-update" class="headerlink" title="boolean compareAndSet(long expect, long update)"></a>boolean compareAndSet(long expect, long update)</h4><p>如果原子变量中的value 值等于expect，则使用update 值更新该值并返回true，否则返回false。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>使用AtomicLong 时，在高并发下大量线程会同时去竞争更新同一个原子变量，但是由于同时只有一个线程的CAS 操作会成功，这就造成了大量线程竞争失败后，会通过无限循环不断进行自旋尝试CAS 的操作， 而这会白白浪费CPU 资源。为此JDK 8 新增了一个原子性递增或者递减类LongAdder 用来克服在高并发下使用AtomicLong 的缺点。</p><p>如下图所示，LongAdder 在内部维护多个Cell 变量，每个Cell 里面有一个初始值为0 的long 型变量，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少，减少了争夺共享资源的并发量。另外，多个线程在争夺同一个Cell 原子变量时如果失败了， 它并不是在当前Cell 变量上一直自旋CAS 重试，而是尝试在其他Cell 的变量上进行CAS 尝试，这个改变增加了当前线程重试CAS 成功的可能性。在获取LongAdder 当前值时， 是把所有Cell 变量的value 值累加后再加上base 返回的。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/LongAddr.png" alt="image"></p><p>LongAdder 维护了一个延迟初始化的原子性更新数组（默认情况下Cell 数组是null）和一个基值变量base。由于Cells 占用的内存是相对比较大的，所以一开始并不创建它，而是在需要时创建，也就是惰性加载。</p><p>当一开始判断Cell 数组是null 并且并发线程较少时，所有的累加操作都是对base 变量进行的。保持Cell 数组的大小为2 的N 次方，在初始化时Cell 数组中的Cell 元素个数为2 ，数组里面的变量实体是Cell 类型。Cell 类型是AtomicLong 的一个改进，用来减少缓存的争用，也就是解决伪共享问题（@sun.misc.Contended）。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>下面围绕以下话题从源码角度来分析LongAdder 的实现： </p><ol><li>LongAdder 的结构是怎样的？</li><li>当前线程应该访问Cell 数组里面的哪一个Cell 元素？</li><li>如何初始化Cell 数组？</li><li>Cell 数组如何扩容？</li><li>线程访问分配的Cell 元素有冲突后如何处理？</li><li>如何保证线程操作被分配的Cell 元素的原子性？</li></ol><p>LongAdder 类图结构如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/LongAddr-uml.png" alt="image"></p><p>LongAdder 类继承自Striped64 类，在Striped64 内部维护着三个变量。LongAdder 的真实值其实是base 的值与Cell 数组里面所有Cell 元素中的value 值的累加，base 是个基础值，默认为0 。cellsBusy 用来实现自旋锁，状态值只有0 和 1，当创建Cell 元素，扩容Cell 数组或者初始化Cell 数组时，使用CAS 操作该变量来保证同时只有一个线程可以进行其中之一的操作。</p><p>Cell 的构造如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>{</span><br><span class="line">    <span class="comment">// 保证内存可见</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) { value = x; }</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="long-sum"><a href="#long-sum" class="headerlink" title="long sum()"></a>long sum()</h4><p>内部操作是累加所有Cell 内部的value 值后累加base。但是由于计算总和没有对Cell 数组进行加锁，在累加过程中可能有其他线程对Cell 中的值进行了修改，也有可能对数组进行了扩容，所以sum 返回的值并不是非常精确的，其返回值并不是一个调用sum 方法时的原子快照值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>{</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-reset"><a href="#void-reset" class="headerlink" title="void reset()"></a>void reset()</h4><p>重置操作，把base 置为0，如果Cell 数组中有元素，则元素值重置为0</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>{</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="long-sumThenReset"><a href="#long-sumThenReset" class="headerlink" title="long sumThenReset()"></a>long sumThenReset()</h4><p>sum 累加Cell 值后，把前一个Cell 值重置为0，base 重置为0，多线程存在问题。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumThenReset</span><span class="params">()</span> </span>{</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>) {</span><br><span class="line">                sum += a.value;</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-add-long-x"><a href="#void-add-long-x" class="headerlink" title="void add(long x)"></a>void add(long x)</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 如果cells不为null继续执行，如果cells为空，则在base上累加，类似AtomicLong </span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) { </span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> || <span class="comment">// 前面的条件决定当前线程应该访问cells数组中的哪一个元素（m是当前cells数组元素个数-1，getProbe()用于获取当前线程变量threadlocalRandomProbe）</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))) <span class="comment">// 如果当前线程映射的元素存在， 使用CAS更新Cell元素值</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended); </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="cells-数组初始化和扩容"><a href="#cells-数组初始化和扩容" class="headerlink" title="cells 数组初始化和扩容"></a>cells 数组初始化和扩容</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化当前线程变量threadLocalRandomProbe的值（计算当前线程应分配到cells哪一个Cell元素用到）</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) {</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) { <span class="comment">// cells中有元素</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) { <span class="comment">// 当前线程应该访问cells数组的位置是空</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) {       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) {</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> {               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) {</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            }</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">// 当前Cell存在则执行CAS设置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 当前Cell数组元素个数大于CPU个数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">// 是否有冲突</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 如果当前元素个数没有达到CPU个数并且有冲突则扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) {      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        <span class="comment">// 扩容为之前的2倍</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 重置cellsBusy标识</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 为了能找到一个空闲的Cell,重新计算hash值，xorshift算法生成随机数（问题5，对CAS失败的线程重新计算threadLocalRandomProbe以减少冲突）</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 初始化Cell数组</span></span><br><span class="line">        <span class="comment">// cellsBusy标识，为0表示当前cells没有被初始化或扩容也没有在新建Cell元素；为1表示cells数组在被初始化或扩容或当前在创建新的Cell元素</span></span><br><span class="line">        <span class="comment">// casCellsBusy()通过CAS设置cellsBusy为1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> {                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) {</span><br><span class="line">                    <span class="comment">// 初始化cells元素个数为2</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// threadLocalRandomProbe &amp; (数组元素个数-1) 计算当前线程应该访问cells数组的位置</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 重置cellsBusy标识</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h2><p>LongAdder 类是LongAccumulator 的一个特例， LongAccumulator 比LongAdder 的功能更强大，可以为累加器提供非0 的初始值，还可以指定累加规则，比如不进行累加而进行相乘。</p><p>LongAccumulator构造函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">long</span> identity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.function = accumulatorFunction;</span><br><span class="line">    base = <span class="keyword">this</span>.identity = identity;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中accumulatorFunction 是一个双目运算器接口，根据输入的两个参数返回一个计算值，identity 为LongAccumulator 累加器的初始值。</p><p>调用LongAdder 就相当于使用下面的方式调用LongAccumulator:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(<span class="keyword">new</span> LongBinaryOperator() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    }</span><br><span class="line">}, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>通过对比LongAccumulator 与LongAdder 累加操作，不同之处在于在调用casBase时，后者传递的时b+x，前者使用 function.applyAsLong(b = base, x)来计算。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LongAccumulator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v, r; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> ||</span><br><span class="line">        (r = function.applyAsLong(b = base, x)) != b &amp;&amp; !casBase(b, r)) {</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">                (r = function.applyAsLong(v = a.value, x)) == v ||</span><br><span class="line">                a.cas(v, r)))</span><br><span class="line">            longAccumulate(x, function, uncontended);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) {</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : <span class="comment">// function为空默认使用v+x，等价于LongAdder，不为空使用自定义逻辑</span></span><br><span class="line">                                        fn.applyAsLong(v, x)))) </span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// LongAdder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) {</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;JUC 包提供了Atomiclnteger 、AtomicLong 和AtomicBoolean等原子性操作类，这些类都是使用非阻塞算法CAS 实现的，相比使用锁实现原子性操作这在性能上有很大提高。原子性操作类的原理大致相同，本文只对AtomicLong 类的实现原理以及JDK 8 中新增的LongAdder 和 LongAccumulator 类的原理讲解。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】：ThreadLocal</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-6/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-6/</id>
    <published>2020-12-26T09:46:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 即线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。</p><h2 id="ThreadLocal-实现原理"><a href="#ThreadLocal-实现原理" class="headerlink" title="ThreadLocal 实现原理"></a>ThreadLocal 实现原理</h2><p>ThreadLocal 相关类类图如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/threadlocal-uml.png" alt="image"></p><span id="more"></span><p>如图所示，Thread 类中有threadLocals 和inheritableThreadLocals 两个ThreadLocalMap 类型的变量，而ThreadLocalMap 是一个定制化的hash map。以ThreadLocal 为键，任意对象为值的存储结构。</p><p>ThreadLocal 相关源码分析如下：</p><ul><li>void set(T value)<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 查找当前线程的线程变量threadLocals</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 查找到线程变量则设置</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 第一次调用创建当前线程对应的ThreadLocalMap</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>{</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>T get()<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获得当前线程的threadLocals 变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// threadLocals 不为空则返回对应本地变量值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// threadLocals 为空则初始化当前线程的threadLocals 变量</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化为null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 设置当前线程threadLocals 为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>void remove()<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获得当前线程的threadLocals 变量</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// threadLocals 不为空则删除当前线程本地变量值</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>需要注意的是：每个线程的本地变量存放在线程自己的内存变量threadLocals 中，如果当前线程一直不消亡， 那么这些本地变量会一直存在， 所以可能会造成内存溢出， 因此使用完毕后要记得调用ThreadLocal 的remove 方法删除对应线程的threadLocals 中的本地变量。</p><h2 id="Threadlocal-不支持继承性"><a href="#Threadlocal-不支持继承性" class="headerlink" title="Threadlocal 不支持继承性"></a>Threadlocal 不支持继承性</h2><p>首先看下面一个例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span>  </span>{</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建线程变量</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">            <span class="comment">// 设置线程变量</span></span><br><span class="line">            threadLocal.set(<span class="string">"thread local"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启用子线程</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                        <span class="comment">// 子线程输出线程变量</span></span><br><span class="line">                        System.out.println(<span class="string">"thread:"</span> + threadLocal.get());</span><br><span class="line">                  }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程输出线程变量</span></span><br><span class="line">            System.out.println(<span class="string">"main:"</span> + threadLocal.get());</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main:thread local</span><br><span class="line">thread:null</span><br></pre></td></tr></tbody></table></figure><p>同一个ThreadLocal 变量在父线程中被设置值后， 在子线程中是获取不到的。因为在子线程thread 里面调用get 方法时当前线程为thread 线程，而这里调用set 方法设置线程变量的是main 线程，两者是不同的线程，自然子线程访问时返回null。但是可以使用InheritableThreadLocal 让子线程能访问到父线程中的值。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>{</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>InheritableThreadLocal 继承自ThreadLocal，并重写了其中的三个方法，那么当第一次调用set 方法时，创建的是当前线程inheritableThreadLocals 变量而不是threadLocals。get 方法获取到的也是inheritableThreadLocals。</p><p>那么InheritableThreadLocal 如何让子线程可以访问父线程的本地变量？这要从创建Thread 的代码说起，查看Thread 类的默认构造函数，部分源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>{</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">long</span> stackSize)</span> </span>{</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果父线程inheritableThreadLocals 变量不为null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 设置父线程inheritableThreadLocals 到子线程</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">        </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>{</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) {</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 调用重写的childValue</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么只需要把【Threadlocal 不支持继承性】章节测试代码中的线程变量修改为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main:thread local</span><br><span class="line">thread:thread local</span><br></pre></td></tr></tbody></table></figure><p>使用场景：</p><ul><li>子线程需要使用存放在threadlocal 变量中的用户登录信息</li><li>一些中间件需要把统一的id 追踪的整个调用链路记录下来</li><li>···</li></ul><p>参考文献：</p><ul><li>Java并发编程之美</li><li>Java并发编程的艺术</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;p&gt;ThreadLocal 即线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。&lt;/p&gt;
&lt;h2 id=&quot;ThreadLocal-实现原理&quot;&gt;&lt;a href=&quot;#ThreadLocal-实现原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 实现原理&quot;&gt;&lt;/a&gt;ThreadLocal 实现原理&lt;/h2&gt;&lt;p&gt;ThreadLocal 相关类类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/threadlocal-uml.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】：线程基础</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-5/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-5/</id>
    <published>2020-12-26T09:44:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是进程中的一个实体，线程本身是不会独立存在。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用CPU 运行的是线程，所以也说线程是CPU 分配的基本单位。</p><h2 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h2><p>Java 中有三种线程创建方式，分别为:</p><ol><li>通过继承Thread类，重写run方法</li><li>通过实现Runnable接口的run 方法</li><li>通过使用FutureTask 方式, 实现Callable接口的call 方法</li></ol><span id="more"></span><ul><li>继承Thread类，重写run方法<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承Thread类并重写run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Singleton.ThreadTest.MyThread thread = <span class="keyword">new</span> Singleton.ThreadTest.MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>如上代码中，MyThread类继承Thread类，并重写run() 方法。创建MyThread实例后调用start方法启动线程。值得注意的是，调用start 方法后线程不是马上执行，而是处于就绪状态，等待获取CPU 资源后才会处于运行状态，run 方法执行完毕后，线程处于终止状态。</li></ul><p>使用继承方式的好处是， 在run 方法内获取当前线程直接使用this 就可以了，无须使用Thread.currentThread() 方法；不好的地方是Java 不支持多继承，如果继承了Thread 类，那么就不能再继承其他类。另外任务与代码没有分离， 当多个线程执行一样的任务时需要多份任务代码，而Runable 则没有这个限制。</p><ul><li><p>实现Runnable接口的run 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        RunnableTask task = <span class="keyword">new</span> RunnableTask();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上面代码所示，两个线程共用一个task 代码逻辑，如果需要，可以给RunnableTask 添加参数进行任务区分。另外，RunnableTask 可以继承其他类。但是上面介绍的两种方式 都有一个缺点，就是任务没有返回值。</p></li><li><p>使用FutureTask 方式, 实现Callable接口的call 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"caller task"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        <span class="comment">// 创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待任务执行完毕并返回结果</span></span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上代码中的CallerTask 类实现了Callable 接口的call() 方法。创建FutureTask 对象（构造函数为CallerTask 的实例），然后使用创建的FutrueTask 对象作为任务创建了一个线程并且启动它， 最后通过futureTask.get() 等待任务执行完毕并返回结果。</p></li></ul><h2 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h2><p>Java 中的Object 类是所有类的父类，鉴于继承机制， Java 把所有类都需要的方法放到了Object 类里面，其中就包含通知与等待系列函数。</p><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait() 函数"></a>wait() 函数</h3><p>当一个线程调用一个共享变量的wait() 方法时， 该调用线程会被阻塞挂起， 直到发生下面几件事情之一才返回：</p><ol><li>其他线程调用了该共享对象的notify() 或者notifyAll() 方法</li><li>其他线程调用了该线程的interrupt() 方法， 该线程抛出InterruptedException 异常返回</li></ol><p>需要注意的是，如果调用wait() 方法的线程没有事先获取该对象的监视器锁，则调用wait() 方法时调用线程会抛出IllegalMonitorStateException 异常。</p><p>线程通过以下方法获取共享变量的监视器锁：</p><ol><li>执行synchronized 同步代码块时， 使用该共享变量作为参数。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(共享变量) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>调用该共享变量的方法，并且该方法使用了synchronized 修饰。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>另外需要注意的是，一个线程可以从挂起状态变为可以运行状态（也就是被唤醒），即使该线程没有被其他线程调用notify()、notifyAll() 方法进行通知，或者被中断，或者等待超时，这就是所谓的虚假唤醒。</p><p>（虚假唤醒在应用实践中很少发生），防患做法是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用wait() 方法进行防范。退出循环的条件是满足了唤醒该线程的条件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) {</span><br><span class="line">    <span class="keyword">while</span>(条件不满足) {</span><br><span class="line">        obj.wait();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="wait-long-timeout-函数"><a href="#wait-long-timeout-函数" class="headerlink" title="wait(long timeout) 函数"></a>wait(long timeout) 函数</h3><p>如果一个线程调用共享对象的该方法挂起后，没有在指定的timeout ms时间内被其他线程调用该共享变量的 notify() 或者notifyAll() 方法唤醒，那么该函数会因为超时而返回。</p><h3 id="wait-long-timeout-int-nanos-函数"><a href="#wait-long-timeout-int-nanos-函数" class="headerlink" title="wait(long timeout, int nanos) 函数"></a>wait(long timeout, int nanos) 函数</h3><p>nanos 纳秒，在nanos &gt; 0 时使参数timeout 递增1。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">              <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) {</span><br><span class="line">        timeout++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="notify-函数"><a href="#notify-函数" class="headerlink" title="notify() 函数"></a>notify() 函数</h3><p>一个线程调用共享对象的notify() 方法后，会随机唤醒一个在该共享变量上调用wait 系列方法后被挂起的线程。被唤醒的变量只有在获取到共享变量监视器锁后才能继续执行。</p><p>类似wait 系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify() 方法，否则会抛出IllegalMonitorStateException 异常。</p><h3 id="notifyAll-函数"><a href="#notifyAll-函数" class="headerlink" title="notifyAll() 函数"></a>notifyAll() 函数</h3><p>notifyAll() 方法会唤醒所有在该共享变量上由于调用wait 系列方法而被挂起的线程。</p><h2 id="等待线程执行终止的join-方法"><a href="#等待线程执行终止的join-方法" class="headerlink" title="等待线程执行终止的join 方法"></a>等待线程执行终止的join 方法</h2><p>挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p><h2 id="让线程睡眠的sleep-方法"><a href="#让线程睡眠的sleep-方法" class="headerlink" title="让线程睡眠的sleep 方法"></a>让线程睡眠的sleep 方法</h2><p>当一个执行中的线程调用了Thread 的sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与CPU 的调度。</p><p>如果在睡眠期间其他线程调用了该线程的interrupt()方法中断了该线程，则该线程会在调用sleep 方法的地方抛出InterruptedException 异常而返回。</p><h2 id="让出CPU-执行权的yield-方法"><a href="#让出CPU-执行权的yield-方法" class="headerlink" title="让出CPU 执行权的yield 方法"></a>让出CPU 执行权的yield 方法</h2><p>当一个线程调用Thread 的yield 方法时， 当前线程会让出CPU 使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU 的那个线程来获取CPU 执行权。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li>void interrupt() : 中断线程</li><li>boolean isInterrupted() : 检测当前线程是否被中断<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 传递false，说明不清除中断标志</span></span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>boolean interrupted() : 检测当前线程是否被中断，与isInterrupted不同的是，该方法如果发现当前线程被中断，会清除中断标志，并且该方法是static 方法，可以通过Thread 类直接调用。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 清除中断标志</span></span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线程状态与状态转换"><a href="#线程状态与状态转换" class="headerlink" title="线程状态与状态转换"></a>线程状态与状态转换</h2></li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>Java语言定义了6种线程状态，在给定的一个时刻，线程只能处于其中的一个状态。这6种状态分别是：</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被构建但是还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态，包括操作系统线程状态中的运行（Running）和就绪（Ready），线程正在执行或等待操作系统为其分配执行时间。</td></tr><tr><td>WAITING</td><td>等待状态，等待被其他线程显式唤醒（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态，无须等待被其他线程显式唤醒，在一定时间之后由系统自动唤醒</td></tr><tr><td>BLOCKED</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>TERMINATED</td><td>终止状态，线程已执行完毕</td></tr></tbody></table><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/threadstatus.png" alt="image"></p><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>CPU 一般是使用时间片轮转方式让线程轮询占用，所以当前线程CPU 时间片用完后，就会处于就绪状态并让出CPU ，等下次轮到自己的时候再执行，这就是上下文切换。（通过程序计数器记录线程让出CPU 时的执行地址，待再次分配到时间片时线程就从自己私有的计数器指定地址继续执行。另外需要注意的是，如果执行的是native 方法，那么pc 计数器记录的是undefined 地址，只有执行的是Java 代码时pc 计数器记录的才是下一条指令的地址。）</p><p>线程上下文切换时机有：</p><ul><li>当前线程的CPU 时间片使用完处于就绪状态时</li><li>当前线程被其他线程中断时</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p>死锁的产生必须具备以下四个条件：</p><ul><li>互斥条件： 指线程对己经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。</li><li>请求并持有条件： 指一个线程己经持有了至少一个资源但又要请求己被其他线程占有的资源时，当前线程会被阻塞但并不释放己获取的资源。</li><li>不可剥夺条件： 指线程获取到的资源在自己使用完之前不能被其他线程抢占， 只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件： 指在发生死锁时， 必然存在一个线程 - 资源的环形链。</li></ul><h3 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h3><p>要避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但只有请求并持有和环路等待条件是可以被破坏的。保持资源申请的有序性可以避免死锁。</p><h2 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h2><p>Java 中的线程分为两类，分别为daemon 线程（守护线程）和user 线程（用户线程）。在JVM 启动时会调用main 函数， main 函数所在的线程就是一个用户线程，在JVM 内部启动了很多守护线程， 比如垃圾回收线程。</p><h3 id="守护线程与用户线程区别"><a href="#守护线程与用户线程区别" class="headerlink" title="守护线程与用户线程区别"></a>守护线程与用户线程区别</h3><p>当最后一个非守护线程结束时， JVM 会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响JVM 的退出。即只要有一个用户线程还没结束， 正常情况下JVM 就不会退出。</p><p>下面代码中演示如何创建守护线程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Thread daemonThread = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">        System.out.println(<span class="string">"I am a daemon thread"</span>)</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;线程是进程中的一个实体，线程本身是不会独立存在。进程是代码在数据集合上的一次运行活动， 是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。&lt;/p&gt;
&lt;p&gt;操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用CPU 运行的是线程，所以也说线程是CPU 分配的基本单位。&lt;/p&gt;
&lt;h2 id=&quot;线程创建与运行&quot;&gt;&lt;a href=&quot;#线程创建与运行&quot; class=&quot;headerlink&quot; title=&quot;线程创建与运行&quot;&gt;&lt;/a&gt;线程创建与运行&lt;/h2&gt;&lt;p&gt;Java 中有三种线程创建方式，分别为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过继承Thread类，重写run方法&lt;/li&gt;
&lt;li&gt;通过实现Runnable接口的run 方法&lt;/li&gt;
&lt;li&gt;通过使用FutureTask 方式, 实现Callable接口的call 方法&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】：深入浅出synchronized</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-3/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-3/</id>
    <published>2020-12-26T09:42:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：</p><ol><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是synchonized括号里配置的对象。</li></ol><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><span id="more"></span><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>如下代码中，使用了同步代码块和同步方法，通过使用javap工具查看生成的class文件信息来分析synchronized关键字的实现细节。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>{</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">            <span class="keyword">synchronized</span>(object) {</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">      }</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>javap -v SynchronizedDemo.class查看字节码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Exception</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: astore_1</span><br><span class="line">         <span class="number">5</span>: monitorenter</span><br><span class="line">         <span class="number">6</span>: aload_1</span><br><span class="line">         <span class="number">7</span>: monitorexit</span><br><span class="line">         <span class="number">8</span>: goto          <span class="number">16</span></span><br><span class="line">        <span class="number">11</span>: astore_2</span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: monitorexit</span><br><span class="line">        <span class="number">14</span>: aload_2</span><br><span class="line">        <span class="number">15</span>: athrow</span><br><span class="line">        <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>从生成的class信息中，可以看到：</p><ul><li>同步代码块使用了 monitorenter 和 monitorexit 指令实现。</li><li>同步方法中依靠方法修饰符上的 ACC_SYNCHRONIZED 实现。</li></ul><p>monitorenter 和 monitorexit 这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</p><p>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。获取对象锁的过程是互斥的，如果获取对象锁失败，那当前线程就会被阻塞，并放入到同步队列中，进入BLOCKED状态，直到请求锁定的对象被持有它的线程释放为止。</p><p>需要特别注意的是：</p><ul><li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><h2 id="锁内部机制"><a href="#锁内部机制" class="headerlink" title="锁内部机制"></a>锁内部机制</h2><p>一般锁有4种状态：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。</p><p>在进一步深入之前，我们回顾两个概念：对象头和monitor。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在hotspot虚拟机中，对象在内存的分布分为3个部分：对象头，实例数据，和对齐填充。</p><p>对象头存储结构如下（32位虚拟机）：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/markword.png" alt="image"></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor是线程私有的数据结构，每一个线程都有一个可用monitor列表，同时还有一个全局的可用列表。</p><p>monitor内部包含如下几部分：</p><ul><li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li>EntryQ：关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor失败的线程。</li><li>RcThis：表示blocked或waiting在该monitor上的所有线程的个数。</li><li>Nest：用来实现重入锁的计数。</li><li>HashCode：保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li><li>Candidate：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值：0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在 java 虚拟机中，线程一旦进入到被synchronized修饰的方法或代码块时，指定的锁对象通过某些操作将对象头中的LockWord指向monitor 的起始地址与之关联，同时monitor 中的Owner存放拥有该锁的线程的唯一标识，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote><p>利用了CPU原语Compare-And-Swap(CAS，汇编指令CMPXCHG)。</p></blockquote><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ul><li>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word）。</li><li>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。<ul><li>如果更新成功，则获取对象轻量级锁成功，对象Mark Word的锁标志位将转变为“00”。</li><li>如果失败，则说明锁已被抢占，轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</li></ul></li></ul><h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><ul><li>如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。<ul><li>如果成功替换，那整个同步过程就顺利完成了；</li><li>如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li></ul></li></ul><blockquote><p>“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过CAS操作避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当线程获取锁时，会在对象头和栈帧的锁记录中存储锁偏向的线程ID，当线程再次进入锁相关的同步块时，只需要判断对象头存储的线程ID是否为当前线程，而不需要进行CAS操作进行加锁和解锁。</p><p>偏向锁目的是消除数据在无竞争情况下的同步，从而提高性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做。</p><h4 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h4><ul><li>当锁对象第一次被线程获取时，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。</li><li>同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。</li><li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。</li></ul><h4 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h4><p>当有其他线程请求相同锁时，偏向模式结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态。</p><blockquote><p>如果程序中大多数锁总是被多个线程访问的时候，也就是竞争比较激烈，偏向锁反而会降低性能。使用参数-XX:-UseBiasedLocking 禁止偏向锁，默认开启。</p></blockquote><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><h3 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别差距</td><td>如果线程间存在锁竞争会带来额外的锁撤销消耗</td><td>适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序响应速度</td><td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td>追求响应时间</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间慢</td><td>追求吞吐量</td></tr></tbody></table><p>参考文献：</p><ul><li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</li><li>《Java并发编程的艺术》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于普通同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前类的Class对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是synchonized括号里配置的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】：深入剖析volatile关键字</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-2/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-2/</id>
    <published>2020-12-26T09:41:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><p>volatile关键字是Java虚拟机提供的最轻量级的同步机制，volatile修饰的变量具备两个特性：</p><ol><li>保证此变量对所有线程的可见性。</li><li>禁止指令重排序优化。</li></ol><span id="more"></span><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="加锁如何解决可见性问题？"><a href="#加锁如何解决可见性问题？" class="headerlink" title="加锁如何解决可见性问题？"></a>加锁如何解决可见性问题？</h4><p>因为某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。</p><p>而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p><h4 id="volatile如何解决可见性问题？"><a href="#volatile如何解决可见性问题？" class="headerlink" title="volatile如何解决可见性问题？"></a>volatile如何解决可见性问题？</h4><p>每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果操作了数据并且写回主内存，则其他线程已经读取的变量副本就会失效，需要再次去主内存中读取。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><h4 id="指令重排序-1"><a href="#指令重排序-1" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。一般重排序可以分为如下三种：</p><ul><li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</p></li></ul><p>但是不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><h4 id="volatile如何禁止指令重排序？"><a href="#volatile如何禁止指令重排序？" class="headerlink" title="volatile如何禁止指令重排序？"></a>volatile如何禁止指令重排序？</h4><p>下面是一段标准的双锁检测（Double Check Lock，DCL）单例代码，通过观察加入volatile<br>和未加入volatile关键字时所生成的汇编代码的差别（如何获得即时编译的汇编代码？请参考附录关于HSDIS插件的介绍）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过对比发现，关键变化在于有volatile修饰的变量，赋值后多执行了一个<code>“lock addl $0x0,(%rsp)”</code>操作，</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/volatile01.png" alt="image"></p><p>这个操作的作用相当于一个内存屏障<br>（Memory Barrier或Memory Fence，指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p><p>IA-32架构软件开发者手册中规定，Lock前缀的指令在多核处理器下会引发了两件事情：</p><ol><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<code>缓存一致性协议</code>，每个处理器通过<code>嗅探</code>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p><strong>由此可见，Java编译器会在生成指令系列时在适当的位置插入<code>内存屏障</code>指令来禁止特定类型的处理器重排序。</strong></p><p>JMM针对编译器制定volatile重排序规则表：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/volatile.png" alt="image"></p><p>需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。</p><ul><li>写操作：</li></ul><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/volatile02.png" alt="image"></p><ul><li>读操作：</li></ul><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/volatile03.png" alt="image"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="解决单例双重检查对象初始化代码执行乱序问题"><a href="#解决单例双重检查对象初始化代码执行乱序问题" class="headerlink" title="解决单例双重检查对象初始化代码执行乱序问题"></a>解决单例双重检查对象初始化代码执行乱序问题</h3><p>创建对象步骤：</p><ul><li>分配内存空间</li><li>调用构造器，初始化实例</li><li>返回地址给引用</li></ul><p>对象创建过程有可能发生指令重排序：在内存里面开辟了一片存储区域后直接返回内存的引用，这个时候还没真正的初始化完对象，因而发生异常。使用volatile禁止指令重排可解决。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h3><p>由于volatile的MESI缓存一致性协议，不断从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值，造成其他的功能通信的延迟。所以根据场景使用volatile或锁。</p><h3 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h3><ul><li>volatile只能修饰实例变量和类变量，而synchronized可以用在变量、方法、类、以及代码块。</li><li>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全); 而synchronized是一种排他(互斥)的机制，保证变量的修改可见性和原子性。</li><li>volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。</li><li>volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，可以保证线程安全。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="HSDIS-反汇编插件"><a href="#HSDIS-反汇编插件" class="headerlink" title="HSDIS 反汇编插件"></a>HSDIS 反汇编插件</h3><p>虚拟机提供了一组通用的反汇编接口，可以接入各种平台下的反汇编适配器，64位x86平台选用hsdis-amd64，下载后将其放置在JAVA_HOME/lib/amd64/server下，只要与jvm.dll或libjvm.so的路径相同即可被虚拟机调用。为虚拟机安装反汇编适配器后，就可以使用-XX:+PrintAssembly参数要求虚拟机打印编译方法的汇编代码。</p><ol><li>下载<a href="https://files.cnblogs.com/files/haif/hsdis-amd64.zip">hsdis-amd64.dll</a>放到JRE_HOME/bin/server路径下</li><li>添加虚拟机参数 <code>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,*Singleton.*</code>并启动</li></ol><p>参考文献：</p><ul><li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</li><li>《Java并发编程的艺术》</li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a></li><li><a href="https://www.cnblogs.com/aobing/p/12840913.html">面试官没想到一个Volatile，我都能跟他扯半小时</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;语义&quot;&gt;&lt;a href=&quot;#语义&quot; class=&quot;headerlink&quot; title=&quot;语义&quot;&gt;&lt;/a&gt;语义&lt;/h2&gt;&lt;p&gt;volatile关键字是Java虚拟机提供的最轻量级的同步机制，volatile修饰的变量具备两个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保证此变量对所有线程的可见性。&lt;/li&gt;
&lt;li&gt;禁止指令重排序优化。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Java 并发编程系列】：并发编程基础</title>
    <link href="https://haifuns.com/2020/12/26/java-concurrent-1/"/>
    <id>https://haifuns.com/2020/12/26/java-concurrent-1/</id>
    <published>2020-12-26T09:40:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h2><p>为了解决计算机系统中主内存与CPU之间运行速度差问题，在CPU与主内存之间添加一级或者多级高速缓冲存储器（Cache）。这个Cache一般被集成到CPU内部，所以也叫CPU Cache。</p><p>图示为两级Cache结构：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/cpu-cache1.png" alt="image"></p><span id="more"></span><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p><ul><li>时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问</li><li>空间一致性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问</li></ul><h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议(MESI)"></a>缓存一致性协议(MESI)</h3><p>MESI（Modified Exclusive Shared Or Invalid）(也称伊利诺斯协议）是一种广泛使用的支持写回策略的缓存一致性协议。CPU中每个缓存行（Cache line）有4种状态，可用2个bit表示，它们分别是：</p><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M 修改 (Modified)</td><td>这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td></tr><tr><td>E 独享、互斥 (Exclusive)</td><td>这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td></tr><tr><td>S 共享 (Shared)</td><td>这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td></tr><tr><td>I 无效 (Invalid)</td><td>这行数据无效。</td><td>无</td></tr></tbody></table><p>MESI状态转换如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/MESI.jpg" alt="image"></p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>本地读取（Local read）</td><td>本内核读本Cache中的值</td></tr><tr><td>本地写入（Local write）</td><td>本内核写本Cache中的值</td></tr><tr><td>远端读取（Remote read）</td><td>其他内核读其他Cache中的值</td></tr><tr><td>远端写入（Remote write）</td><td>其他内核写其他Cache中的值</td></tr></tbody></table><p>状态之间的相互转换关系也可以使用下表进行表示:</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/MESI2.png" alt="image"></p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p>CPU 访问某个变量时，首先会去看CPU Cache 内是否有该变量，如果有则直接从中获取，否则就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache 行大小的内存复制到Cache 中。</p><p>由于存放到Cache 行的是内存块而不是单个变量，所以可能会把多个变量存放到一个Cache 行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/FalseSharing.png" alt="image"></p><p>如图所示，变量x 和y 同时被放到了CPU 的一级和二级缓存， 当线程1 使用CPU1 对变量x 进行更新时，首先会修改CPU1 的一级缓存变量x 所在的缓存行，这时候在缓存一致性协议下， CPU2 中变量x 对应的缓存行失效。那么线程2 在写入变量x 时就只能去 二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的CPU 中相同缓存行里面的变量。更坏的情况是，如果CPU 只有一级缓存，则会导致频繁地访问主内存。</p><h3 id="如何避免伪共享"><a href="#如何避免伪共享" class="headerlink" title="如何避免伪共享"></a>如何避免伪共享</h3><p>在JDK 8 之前一般都是通过<code>字节填充</code>的方式来避免该问题，也就是创建一个变量时使用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中。</p><p>JDK 8 提供了一个sun.misc.Contended 注解(修饰类或变量)，用来解决伪共享问题。</p><p>在默认情况下，@Contended 注解只用于Java 核心类，  比如rt包下的类。如果用户类路径下的类需要使用这个注解， 则需要添加JVM 参数：-XX:-RestrictContended 。<br>填充的宽度默认为128 ，要自定义宽度则可以设置 -XX:ContendedPaddingWidth 参数。</p><h2 id="Java-指令重排序"><a href="#Java-指令重排序" class="headerlink" title="Java 指令重排序"></a>Java 指令重排序</h2><p>Java 内存模型允许编译器和处理器对指令重排序以提高运行性能， 并且只会对不存在数据依赖性的指令重排序。</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p><p>数据依赖分为下列3种类型:</p><table><thead><tr><th>名称</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a = 1;b = a;</td><td>写一个变量之后，再读这个位置。</td></tr><tr><td>写后写</td><td>a = 1;a = 2;</td><td>写一个变量之后，再写这个变量。</td></tr><tr><td>读后写</td><td>a = b;b = 1;</td><td>读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><ol><li>A happens-before B</li><li>B happens-before C</li><li>A happens-before C</li></ol><p>这里的第3个happens-before关系，是根据happens-before的传递性推导出来的。</p><p>这里A happens-before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens-before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法，JMM允许这种重排序。</p><h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;      <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;      <span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">int</span> c= a + b;   <span class="comment">// (3)</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码中，变量c 的值依赖a 和b 的值，所以重排序后能够保证(3)的操作在(2)(1)之后，但是(1)(2)谁先执行就不一定了，这在单线程下不会存在问题，因为并不影响最终结果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">// (1)</span></span><br><span class="line">        flag = <span class="keyword">true</span>;             <span class="comment">// (2)</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (flag) {             <span class="comment">// (3)</span></span><br><span class="line">             <span class="keyword">int</span> i =  a * a;    <span class="comment">// (4)</span></span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 (4) 时，实际上不一定能看到线程 A 在操作 (1) 对共享变量 a 的写入。</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><p>使用volatile 修饰可以避免重排序和内存可见性问题。写volatile 变量时，可以确保volatile 写之前的操作不会被编译器重排序到volatile 写之后。读volatile 变量时，可以确保volatile 读之后的操作不会被编译器重排序到volatile 读之前。</p><h2 id="先行发生（happens-before）规则"><a href="#先行发生（happens-before）规则" class="headerlink" title="先行发生（happens-before）规则"></a>先行发生（happens-before）规则</h2><h3 id="happens-before定义"><a href="#happens-before定义" class="headerlink" title="happens-before定义"></a>happens-before定义</h3><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li></ol><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><ul><li>程序顺序原则：一个线程内保证语义串行性</li><li>volatile规则：volatile变量的写先发生于读</li><li>锁规则：解锁（unlock）必然发生在随后的加锁（lock）前</li><li>传递性：操作A先于操作B，操作B先于操作C 那么操作A必然先于操作C</li><li>线程启动规则：线程的start方法先于它的每一个动作</li><li>线程终止规则：线程的所有操作先于线程的终结（Thread.join()）</li><li>线程中断规则：线程的中断（interrupt()）先于被中断的代码</li><li>对象终结规则：对象的构造函数执行结束先于finalize()方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CPU多级缓存&quot;&gt;&lt;a href=&quot;#CPU多级缓存&quot; class=&quot;headerlink&quot; title=&quot;CPU多级缓存&quot;&gt;&lt;/a&gt;CPU多级缓存&lt;/h2&gt;&lt;p&gt;为了解决计算机系统中主内存与CPU之间运行速度差问题，在CPU与主内存之间添加一级或者多级高速缓冲存储器（Cache）。这个Cache一般被集成到CPU内部，所以也叫CPU Cache。&lt;/p&gt;
&lt;p&gt;图示为两级Cache结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/concurrent/cpu-cache1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://haifuns.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="https://haifuns.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Netty】工作原理解析</title>
    <link href="https://haifuns.com/2020/12/26/netty/"/>
    <id>https://haifuns.com/2020/12/26/netty/</id>
    <published>2020-12-26T09:34:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程模型介绍"><a href="#线程模型介绍" class="headerlink" title="线程模型介绍"></a>线程模型介绍</h1><p>不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，下面来系统的讲解下各个线程模式， 最后看看 Netty 线程模型有什么优越性。</p><p>目前存在的线程模型有： </p><ul><li>传统阻塞 I/O 服务模型</li><li>Reactor 模式</li></ul><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p><ul><li>单 Reactor 单线程</li><li>单 Reactor 多线程</li><li>主从 Reactor 多线程</li></ul><p>Netty 线程模式：Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p><span id="more"></span><h1 id="传统阻塞-I-x2F-O-服务模型"><a href="#传统阻塞-I-x2F-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h1><h2 id="工作原理示意图"><a href="#工作原理示意图" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/old-io-model.png" alt="image"></p><h2 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h2><ul><li>采用阻塞 IO 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>当并发数很大，就会创建大量的线程，占用很大的系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</li></ul><h1 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h1><p>Reactor: 反应器模式，也被称为分发者模式(Dispatcher)或通知者模式(notifier)。</p><p>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案如下：</p><ul><li>基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ul><h2 id="Reactor-模式设计思想"><a href="#Reactor-模式设计思想" class="headerlink" title="Reactor 模式设计思想"></a>Reactor 模式设计思想</h2><p>Reactor 模式基本设计思想是I/O 复用结合线程池，如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/reactor-model.png" alt="image"></p><ol><li>Reactor 模式，通过一个或多个输入同时传递给服务处理器(基于事件驱动) 。</li><li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此 Reactor 模式也叫 Dispatcher 模式。</li><li>Reactor 模式使用 IO 复用监听事件，收到事件后，分发给某个线程(进程)， 这点就是网络服务器高并发处理关键。</li></ol><h2 id="Reactor-模式核心组成"><a href="#Reactor-模式核心组成" class="headerlink" title="Reactor 模式核心组成"></a>Reactor 模式核心组成</h2><ol><li>Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。</li><li>Handlers：处理程序执行 I/O 事件要完成的实际事件。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li></ol><h2 id="Reactor-模式分类"><a href="#Reactor-模式分类" class="headerlink" title="Reactor 模式分类"></a>Reactor 模式分类</h2><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p><ol><li>单 Reactor 单线程</li><li>单 Reactor 多线程</li><li>主从 Reactor 多线程</li></ol><h2 id="单Reactor-单线程模式"><a href="#单Reactor-单线程模式" class="headerlink" title="单Reactor 单线程模式"></a>单Reactor 单线程模式</h2><h3 id="工作原理示意图-1"><a href="#工作原理示意图-1" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/reactor-model1.png" alt="image"></p><h3 id="工作流程说明"><a href="#工作流程说明" class="headerlink" title="工作流程说明"></a>工作流程说明</h3><ol><li>Select 是前面 I/O 复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求。</li><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发。</li><li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理完成连接后的各种事件</li><li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应。</li><li>Handler 会完成 Read -&gt; 业务处理 -&gt; Send 的完整业务流程。</li></ol><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul><li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</li><li>缺点：<ul><li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul></li></ul><p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况。</p><h2 id="单Reactor-多线程模式"><a href="#单Reactor-多线程模式" class="headerlink" title="单Reactor 多线程模式"></a>单Reactor 多线程模式</h2><h3 id="工作原理示意图-2"><a href="#工作原理示意图-2" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/reactor-model2.png" alt="image"></p><h3 id="工作流程说明-1"><a href="#工作流程说明-1" class="headerlink" title="工作流程说明"></a>工作流程说明</h3><ol><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后，通过 dispatch 进行分发。</li><li>如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理完成连接后的各种事件。</li><li>如果不是连接请求，则由 Reactor 分发调用连接对应的 Handler 来处理。</li><li>Handler 只负责响应事件，不做具体的业务处理，通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务。</li><li>Worker 线程池会分配独立线程完成真正的业务，并将结果返回给 Handler。</li><li>Handler 收到响应后，通过 send 将结果返回给 client。</li></ol><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul><li>优点：可以充分的利用多核 CPU 的处理能力。</li><li>缺点：多线程数据共享和访问比较复杂，Reactor 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li></ul><h2 id="主从Reactor-模式"><a href="#主从Reactor-模式" class="headerlink" title="主从Reactor 模式"></a>主从Reactor 模式</h2><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在 多线程中运行。</p><h3 id="工作原理示意图-3"><a href="#工作原理示意图-3" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/reactor-model3.png" alt="image"></p><h3 id="工作流程说明-2"><a href="#工作流程说明-2" class="headerlink" title="工作流程说明"></a>工作流程说明</h3><ol><li>Reactor 主线程 MainReactor 对象通过 select 监听连接事件，收到事件后，通过Acceptor 处理连接事件。</li><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor。</li><li>SubReactor 将连接加入到连接队列进行监听，并创建 handler 进行各种事件处理。</li><li>当有新事件发生时，SubReactor 就会调用对应的 handler 处理。</li><li>handler 通过 read 读取数据，分发给后面的 worker 线程处理。</li><li>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果。</li><li>handler 收到响应的结果后，再通过 send 将结果返回给 client。</li><li>Reactor 主线程可以对应多个 Reactor 子线程, 即 MainRecator 可以关联多个SubReactor。</li></ol><h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul><li>优点：<ul><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li></ul></li><li>缺点：编程复杂度较高</li></ul><p>结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程， Netty 主从多线程模型的支持。</p><h2 id="Reactor-模式优点和缺点"><a href="#Reactor-模式优点和缺点" class="headerlink" title="Reactor 模式优点和缺点"></a>Reactor 模式优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的。</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销。</li><li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源。</li><li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。</li><li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector 支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer 可能不会有那么高效。</li><li>Reactor模式在IO 读写数据时还是在同一个线程中实现的，即使使用多个Reactor 机制的情况下，那些共享一个Reactor 的Channel 如果出现一个长时间的数据读写，会影响这个Reactor 中其他Channel 的响应时间，比如在大文件传输时，IO 操作就会影响其他Client 的响应时间，因而对这种操作，使用传统的Thread-Per-Connection 或许是一个更好的选择，或者此时使用改进版的Reactor 模式如Proactor 模式。</li></ol><h1 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h1><p>Netty 主要基于主从 Reactors 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p><h2 id="工作原理示意图-4"><a href="#工作原理示意图-4" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/netty-model.png" alt="image"></p><h2 id="工作流程说明-3"><a href="#工作流程说明-3" class="headerlink" title="工作流程说明"></a>工作流程说明</h2><ol><li>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写。</li><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup。</li><li>NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop。</li><li>NioEventLoop 表示一个不断循环的执行处理任务的线程，每个 NioEventLoop 都有一个 selector ，用于监听绑定在其上的 socket 的网络通讯。其内部采用串行化设计，从消息的读取 -&gt; 解码 -&gt; 处理 -&gt; 编码 -&gt; 发送，始终由 IO 线程 NioEventLoop 负责。</li><li>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop。</li><li>每个 Boss NioEventLoop 循环执行的步骤：<ul><li>轮询 accept 事件。</li><li>处理 accept 事件，与 client 建立连接，生成 NioSocketChannel ，并将其注册到某个 Worker NIOEventLoop 上 的 selector。</li><li>处理任务队列的任务，即 runAllTasks。</li></ul></li><li>每个 Worker NIOEventLoop 循环执行的步骤：<ul><li>轮询 read，write 事件。</li><li>处理 I/O 事件， 即read ，write 事件，在对应 NioSocketChannel 处理业务。</li><li>处理任务队列的任务，即 runAllTasks。</li></ul></li><li>每个 Worker NIOEventLoop 处理业务时，会使用pipeline（管道），pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的handler 处理器用来处理 channel 中的数据。</li></ol><h2 id="案例：-TCP-服务"><a href="#案例：-TCP-服务" class="headerlink" title="案例： TCP 服务"></a>案例： TCP 服务</h2><ul><li>服务端</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        // 创建两个线程组 bossGroup 和 workerGroup</span><br><span class="line">        // bossGroup 只是处理连接请求, 真正的和客户端业务处理, 会交给workerGroup 完成</span><br><span class="line">        // bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数默认是实际cpu 核心数 * 2</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(bossGroup, workerGroup) // 设置两个线程组</span><br><span class="line">                .channel(NioServerSocketChannel.class) // 使用NioSocketChannel 作为服务器的通道实现</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列得到连接个数</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true) // 设置保持活动的连接状态</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { // 创建一个通道测试对象(匿名对象)</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel ch) throws Exception {</span><br><span class="line">                        // 给pipeline 设置处理器</span><br><span class="line">                        ch.pipeline().addLast(new NettyServerHandler());</span><br><span class="line">                    }</span><br><span class="line">                }); // 给workGroup 的EventLoop 对应的管道设置处理器</span><br><span class="line"></span><br><span class="line">        System.out.println("服务器已准备就绪...");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            // 启动服务器, 绑定端口并设置同步</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(8080).sync();</span><br><span class="line"></span><br><span class="line">            // 对关闭通道监听</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } finally {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义handler处理器</span><br><span class="line"> */</span><br><span class="line">class NettyServerHandler extends ChannelInboundHandlerAdapter {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取数据实际(这里可以读取客户端发送的消息)</span><br><span class="line">     * @param ctx 上下文对象, 含有管道pipeline, 通道channel, 地址</span><br><span class="line">     * @param msg 客户端发送的数据</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {</span><br><span class="line"></span><br><span class="line">        System.out.println("服务器读取线程: " + Thread.currentThread().getName());</span><br><span class="line">        System.out.println("server ctx = " + ctx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        // ChannelPipeline pipeline = ctx.pipeline(); // 本质是一个双向链表</span><br><span class="line"></span><br><span class="line">        // 将msg 转成一个ByteBuf</span><br><span class="line">        // ByteBuf是Netty提供的, 不是NIO的ByteBuffer</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line"></span><br><span class="line">        System.out.println("收到客户端消息: " + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println("客户端地址: " + channel.remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据读取完毕</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {</span><br><span class="line">        // writeAndFlush 是write + flush</span><br><span class="line">        // 将数据写入到缓存, 并刷新</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer("bye ~", CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>客户端</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class NettyClient {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // 客户端需要一个事件循环组</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        // 创建客户端启动对象</span><br><span class="line">        // 注意客户端使用的不是ServerBootstrap 而是Bootstrap</span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        // 设置相关参数</span><br><span class="line">        bootstrap.group(group) //设置线程组</span><br><span class="line">                .channel(NioSocketChannel.class) // 设置客户端通道的实现类(反射)</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                    @Override protected void initChannel(SocketChannel ch) throws Exception {</span><br><span class="line">                        ch.pipeline().addLast(new NettyClientHandler()); //加入自己的处理器</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line"></span><br><span class="line">        System.out.println("客户端准备就绪...");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            // 启动客户端去连接服务器端</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 8080).sync();</span><br><span class="line">            // 监听关闭通道</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } finally {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class NettyClientHandler extends ChannelInboundHandlerAdapter {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当通道就绪就会触发该方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception {</span><br><span class="line">        System.out.println("client ctx = " + ctx);</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer("hello ~", CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当通道有读取事件时触发</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println("服务器消息: " + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println("服务器地址: "+ ctx.channel().remoteAddress());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常事件</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="任务队列-Task"><a href="#任务队列-Task" class="headerlink" title="任务队列 Task"></a>任务队列 Task</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>用户程序自定义的普通任务</li><li>用户自定义定时任务</li><li>非当前 Reactor 线程调用 Channel 的各种方法</li></ol><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class NettyServerTaskHandler extends ChannelInboundHandlerAdapter {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {</span><br><span class="line"></span><br><span class="line">        // 自定义普通任务, 该任务是提交到taskQueue中</span><br><span class="line">        ctx.channel().eventLoop().execute(new Runnable() {</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello ~ task", CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println("channel hash =" + ctx.channel().hashCode());</span><br><span class="line">                } catch (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        // 注意此处第二个普通任务在任务一基础上睡眠5s, 10s后输出</span><br><span class="line">        ctx.channel().eventLoop().execute(new Runnable() {</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello ~ task2", CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println("channel hash =" + ctx.channel().hashCode());</span><br><span class="line">                } catch (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        // 自定义定时任务, 该任务是提交到scheduledTaskQueue中</span><br><span class="line">        ctx.channel().eventLoop().schedule(new Runnable() {</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(5 * 1000);</span><br><span class="line">                    ctx.writeAndFlush(Unpooled.copiedBuffer("hello ~ timed task", CharsetUtil.UTF_8));</span><br><span class="line">                    System.out.println("channel hash =" + ctx.channel().hashCode());</span><br><span class="line">                } catch (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, 5, TimeUnit.SECONDS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer("bye ~", CharsetUtil.UTF_8));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>异步的概念和同步相对，当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。 </p><p>Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture，调用者并不能立刻获得结果，而是通过 Future - Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。Netty 的异步模型是建立在 future 和 callback 的基础上。</p><p>Future 表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等。</p><h2 id="工作原理示意图-5"><a href="#工作原理示意图-5" class="headerlink" title="工作原理示意图"></a>工作原理示意图</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/netty/async-model.png" alt="image"></p><p>说明: </p><ol><li>在使用 Netty 编程时，拦截操作和转换出入站数据只需要提供 callback 或利用 future 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li></ol><h2 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h2><ol><li>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li><li>常见有如下操作：<ul><li>通过 isDone 方法来判断当前操作是否完成 </li><li>通过 isSuccess 方法来判断已完成的当前操作是否成功</li><li>通过 getCause 方法来获取已完成的当前操作失败的原因</li><li>通过 isCancelled 方法来判断已完成的当前操作是否被取消</li><li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器</li></ul></li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 启动服务器, 绑定端口并设置同步</span><br><span class="line">ChannelFuture channelFuture = bootstrap.bind(8080).sync();</span><br><span class="line">// 给ChannelFuture注册监听器, 监控关心的事件</span><br><span class="line">channelFuture.addListener(new ChannelFutureListener() {</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) throws Exception {</span><br><span class="line">        if (future.isSuccess()) {</span><br><span class="line">            System.out.println("监听端口 8080 成功");</span><br><span class="line">        } else {</span><br><span class="line">            System.out.println("监听端口 8080 失败");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="案例：HTTP-服务"><a href="#案例：HTTP-服务" class="headerlink" title="案例：HTTP 服务"></a>案例：HTTP 服务</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new CustomHttpServerInitializer());</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(8080).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } finally {</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class CustomHttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception {</span><br><span class="line">        // 得到管道</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        // 加入一个netty提供的http编解码器</span><br><span class="line">        pipeline.addLast("httpServerCodec", new HttpServerCodec());</span><br><span class="line">        // 增加一个自定义handler</span><br><span class="line">        pipeline.addLast(new CustomHttpServer());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class CustomHttpServer extends SimpleChannelInboundHandler&lt;HttpObject&gt; {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取客户端数据</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {</span><br><span class="line">        if (msg instanceof HttpRequest) {</span><br><span class="line">            System.out.println("pipeline hash = " + ctx.pipeline().hashCode() + "handler hash = " + this.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println("客户端地址: " + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            // 请求信息</span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            // 获取URI, 过滤指定资源</span><br><span class="line">            URI uri = new URI(httpRequest.uri());</span><br><span class="line">            if ("/favicon.ico".equals(uri.getPath())) {</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // 回复信息给浏览器</span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer("hello ~", CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            // 构造http响应, 即httpResponse</span><br><span class="line">            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程模型介绍&quot;&gt;&lt;a href=&quot;#线程模型介绍&quot; class=&quot;headerlink&quot; title=&quot;线程模型介绍&quot;&gt;&lt;/a&gt;线程模型介绍&lt;/h1&gt;&lt;p&gt;不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，下面来系统的讲解下各个线程模式， 最后看看 Netty 线程模型有什么优越性。&lt;/p&gt;
&lt;p&gt;目前存在的线程模型有： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统阻塞 I/O 服务模型&lt;/li&gt;
&lt;li&gt;Reactor 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单 Reactor 单线程&lt;/li&gt;
&lt;li&gt;单 Reactor 多线程&lt;/li&gt;
&lt;li&gt;主从 Reactor 多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Netty 线程模式：Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。&lt;/p&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://haifuns.com/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://haifuns.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝（zero-copy）原理详解</title>
    <link href="https://haifuns.com/2020/12/26/zero-copy/"/>
    <id>https://haifuns.com/2020/12/26/zero-copy/</id>
    <published>2020-12-26T09:33:00.000Z</published>
    <updated>2025-02-23T13:53:31.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h1><h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>CPU 将指令分为特权指令和非特权指令，对于危险指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</p><p>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别（Windows 系统也是一样的）。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</p><p><strong>简单来说：内核空间和用户空间本质上是要提高操作系统的稳定性及可用性，当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。</strong></p><span id="more"></span><h2 id="DMA（直接存储器访问）"><a href="#DMA（直接存储器访问）" class="headerlink" title="DMA（直接存储器访问）"></a>DMA（直接存储器访问）</h2><p>DMA 即Direct Memory Access ，直接存储器访问。DMA 控制方式是以存储器为中心，在主存和I/O设备之间建立一条直接通路，在DMA 控制器的控制下进行设备和主存之间的数据交换。这种方式只在传输开始和传输结束时才需要CPU的干预。它非常适用于高速设备与主存之间的成批数据传输。</p><h1 id="传统I-x2F-O"><a href="#传统I-x2F-O" class="headerlink" title="传统I/O"></a>传统I/O</h1><p>下面通过一个Java 非常常见的应用场景：将系统中的文件发送到远端（磁盘文件 -&gt; 内存（字节数组） -&gt; 传输给用户/网络）来详细展开I/O操作。</p><p>如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/old-io.png"></p><ol><li>JVM 发出read() 系统调用，上下文从用户态切换到内核态（第一次上下文切换）。通过DMA（Direct Memory Access，直接存储器访问）引擎将文件中的数据从磁盘上读取到内核空间缓冲区（第一次拷贝: hard drive -&gt; kernel buffer）。</li><li>将内核空间缓冲区的数据拷贝到用户空间缓冲区（第二次拷贝：kernel buffer -&gt; user buffer），然后read系统调用返回。而系统调用的返回又会导致一次内核态到用户态的上下文切换（第二次上下文切换）。</li><li>JVM 处理代码逻辑并发送write() 系统调用，上下文从用户态切换到内核态（第三次上下文切换），然后将用户空间缓冲区中的数据拷贝到内核空间中与socket 相关联的缓冲区中（即，第2步中从内核空间缓冲区拷贝而来的数据原封不动的再次拷贝到内核空间的socket缓冲区中。）（第三次拷贝：user buffer -&gt; socket buffer）。</li><li>write 系统调用返回，上下文再次从内核态切换到用户态（第四次上下文切换）。通过DMA 引擎将内核缓冲区中的数据传递到协议引擎（第四次拷贝：socket buffer -&gt; protocol engine)，这次拷贝是一个独立且异步的过程。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>传统的I/O操作进行了4次用户态与内核态间的上下文切换，以及4次数据拷贝（2次DMA拷贝和2次CPU拷贝）。</p><p>传统的文件传输方式简单但存在冗余的上文切换和数据拷贝，多了很多不必要的开销，在高并发系统里会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h1 id="零拷贝（zero-copy）"><a href="#零拷贝（zero-copy）" class="headerlink" title="零拷贝（zero-copy）"></a>零拷贝（zero-copy）</h1><p>零拷贝是站在内核的角度来说的，其目的是消除从内核空间到用户空间的来回复制，并不是完全不会发生任何拷贝。</p><p>零拷贝不仅仅带来了更少的数据复制，还能带来其他的性能优势，例如：更少的上下⽂切换，更少的CPU 缓存伪共享以及无CPU 校验和计算。</p><h2 id="mmap-实现"><a href="#mmap-实现" class="headerlink" title="mmap 实现"></a>mmap 实现</h2><p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read，write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><p>基于mmap的拷贝流程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/mmap.png"></p><ol><li>发出mmap 系统调用，上下文从用户态切换到内核态（第一次上下文切换）。通过DMA 将磁盘文件中的内容拷贝到内核空间缓冲区中（第一次拷贝：hard drive -&gt; kernel buffer）。</li><li>mmap 系统调用返回，上下文从内核态切换到用户态（第二次上下文切换）。接着用户空间和内核空间共享这个缓冲区而不需要进行数据拷贝。</li><li>发出write 系统调用，上下文从用户态切换到内核态（第三次上下文切换）。将数据从内核空间缓冲区拷贝到内核空间socket 相关联的缓冲区（第二次拷贝：kernel buffer -&gt; socket buffer）。</li><li>write 系统调用返回，上下文从内核态切换到用户态（第四次上下文切换）。通过DMA 将内核空间socket  缓冲区中的数据传递到协议引擎（第三次拷贝：socket buffer -&gt; protocol engine）。</li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>通过mmap 实现的零拷贝 I/O 进行了4次用户态与内核态间的上下文切换，以及3次数据拷贝（2次DMA 拷贝和1次CPU 拷贝）。</p><p>通过mmap实现的零拷贝I/O 与传统 I/O 相比仅仅少了1次内核空间缓冲区和用户空间缓冲区之间的CPU拷贝。这样的好处是，可以将整个文件或者整个文件的一部分映射到内存当中，用户直接对内存中对文件进行操作，然后是由操作系统来进行相关的页面请求并将内存的修改写入到文件当中。应用程序只需要处理内存的数据，这样可以实现非常迅速的 I/O 操作。</p><h2 id="sendfile-实现"><a href="#sendfile-实现" class="headerlink" title="sendfile 实现"></a>sendfile 实现</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/sendfile.png"></p><ol><li>发出sendfile 系统调用，上下文从用户态切换到内核态（第一次上下文切换）。通过DMA 将磁盘文件中的内容拷贝到内核空间缓冲区中（第一次拷贝：hard drive -&gt; kernel buffer）。</li><li>将数据从内核空间缓冲区拷贝到内核中与socket相关的缓冲区中（第二次拷贝:kernel buffer -&gt; socket buffer）。</li><li>sendfile 系统调用返回，上下文从内核态切换到用户态（第二次上下文切换）。通过DMA 将内核空间socket  缓冲区中的数据传递到协议引擎（第三次拷贝：socket buffer -&gt; protocol engine）。</li></ol><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过sendfile实现的零拷贝I/O 只进行了2次用户态与内核态间的上下文切换，以及3次数据的拷贝（2次DMA 拷贝和1次CPU 拷贝）。</p><p>在Java中，FileChannel 的transferTo() 方法可以实现了这个过程，该方法将数据从文件通道传输到给定的可写字节通道。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>在 UNIX 和各种 Linux 系统中，此调用被传递到 <code>sendfile()</code> 系统调用中，最终实现将数据从一个文件描述符传输到了另一个文件描述符。</p><p>此时操作系统仍然需要在内核内存空间中复制数据（kernel buffer -&gt;socket buffer）。 虽然从操作系统的角度来看，这已经是零拷贝了（因为没有数据从内核空间复制到用户空间， 内核需要复制的原因是因为通用硬件DMA 访问需要连续的内存空间（因此需要缓冲区），但是，如果硬件支持scatter-and-gather ，这是可以避的。</p><h2 id="带有DMA-收集拷贝功能的sendfile-实现"><a href="#带有DMA-收集拷贝功能的sendfile-实现" class="headerlink" title="带有DMA 收集拷贝功能的sendfile 实现"></a>带有DMA 收集拷贝功能的sendfile 实现</h2><p>从 Linux 2.4 版本开始，操作系统底层提供了带有 scatter/gather 的DMA 来从内核空间缓冲区中将数据读取到协议引擎中。这样一来待传输的数据可以分散在存储的不同位置上，而不需要在连续存储中存放。那么从文件中读出的数据就根本不需要被拷贝到socket 缓冲区中去，只是需要将缓冲区描述符添加到socket 缓冲区中去，DMA 收集操作会根据缓冲区描述符中的信息将内核空间中的数据直接拷贝到协议引擎中。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/sendfile-gather.png"></p><ol><li>发出sendfile 系统调用，上下文从用户态切换到内核态（第一次上下文切换）。通过DMA 将磁盘文件中的内容拷贝到内核空间缓冲区中（第一次拷贝：hard drive -&gt; kernel buffer）。</li><li>没有数据拷贝到socket缓冲区。取而代之的是只有相应的描述符信息会被拷贝到相应的socket 缓冲区当中。该描述符包含了两方面的信息：kernel buffer 的内存地址和kernel buffer 的偏移量。</li><li>sendfile系统调用返回，上下文从内核态切换到用户态。DMA gather copy根据socket 缓冲区中描述符提供的位置和偏移量信息直接将内核空间缓冲区中的数据拷贝到协议引擎上（第二次拷贝：socket buffer -&gt; protocol engine），这样就避免了最后一次CPU数据拷贝。</li></ol><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>带有DMA 收集拷贝功能的sendfile 实现的I/O 只进行了2次用户态与内核态间的上下文切换，以及2次数据的拷贝，而且这2次的数据拷贝都是非CPU 拷贝。这样一来就实现了最理想的零拷贝I/O 传输了，不需要任何一次的CPU 拷贝，以及最少的上下文切换。</p><h2 id="零拷贝使用场景"><a href="#零拷贝使用场景" class="headerlink" title="零拷贝使用场景"></a>零拷贝使用场景</h2><ul><li>⽂件较⼤，读写较慢，追求速度</li><li>JVM 内存不够，不能加载太⼤的数据</li><li>内存宽带不够，即存在其他程序或线程存在⼤量的IO操作</li><li>······</li></ul><p>使用零拷贝的技术：</p><ul><li>Java NIO</li><li>Netty</li><li>RocketMQ</li><li>Kafka</li><li>······</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li>传统I/O</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOserver</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(bytes);</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) {</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldIOClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test1.zip"</span>);</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((readCount = fileInputStream.read(bytes)) &gt;= <span class="number">0</span>) {</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(bytes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"发送的总字节数= "</span> + total + <span class="string">", 耗时: "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总字节数= 192778371, 耗时: 1227</span><br></pre></td></tr></tbody></table></figure><ul><li>零拷贝：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readCount) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    readCount = socketChannel.read(byteBuffer);</span><br><span class="line">                } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 倒带, position = 0, mark作废</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">"test1.zip"</span>;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// linux下, 一个transferTo方法就可以完成传输</span></span><br><span class="line">        <span class="comment">// windows下, 一次调用transferTo只能发送8m, 超过8m需要分段传输文件</span></span><br><span class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>) fileChannel.size();</span><br><span class="line">        <span class="keyword">int</span> count = length / (<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> transferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">            <span class="comment">// transferTo 底层使用到零拷贝</span></span><br><span class="line">            transferCount += fileChannel.transferTo(transferCount, fileChannel.size(), socketChannel);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"发送的总字节数= "</span> + transferCount + <span class="string">", 耗时: "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的总字节数= 192778371, 耗时: 205</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前置概念&quot;&gt;&lt;a href=&quot;#前置概念&quot; class=&quot;headerlink&quot; title=&quot;前置概念&quot;&gt;&lt;/a&gt;前置概念&lt;/h1&gt;&lt;h2 id=&quot;用户空间与内核空间&quot;&gt;&lt;a href=&quot;#用户空间与内核空间&quot; class=&quot;headerlink&quot; title=&quot;用户空间与内核空间&quot;&gt;&lt;/a&gt;用户空间与内核空间&lt;/h2&gt;&lt;p&gt;CPU 将指令分为特权指令和非特权指令，对于危险指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。&lt;/p&gt;
&lt;p&gt;其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别（Windows 系统也是一样的）。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单来说：内核空间和用户空间本质上是要提高操作系统的稳定性及可用性，当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://haifuns.com/categories/Java/"/>
    
    
    <category term="Java IO" scheme="https://haifuns.com/tags/Java-IO/"/>
    
  </entry>
  
  <entry>
    <title>【Java I/O】NIO 详解</title>
    <link href="https://haifuns.com/2020/12/26/java-nio/"/>
    <id>https://haifuns.com/2020/12/26/java-nio/</id>
    <published>2020-12-26T09:28:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</p><p>NIO 三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。</p><p>NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p><p>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入， 这个线程同时可以去做别的事情。</p><span id="more"></span><h1 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h1><ul><li>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多</li><li>BIO 是阻塞的，NIO 则是非阻塞的</li><li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li></ul><h1 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h1><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p>NIO 简单原理示意如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/nio.png" alt="image"></p><ul><li>Buffer 是内存块，底层是数组，数据的读取写入通过Buffer ，Buffer 可以读也可以写，需要flip 方法切换</li><li>Channel 是双向的，可以反映底层操作系统的情况，比如Linux 底层的操作系统通道就是双向的，每个Channel 都会对应一个Buffer</li><li>Selector 对应一个线程，一个线程对应多个Channel（连接），Selector 会根据不同的事件，在各个通道上切换</li></ul><h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h2><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><p>Buffer 类内部结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>; <span class="comment">// 标记</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">// 下一个要被读或写的元素索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit; <span class="comment">// 缓冲区当前终点，不能越界，可以修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 最大容量，创建时设置</span></span><br></pre></td></tr></tbody></table></figure><p>Buffer 类相关方法一览：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @since JDK1.4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="comment">// 返回此缓冲区容量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> <span class="comment">// 返回此缓冲区位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> <span class="comment">// 设置此缓冲区位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> <span class="comment">// 返回此缓冲区限制</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> <span class="comment">// 设置缓冲区限制</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> <span class="comment">// 在此缓冲区的位置设置标记</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> <span class="comment">// 将此缓冲区的位置重置为之前标记的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> <span class="comment">// 清除此缓冲区，即将各个标记恢复到初始状态，数据并没有真正擦除</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> <span class="comment">// 反转此缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> <span class="comment">// 重绕此缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> <span class="comment">// 返回当前位置与限制之间的元素数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> <span class="comment">// 判断当前位置与限制之间是否有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> <span class="comment">// 判断此缓冲区是否只读</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// @since JDK1.6</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> <span class="comment">// 判断此缓冲区是否具有可访问的底层实现数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">array</span><span class="params">()</span> <span class="comment">// 返回此缓冲区底层实现数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> <span class="comment">// 返回此缓冲区底层实现数组中第一个缓冲区元素的偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> <span class="comment">// 判断此缓冲区是否为直接缓冲区</span></span></span><br></pre></td></tr></tbody></table></figure><p>Java 中的基本数据类型（boolean除外），都有Buffer 实现类，其中最常用的是ByteBuffer （二进制数据），该类主要方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> <span class="comment">// 创建直接缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> <span class="comment">// 设置缓冲区初始容量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> <span class="comment">// 把一个数组放到缓冲区使用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="comment">// 初始化位置offset，上界length的缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> <span class="comment">// 从当前位置position上get，get后position会自动加1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 从指定位置get</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span> <span class="comment">// 从当前位置put，put后position自动加1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span> <span class="comment">// 从指定位置put</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h2><p>NIO 的通道（Channel）类似于流（stream，如FileInputStream），但有些区别如下： </p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲</li></ul><p>Channel 是一个接口，常用的Channel 类有：FileChannel 、DatagramChannel 、ServerSocketChannel 和SocketChannel。（ServerSocketChannel类似ServerSocket ，SocketChannel 类似Socket）</p><ul><li>FileChannel 用于文件的数据读写</li><li>DatagramChannel 用于 UDP 的数据读写</li><li>ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写</li></ul><p>FileChannel 类主要用来对本地文件进行IO 操作，常用方法有：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="comment">// 从通道读取数据并放到缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="comment">// 把缓冲区数据写到通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span> <span class="comment">// 从目标通道复制数据到当前通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span> <span class="comment">// 把数据从当前通道复制到目标通道</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="文件读取、写入"><a href="#文件读取、写入" class="headerlink" title="文件读取、写入"></a>文件读取、写入</h4><p>使用Channel、Buffer将文件1中的内容写入到文件2</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">        FileChannel inFileChannel = fileInputStream.getChannel();</span><br><span class="line">        </span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line">        FileChannel outFileChannel = fileOutputStream.getChannel();</span><br><span class="line">        </span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">// 重置buffer</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> read = inFileChannel.read(buffer);</span><br><span class="line">            <span class="comment">// 已读完</span></span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 将buffer 中的数据写入到2.txt</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            outFileChannel.write(buffer);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="拷贝文件-transferFrom-方法"><a href="#拷贝文件-transferFrom-方法" class="headerlink" title="拷贝文件 transferFrom 方法"></a>拷贝文件 transferFrom 方法</h4><p>使用 FileChannel和方法transferFrom 完成文件的拷贝</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"a.png"</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.png"</span>);</span><br><span class="line">        <span class="comment">// 获取各个流对应的fileChannel</span></span><br><span class="line">        FileChannel sourceCh = fileInputStream.getChannel();</span><br><span class="line">        FileChannel destCh = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">// 使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">        <span class="comment">// 关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>ByteBuffer 支持类型化的put 和get，put 放入的是什么数据类型，get就应该使用相应的数据类型来取出</li><li>可以将普通Buffer 转成只读Buffer，asReadOnlyBuffer()</li><li>NIO 还提供了 MappedByteBuffer，可以让文件直接在内存（堆外内存）中进行修改，而如何同步到文件由 NIO 来完成<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MappedByteBuffer 可让文件直接在内存(堆外内存)修改, 操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">// 获取对应的通道</span></span><br><span class="line">        FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param1: 读写模式, param2: 可以修改的起始位置, param3: 映射到内存的大小(不是索引大小)即1.txt有多少字节映射到内存</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'A'</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'B'</span>);</span><br><span class="line">        <span class="comment">// mappedByteBuffer.put(5, (byte) 'C'); // IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到buffer 时, 可以采用 buffer 数组，依次写入 [分散]</span></span><br><span class="line"><span class="comment"> * Gathering: 从buffer 读取数据时, 可以采用 buffer 数组，依次读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到 socket, 并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等客户端连接(telnet)</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="comment">// 假定从客户端接收8个字节</span></span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(byteRead &lt; messageLength) {</span><br><span class="line">                <span class="keyword">long</span> length = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += length;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"byteRead="</span> + byteRead);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印当前buffer 的position 和limit</span></span><br><span class="line">                Arrays.stream(byteBuffers)</span><br><span class="line">                        .map(buffer -&gt; <span class="string">"position="</span> + buffer.position() + <span class="string">", limit="</span> + buffer.limit())</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有的 buffer 进行 flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(Buffer::flip);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据读出显示到客户端</span></span><br><span class="line">            <span class="keyword">long</span> byteWrite = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWrite &lt; messageLength) {</span><br><span class="line">                <span class="keyword">long</span> length = socketChannel.write(byteBuffers);</span><br><span class="line">                byteWrite += length;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有的 buffer 进行 clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(Buffer::clear);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"byteRead="</span> + byteRead + <span class="string">", byteWrite="</span> + byteWrite + <span class="string">", messageLength="</span> + messageLength);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器 Selector"></a>选择器 Selector</h2><p>Selector 能够检测多个注册的通道上是否有事件发生（注意：多个Channel 以事件的方式可以注册到同一个Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p><p>只有在 <em>连接/通道</em> 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。避免了多线程之间的上下文切换导致的开销。</p><p>Selector 类是一个抽象类, 常用方法和说明如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个选择器对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 从内部集合中得到所有SelectionKey</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 监控所有注册的通道，当其中有IO操作可以进行时，将对应的SelectionKey加入到内部集合中并返回</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数用来设置超时时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 阻塞</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 不阻塞，立马返还</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 唤醒 selector</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Selector <span class="title">wakeup</span><span class="params">()</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="NIO-非阻塞网络编程原理分析"><a href="#NIO-非阻塞网络编程原理分析" class="headerlink" title="NIO 非阻塞网络编程原理分析"></a>NIO 非阻塞网络编程原理分析</h3><p>NIO 非阻塞 网络编程相关的(Selector、SelectionKey、ServerSocketChannel 和 SocketChannel) 关系梳理图如下：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/nio-flow.png" alt="image"></p><ol><li>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel </li><li>Selector 进行监听 select 方法, 返回有事件发生的通道的个数</li><li>将 socketChannel 注册到 Selector 上, register(Selector sel, int ops), 一个 selector 上可以注册多个 SocketChannel </li><li>注册后返回一个 SelectionKey, 会和该 Selector 关联(集合) </li><li>进一步得到各个 SelectionKey (有事件发生) </li><li>在通过 SelectionKey 反向获取 SocketChannel , 方法 channel() </li><li>通过得到的 channel , 完成业务处理</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 创建 ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 得到一个 Selector 对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 绑定一个端口6666, 在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">// 设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 把serverSocketChannel注册到selector 关心事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">// 等待1s没有事件发生就返回</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) {</span><br><span class="line">                System.out.println(<span class="string">"服务器等待1s, 无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果返回的&gt;0, 表示已经获取到关注的事件, 就获取相关的selectionKey集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) {</span><br><span class="line">                <span class="comment">// 获取到 SelectionKey</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 根据 key 对应的通道发生的事件做相应处理</span></span><br><span class="line">                <span class="comment">// 如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                    <span class="comment">// 给该客户端生成一个 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">"客户端已连接, socketChannel: "</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">// 将SocketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 将socketChannel注册到selector, 关注事件为OP_READ, 同时给socketChannel关联一个 Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发生OP_READ</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                    <span class="comment">// 通过key反向获取对应的channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 获取到channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端消息: "</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动从集合中移动当前的selectionKey, 防止重复操作</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 提供服务器端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) {</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) {</span><br><span class="line">                System.out.println(<span class="string">"因为连接需要时间, 客户端不会阻塞, 可以做其它工作..."</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果连接成功, 就发送数据</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(<span class="string">"hello nio server"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 发送数据, 将buffer数据写入channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>SelectionKey 表示 Selector 和网络通道的注册关系, 共四种: </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 代表读操作，值为 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 代表写操作，值为 4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代表连接已经建立，值为 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 有新的网络连接可以 accept，值为 16</span></span><br></pre></td></tr></tbody></table></figure><p>相关方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> <span class="comment">// 得到与之关联的selecter</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SelectableChannel <span class="title">channel</span><span class="params">()</span> <span class="comment">// 得到与之关联的channel</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span> <span class="comment">// 得到与之关联的共享数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> <span class="comment">// 设置或改变监听事件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span> <span class="comment">// 是否可以accept</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> <span class="comment">// 是否可以读</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> <span class="comment">// 是否可以写</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</p><p>相关方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="comment">// 得到一个ServerSocketChannel通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="comment">// 设置服务器端端口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="comment">// 设置阻塞true或非阻塞false模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span> <span class="comment">// 接受一个连接, 返回代表这个连接的通道对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span> <span class="comment">// 注册一个选择器并设置监听事件</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>SocketChannel  是网络IO通道，具体负责进行读写操作。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p><p>相关方法如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="comment">// 得到一个SocketChannel通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="comment">// 设置阻塞true或非阻塞false模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span> <span class="comment">// 连接服务器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span> <span class="comment">// 如果connect失败，用此方法完成连接操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="comment">// 往通道写数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="comment">// 从通道读数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span> <span class="comment">// 注册一个选择器并设置监听事件，最后一个参数设置共享数据</span></span></span><br></pre></td></tr></tbody></table></figure><h1 id="案例：群聊系统"><a href="#案例：群聊系统" class="headerlink" title="案例：群聊系统"></a>案例：群聊系统</h1><ul><li>编写一个 NIO 多人群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能 </li><li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenerChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 得到Selector</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 得到ServerSocketChannel</span></span><br><span class="line">            listenerChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            listenerChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">            listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将该listenChannel注册到 selector</span></span><br><span class="line">            listenerChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">int</span> count = selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">// 有事件处理</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 遍历得到selectionKey集合</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext()) {</span><br><span class="line">                        SelectionKey selectionKey = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) {</span><br><span class="line">                            <span class="comment">// 监听到accept</span></span><br><span class="line">                            <span class="comment">// 获得socketChannel</span></span><br><span class="line">                            SocketChannel socketChannel = listenerChannel.accept();</span><br><span class="line">                            <span class="comment">// 非阻塞</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该socketChannel注册到selector</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">" 已上线"</span>);</span><br><span class="line">                        } <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) {</span><br><span class="line">                            readData(selectionKey);</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey selectionKey)</span> </span>{</span><br><span class="line">        <span class="comment">// 取到关联的socketChannel</span></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 读消息</span></span><br><span class="line">            <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                System.out.println(socketChannel.getRemoteAddress() + <span class="string">" 消息: "</span> + msg);</span><br><span class="line">                sendInfo(socketChannel, msg);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(socketChannel.getRemoteAddress() + <span class="string">" 已下线"</span>);</span><br><span class="line">                <span class="comment">// 取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">// 关闭通道</span></span><br><span class="line">                socketChannel.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向其它的客户端转发消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(SocketChannel selfChannel, String msg)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"开始转发消息"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 遍历所有注册到selector上的socketChannel, 并排除self</span></span><br><span class="line">            <span class="keyword">for</span> (SelectionKey key : selector.keys()) {</span><br><span class="line">                Channel channel = key.channel();</span><br><span class="line">                <span class="keyword">if</span>(channel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel != selfChannel) {</span><br><span class="line">                    <span class="comment">// 将消息写到channel</span></span><br><span class="line">                    ((SocketChannel)channel).write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"转发完成"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        GroupChatServer chatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        chatServer.listener();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">            <span class="comment">// 非阻塞</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将channel注册到selector</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(username + <span class="string">" 准备完毕"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String msg)</span> </span>{</span><br><span class="line">        msg = username + <span class="string">"： "</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMsg</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="comment">// 有可以用的通道</span></span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) {</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) {</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">// 从channel读出消息</span></span><br><span class="line">                        socketChannel.read(buffer);</span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg);</span><br><span class="line">                    }</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    chatClient.readMsg();</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) {</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。&lt;/p&gt;
&lt;p&gt;NIO 三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)。&lt;/p&gt;
&lt;p&gt;NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。&lt;/p&gt;
&lt;p&gt;Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入， 这个线程同时可以去做别的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://haifuns.com/categories/Java/"/>
    
    
    <category term="Java IO" scheme="https://haifuns.com/tags/Java-IO/"/>
    
  </entry>
  
  <entry>
    <title>【Java I/O】BIO、NIO、AIO</title>
    <link href="https://haifuns.com/2020/12/26/java-io/"/>
    <id>https://haifuns.com/2020/12/26/java-io/</id>
    <published>2020-12-26T09:26:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-x2F-O-模型"><a href="#I-x2F-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO 就是传统的<code>java.io</code>包，<strong>同步并阻塞</strong>，基于流模型实现，在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞。</p><ul><li>优点是代码比较简单、直观</li><li>缺点是效率和扩展性很低，容易成为应用性能瓶颈</li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO 是<em>Java 1.4</em>引入的<code>java.nio</code>包，<strong>同步非阻塞</strong>，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 是<em>Java 1.7</em>之后引入的包，是 NIO 的升级版本，<strong>异步非阻塞</strong>，（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><span id="more"></span><h2 id="BIO、NIO、AIO-适用场景分析"><a href="#BIO、NIO、AIO-适用场景分析" class="headerlink" title="BIO、NIO、AIO 适用场景分析"></a>BIO、NIO、AIO 适用场景分析</h2><ul><li>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。</li><li>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。</li><li>AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</li></ul><h2 id="BIO、NIO、AIO-对比表"><a href="#BIO、NIO、AIO-对比表" class="headerlink" title="BIO、NIO、AIO 对比表"></a>BIO、NIO、AIO 对比表</h2><table><thead><tr><th>\</th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO 模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><h2 id="BIO-详解"><a href="#BIO-详解" class="headerlink" title="BIO 详解"></a>BIO 详解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java BIO 就是传统的 java io 编程，其相关的类和接口在 <code>java.io</code>。</p><p>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/io/bio.png" alt="image"></p><ol><li>服务器端启动一个 ServerSocket </li><li>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li><li>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝 </li><li>如果有响应，客户端线程会等待请求结束后，在继续执行</li></ol><h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><ol><li>使用 BIO 模型编写一个服务器端，监听8080 端口，当有客户端连接时，就启动一个线程与之通讯</li><li>使用线程池机制改善，可以连接多个客户端</li><li>服务器端接收客户端发送的数据(telnet 方式即可)</li></ol><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        System.out.println(<span class="string">"server start"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听, 等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();;</span><br><span class="line">            System.out.println(<span class="string">"client connect, thread: "</span>+ Thread.currentThread());</span><br><span class="line"></span><br><span class="line">            executorService.execute(() -&gt; handler(socket));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过socket获取输入流</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = socket.getInputStream()) {</span><br><span class="line">            <span class="comment">// 循环读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) {</span><br><span class="line">                    System.out.println(<span class="string">"receive message: "</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span> , read) + <span class="string">", thread: "</span>+ Thread.currentThread());</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"client close, thread: "</span>+ Thread.currentThread());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>cmd 窗口使用 telnet 127.0.0.1 8080 创建连接，输入ctrl+]，输入send <message> 发送消息测试</message></p><h3 id="BIO-问题分析"><a href="#BIO-问题分析" class="headerlink" title="BIO 问题分析"></a>BIO 问题分析</h3><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据Read ，业务处理，数据 Write</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</li></ul><h2 id="NIO-详解"><a href="#NIO-详解" class="headerlink" title="NIO 详解"></a>NIO 详解</h2><p>见下一篇<a href="https://haifuns.com/2020/12/26/java-nio/">【Java I/O】NIO 详解</a></p><h2 id="AIO-介绍"><a href="#AIO-介绍" class="headerlink" title="AIO 介绍"></a>AIO 介绍</h2><p>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。</p><p>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><p>目前 AIO 还没有广泛应用，Netty 也是基于 NIO, 而不是 AIO。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;I-x2F-O-模型&quot;&gt;&lt;a href=&quot;#I-x2F-O-模型&quot; class=&quot;headerlink&quot; title=&quot;I/O 模型&quot;&gt;&lt;/a&gt;I/O 模型&lt;/h2&gt;&lt;h3 id=&quot;BIO&quot;&gt;&lt;a href=&quot;#BIO&quot; class=&quot;headerlink&quot; title=&quot;BIO&quot;&gt;&lt;/a&gt;BIO&lt;/h3&gt;&lt;p&gt;BIO 就是传统的&lt;code&gt;java.io&lt;/code&gt;包，&lt;strong&gt;同步并阻塞&lt;/strong&gt;，基于流模型实现，在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点是代码比较简单、直观&lt;/li&gt;
&lt;li&gt;缺点是效率和扩展性很低，容易成为应用性能瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h3&gt;&lt;p&gt;NIO 是&lt;em&gt;Java 1.4&lt;/em&gt;引入的&lt;code&gt;java.nio&lt;/code&gt;包，&lt;strong&gt;同步非阻塞&lt;/strong&gt;，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。&lt;/p&gt;
&lt;h3 id=&quot;AIO&quot;&gt;&lt;a href=&quot;#AIO&quot; class=&quot;headerlink&quot; title=&quot;AIO&quot;&gt;&lt;/a&gt;AIO&lt;/h3&gt;&lt;p&gt;AIO 是&lt;em&gt;Java 1.7&lt;/em&gt;之后引入的包，是 NIO 的升级版本，&lt;strong&gt;异步非阻塞&lt;/strong&gt;，（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://haifuns.com/categories/Java/"/>
    
    
    <category term="Java IO" scheme="https://haifuns.com/tags/Java-IO/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：性能监控与故障处理工具</title>
    <link href="https://haifuns.com/2020/12/26/jvm-6/"/>
    <id>https://haifuns.com/2020/12/26/jvm-6/</id>
    <published>2020-12-26T09:23:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h2><h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>（JVM Process Status Tool），主要用来输出JVM中运行的进程状态信息。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出进程id，省略主类信息</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类全名，如果进程执行的是jar包，输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的JVM参数</td></tr></tbody></table><span id="more"></span><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>（JVM Statistics Monitoring Tool），虚拟机统计监测工具，查看各个区域内存和GC情况。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></tbody></table></figure><p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。</p><p>选项option可查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。<br>详细参考下表：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类装载耗时。</td></tr><tr><td>-gc</td><td>监视堆状况，包括Eden区、两个Survivor、老年代、永久代等的容量，已用时间，垃圾收集时间合计等信息。</td></tr><tr><td>-gccapacity</td><td>（同-gc），输出各个区域最大、最小空间。</td></tr><tr><td>-gcutil</td><td>（同-gc），输出已使用空间占总空间百分比。</td></tr><tr><td>-gccause</td><td>（同-gcutil），输出上一次垃圾回收原因。</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集状况。</td></tr><tr><td>-gcnewcapacity</td><td>（同-gcnew），输出最大、最小空间。</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况。</td></tr><tr><td>-gcoldcapacity</td><td>（同-gcnew），输出最大、最小空间。</td></tr><tr><td>-gcpermcapacity</td><td>输出永生代最大、最小空间。</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法、耗时等信息。</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法。</td></tr></tbody></table><h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>（Configuration Info for Java），实时查看和调整虚拟机各项参数。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-flag</td><td>输出指定args参数的值</td></tr><tr><td>-flags</td><td>不需要args参数，输出所有JVM参数的值</td></tr><tr><td>-sysprops</td><td>输出系统属性，等同于System.getProperties()</td></tr></tbody></table><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>（Memory Map for Java），用来查看堆内存使用情况。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转储快照，格式为-dump:[live,]format=b,file=<filename>，其中live子参数说明是否只dump出存活的对象</filename></td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合集容量</td></tr><tr><td>-permstat</td><td>以ClassLoader为统计口径显示永久代内存状态，只在Linux/Solaris平台下有效</td></tr><tr><td>-F</td><td>-dump无响应时强制生成dump快照，只在Linux/Solaris平台下有效</td></tr></tbody></table><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>（JVM Heap Analysis Tool），与jmap搭配使用，用来分析jmap生成的堆转储快照。</p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>（Stack Trace for Java），主要用来查看Java进程内的线程堆栈信息。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法，可以显示C/C++的堆栈</td></tr></tbody></table><h2 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h2><ul><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr009.html">JConsole：Java监视与管理控制台</a></p></li><li><p><a href="http://visualvm.github.io/">VisualVM：多合-故障处理工具</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开启 JFR 收集: 由于JFR是商用的，所以需要解锁Java程序的商业feature:</span><br><span class="line">-XX:+UnlockCommercialFeatures -XX:+FlightRecorder # JDK 1.8u40之前版本，需再jvm启动前添加参数</span><br><span class="line"></span><br><span class="line"># 检查标志位 </span><br><span class="line">jcmd &lt;pid&gt; VM.unlock_commercial_features</span><br><span class="line"></span><br><span class="line"># JDK 1.8u40之后版本，不需要在启动的时候通过flag来解锁了，可以动态的解锁</span><br><span class="line">jcmd &lt;pid&gt; VM.check_commercial_features</span><br><span class="line">jcmd &lt;pid&gt; JFR.start delay=10s duration=1m filename=xxx.jfr</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://www.oracle.com/java/technologies/jdk-mission-control.html">Java Mission Control：可持续在线的监控工具</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础故障处理工具&quot;&gt;&lt;a href=&quot;#基础故障处理工具&quot; class=&quot;headerlink&quot; title=&quot;基础故障处理工具&quot;&gt;&lt;/a&gt;基础故障处理工具&lt;/h2&gt;&lt;h3 id=&quot;jps：虚拟机进程状况工具&quot;&gt;&lt;a href=&quot;#jps：虚拟机进程状况工具&quot; class=&quot;headerlink&quot; title=&quot;jps：虚拟机进程状况工具&quot;&gt;&lt;/a&gt;jps：虚拟机进程状况工具&lt;/h3&gt;&lt;p&gt;（JVM Process Status Tool），主要用来输出JVM中运行的进程状态信息。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jps [ options ] [ hostid ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;-q&lt;/td&gt;
&lt;td&gt;只输出进程id，省略主类信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;输出虚拟机进程启动时传递给主类main()函数的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;输出主类全名，如果进程执行的是jar包，输出jar路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;输出虚拟机进程启动时的JVM参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：高效并发</title>
    <link href="https://haifuns.com/2020/12/26/jvm-5/"/>
    <id>https://haifuns.com/2020/12/26/jvm-5/</id>
    <published>2020-12-26T09:22:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>内存模型: 在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p><p>Java内存模型主要关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型规定：</p><ul><li>所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本。</li><li>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。</li><li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</li></ul><span id="more"></span><p>线程、主内存、工作内存三者的交互关系如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/JavaMemoryModel.png" alt="image"></p><p>这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。</p><h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h3><p>Java内存模型定义了8种操作来实现内存间交互，Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。</p><ul><li>lock（锁定）：作用于主内存变量，把变量标识为线程独占。</li><li>unlock（解锁）：作用于主内存变量，把处于锁定状态的变量释放，释放后的变量可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，把变量值从主内存传输到线程工作内存中。</li><li>load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，把从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中变量的值传送到主内存中。</li><li>write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>内存间的交互操作如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/MemoryInteraction.png" alt="image"></p><h3 id="内存间的交互操作规则"><a href="#内存间的交互操作规则" class="headerlink" title="内存间的交互操作规则"></a>内存间的交互操作规则</h3><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。以上两个操作必须按顺序执行，但是不保证连续执行，其间可以插入其他指令。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul><h3 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，volatile修饰的变量具备两项特性：</p><ul><li>保证此变量对所有线程的可见性。即对volatile变量所做的写操作能立刻反应到其他线程中。volatile修饰的变量在多线程环境下仍然是不安全的。</li><li>volatile禁止指令重排序。</li></ul><p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁<br>（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p><ul><li>运算结果不依赖变量的当前值，或者能确保只有一个线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h3 id="long和double型变量的特殊规则"><a href="#long和double型变量的特殊规则" class="headerlink" title="long和double型变量的特殊规则"></a>long和double型变量的特殊规则</h3><p>Java内存模型要求内存间交互的八种操作都具有原子性，但是对于64位的数据类型（long和double），允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“long和double的非原子性协定”。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>指令重排序是指JVM为了优化，在条件允许的情况下，对指令进行一定的重新排序，直接运行当前能够立刻执行的后续指令，避开获取下一条指令所需数据造成的等待。</p><p>不是所有的指令都能重排，比如：</p><ul><li>写后读，a = 1; b = a; 写一个变量后再读这个位置。</li><li>写后写，a = 1; a = 2; 写一个变量后，再写这个变量。</li><li>读后写，a = b; b = 1; 读一个变量后，再写这个变量。</li></ul><p>指令重排序基本原则：</p><ul><li>程序顺序原则：一个线程内保证语义串行性</li><li>volatile规则：volatile变量的写先发生于读</li><li>锁规则：解锁（unlock）必然发生在随后的加锁（lock）前</li><li>传递性：操作A先于操作B，操作B先于操作C 那么操作A必然先于操作C</li><li>线程启动规则：线程的start方法先于它的每一个动作</li><li>线程终止规则：线程的所有操作先于线程的终结（Thread.join()）</li><li>线程中断规则：线程的中断（interrupt()）先于被中断的代码</li><li>对象终结规则：对象的构造函数执行结束先于finalize()方法</li></ul><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定）。</p><h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p><p>保证可见性的常见方法：volatile、synchronized、final（一旦初始化完成，其他线程可见）</p><h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>实现线程主要有三种方式：使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程混合实现（N：M实现）。</p><h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>使用内核线程实现的方式也被称为1：1实现。内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核（Multi-Threads Kernel）。</p><p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型，如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/KLT-Thread.png" alt="image"></p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</p><p>局限性：</p><ul><li>由于是基于内核线程实现的，各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。</li><li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</li></ul><h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>使用用户线程实现的方式被称为1：N实现。狭义上，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/UT-Thread.png" alt="image"></p><ul><li>优势：不需要切换到内核态，操作快速、低消耗，支持大规模线程数。</li><li>劣势：没有系统内核支援，线程操作需要用户自行处理，实现复杂。</li></ul><h4 id="用户线程加轻量级进程混合实现"><a href="#用户线程加轻量级进程混合实现" class="headerlink" title="用户线程加轻量级进程混合实现"></a>用户线程加轻量级进程混合实现</h4><p>将内核线程与用户线程一起使用的实现方式，被称为N：M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。</p><p>用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/MN-Thread.png" alt="image"></p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。</p><h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。</p><ul><li>优点：实现简单，一般没有线程同步问题。Lua语言中的“协同例程”就是这类实现。</li><li>缺点：线程执行时间不可控制，有可能造成程序一直阻塞。</li></ul><h4 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h4><p>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。例如，Java中Thread::yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。</p><p>Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。主流虚拟机上的Java线程被映射到系统的原生线程上来实现的，线程调度最终还是由操作系统说了算，线程优先级并不能保证稳定调节。</p><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p><ul><li>新建（New）：创建后尚未启动。</li><li>运行（Runnable）：包括操作系统线程状态中的Running和Ready，线程正在执行或等待操作系统为其分配执行时间。</li><li>无限期等待（Waiting）：等待被其他线程显式唤醒，不会被分配处理器执行时间。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置Timeout参数的Object::wait()方法；</li><li>没有设置Timeout参数的Thread::join()方法；</li><li>LockSupport::park()方法。</li></ul></li><li>限期等待（Timed Waiting）：无须等待被其他线程显式唤醒，在一定时间之后由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul><li>Thread::sleep()方法；</li><li>设置了Timeout参数的Object::wait()方法；</li><li>设置了Timeout参数的Thread::join()方法；</li><li>LockSupport::parkNanos()方法；</li><li>LockSupport::parkUntil()方法。</li></ul></li><li>阻塞（Blocked）：线程被阻塞，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li><li>结束（Terminated）：线程已结束执行。</li></ul><p>线程状态转换关系如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/Thread-status.png" alt="image"></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>Java线程安全的处理方法：</p><ol><li>不可变的对象一定是线程安全的。</li><li>互斥同步（阻塞同步）：synchrized/java.util.concurrent.ReentrantLock。目前两者性能相差不大，建议优先选用synchrized，ReentrantLock增加了如下特性：<ul><li>等待可中断：当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待。</li><li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点。</li><li>一个ReentrantLock对象可以同时绑定多个Condition对象。而synchronized是针对一个条件的，如果要多个就需要有多个锁。</li></ul></li><li>非阻塞同步： 基于冲突检查的乐观锁定策略，通常是先进行操作，如果没有冲突，操作就直接成功；如果共享数据被争用产生冲突，再进行其他补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。</li><li>无同步方案：在多线程中，方法并不涉及共享数据，自然也就无需同步。</li></ol><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><ul><li>自旋：如果线程可以很快获得锁，那么可以不在OS层挂起线程，而是让线程做几个忙循环。</li><li>自适应自旋：自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间和锁的拥有者决定。</li></ul><p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但是要占用处理器时间，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，这就会带来性能的浪费。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</p><p>通过-XX:+EliminateLocks开启锁消除。同时使用-XX:+DoEscapeAnalysis开启逃逸分析。</p><p>逃逸分析：</p><ul><li>如果一个方法中定义的一个对象，可能被外部方法引用，称为方法逃逸。</li><li>如果对象可能被其他外部线程访问，称为线程逃逸。比如赋值给类变量或者在其他线程中访问的实例变量。</li></ul><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，推荐将同步块的作用范围限制得尽量小，即只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p><p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗，这种情况建议把锁同步的范围扩大到整个操作序列。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言，设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>先进行回忆HotSpot虚拟机对象的内存布局（尤其是对象头部分）：<br><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/markword.png" alt="image"></p><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ul><li>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word）。</li><li>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。<ul><li>如果更新成功，则获取对象轻量级锁成功，对象Mark Word的锁标志位将转变为“00”。</li><li>如果失败，则说明锁已被抢占，轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</li></ul></li></ul><h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><ul><li>如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。<ul><li>如果成功替换，那整个同步过程就顺利完成了；</li><li>如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li></ul></li></ul><blockquote><p>“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。如果没有竞争，轻量级锁便通过CAS操作避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁目的是消除数据在无竞争情况下的同步，从而提高性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做。</p><h4 id="加锁过程-1"><a href="#加锁过程-1" class="headerlink" title="加锁过程"></a>加锁过程</h4><ul><li>当锁对象第一次被线程获取时，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。</li><li>同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。</li><li>如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。</li></ul><h4 id="解锁过程-1"><a href="#解锁过程-1" class="headerlink" title="解锁过程"></a>解锁过程</h4><p>当有其他线程请求相同锁时，偏向模式结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态。</p><blockquote><p>如果程序中大多数锁总是被多个线程访问的时候，也就是竞争比较激烈，偏向锁反而会降低性能。使用参数-XX:-UseBiasedLocking 禁止偏向锁，默认开启。</p></blockquote><h3 id="JVM中获取锁的步骤"><a href="#JVM中获取锁的步骤" class="headerlink" title="JVM中获取锁的步骤"></a>JVM中获取锁的步骤</h3><ul><li>先尝试偏向锁</li><li>然后尝试轻量级锁</li><li>再尝试自旋锁</li><li>最后尝试普通锁，使用OS互斥量在操作系统层挂起</li></ul><h3 id="同步代码的基本规则"><a href="#同步代码的基本规则" class="headerlink" title="同步代码的基本规则"></a>同步代码的基本规则</h3><ul><li>尽量减少锁持有时间</li><li>尽量减少锁的粒度</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;p&gt;内存模型: 在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。&lt;/p&gt;
&lt;p&gt;Java内存模型主要关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。&lt;/p&gt;
&lt;h3 id=&quot;主内存与工作内存&quot;&gt;&lt;a href=&quot;#主内存与工作内存&quot; class=&quot;headerlink&quot; title=&quot;主内存与工作内存&quot;&gt;&lt;/a&gt;主内存与工作内存&lt;/h3&gt;&lt;p&gt;Java内存模型规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用的变量的主内存副本。&lt;/li&gt;
&lt;li&gt;线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。&lt;/li&gt;
&lt;li&gt;不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：垃圾回收</title>
    <link href="https://haifuns.com/2020/12/26/jvm-4/"/>
    <id>https://haifuns.com/2020/12/26/jvm-4/</id>
    <published>2020-12-26T09:20:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收?"></a>哪些内存需要回收?</h2><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）了。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><ul><li>优点：实现简单。效率高</li><li>缺点：不能解决对象之间的循环引用的问题</li></ul><span id="more"></span><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列称为“GC Roots”的根对象作为起始节点集，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/ReachabilityAnalysis.png" alt="image"></p><p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p><p>固定可作为GC Roots的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h2 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h2><p>Java引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li><p>强引用，类似“Object obj = new Object()”这种引用关系。只要强引用关系还存在，就不会被回收。</p></li><li><p>软引用，还有用但不必须的对象。用SoftReference类来实现软引用。被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。</p></li><li><p>弱引用，非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。用WeakReference类来实现弱引用。</p></li><li><p>虚引用，也称为“幽灵引用”或者“幻影引用”，是最弱的引用关系。垃圾回收时被回收，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。用PhantomReference类来实现虚引用。</p></li></ul><h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>在HotSpot里，使用一组称为OopMap的数据结构来达到准确式GC的目的。在类加载完成时，HotSpot就会把对象内所有类型数据得偏移量计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。在扫描时就可以直接得知这些信息，并不需要真正从方法区等GC Roots开始查找。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间。HotSpot实际上也没有为每条指令生成OopMap，而是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停进行GC。</p><p>安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p><p>在垃圾收集发生时让所有线程（不包括执行JNI调用的线程）都到最近的安全点，然后停顿下来，有两种方案：</p><ol><li>抢先式中断（Preemptive Suspension）<ul><li>不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</li></ul></li><li>主动式中断（Voluntary Suspension）<ul><li>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li></ul></li></ol><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>如果在一段代码中，对象引用关系不会发生变化，在这个区域任意地方开始GC都是安全的，那么称这个区域为安全区域（Safe Region）。</p><p>当用户线程执行到安全区域里面的代码时：</p><p>首先会标识自己已经进入了安全区域，当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</p><p>当线程要离开安全区域时：</p><p>它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）</p><ul><li>如果完成了，那线程就继续执行；</li><li>否则就必须一直等待，直到收到可以离开安全区域的信号为止。</li></ul><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><p>可供选择（当然也可以选择这个范围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>卡表（Card Table）是记忆集的一种具体实现，定义了记忆集的记录精度和与堆内存的映射关系等。卡表每个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块称为卡页（Card Page）。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态。写屏障可以看做成JVM对“引用类型字段赋值”这个动作的AOP。</p><h2 id="GC-分类"><a href="#GC-分类" class="headerlink" title="GC 分类"></a>GC 分类</h2><ul><li>MinorGC / YoungGC ：发生在新生代的收集动作</li><li>MajorGC / OldGC ：发生在老年代的GC，目前只有CMS收集器会有单独收集老年代的行为</li><li>MixedGC ：收集整个新生代以及部分老年代，目前只有G1收集器会有这种行为</li><li>FullGC ：收集整个Java堆和方法区的GC</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>标记 - 清除（Mark-Sweep）算法，区分为“标记”和“清除”两个阶段：</p><ul><li>标记出所有需要回收的对象</li><li>标记完成后统一回收被标记的对象</li></ul><p>优点：</p><ul><li>简单，是最基础的收集算法，后续算法是基于这种思路并对其不足进行改进而得到的。</li></ul><p>缺点：</p><ul><li>标记和清除效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，从而导致分配大对象时触发GC</li></ul><p>标记 - 清除算法执行过程如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/mark-sweep.png" alt="image"></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h3><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，“半区复制”（Semispace Copying）的垃圾收集算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完时，将还存活的对象复制到另一块上去，然后把已经使用过的内存一次清理掉。</p><p>优点：</p><ul><li>内次都是对整个半区回收，内存分配不需要考虑内存碎片问题，只要移动堆顶指针顺序分配内存即可，实现简单，运行高效。</li></ul><p>缺点：</p><ul><li>内存缩小一半，代价高。</li></ul><p>标记 - 复制算法执行过程如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/copying.png" alt="image"></p><p>HotSpot虚拟机的Serial、ParNew等新生代收集器中：</p><p>把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。</p><p>发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。<br>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%）。但是当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p><p>分配担保：</p><p>当新生代进行垃圾回收后，新生代的存活区存放不下，那么需要把这些对象放置到老年代的策略，也就是老年代为新生代的GC做空间分配担保，步骤如下：</p><ol><li>在发生MinorGC前，JVM会检查老年代的最大可用连续空间是否大于新生代所有对象总空间，如果大于，可以确保MinorGC是安全。</li><li>如果小于，那么JVM会检查是否设置允许担保失败，如果允许，那么继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</li><li>2基础上，如果大于历次平均大小，则尝试进行一次MinorGC</li><li>2基础上，如果小于于历次平均大小，则改做一次FullGC</li></ol><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不直接选用标记-复制算法而使用标记-整理算法。</p><p>标记-清除算法与标记-整理算法标记过程相同，但后续不是直接清除可回收对象，而是让所有存活对象向一端移动，然后直接清除边界以外的内存。</p><p>标记 - 整理算法执行过程如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/mark-compact.png" alt="image"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/GarbageCollector.png" alt="image"></p><p>如图所示，七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用（由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃，并在JDK 9中完全取消了这些组合的支持），图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial收集器是最基础、历史最悠久的收集器。在JDK 1.3.1 之前，Serial是HotSpot虚拟机新生代收集器的唯一选择。Serial是一个单线程工作的收集器，“单线程”并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，还必须暂停其他所有工作线程（Stop The World），直到它收集结束。</p><p>优点：</p><ul><li>简单高效，内存消耗小，对于单核处理器或处理器核心数较少的环境，由于没有多线程交互开销，垃圾回收收集效率更高。是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。</li></ul><p>开启参数：-XX:+UseSerialGC，使用Serial + Serial Old收集器组合</p><p>Serial/Serial Old收集器的运行过程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/Serial.png" alt="image"></p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之<br>外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上也共用了相当多的代码。</p><p>并行收集器在并发能力好的处理器环境，停顿的时间要比串行收集器短，但是但对于单核或核心数较少的处理器环境，由于多线程开销，可能比串行收集器差。</p><p>ParNew 收集器是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>开启参数：-XX:+UseParNewGC，默然开启收集线程数与 CPU 数量相同，可以使用 -XX:+ParallelGCThreads 参数限制垃圾收集线程数</p><p>ParNew 收集器的运行过程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/ParNew.png" alt="image"></p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。</p><p>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = \dfrac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间}</span><br></pre></td></tr></tbody></table></figure><p>参数设置：</p><ul><li>-XX:MaxGCPauseMillis 设置GC最大停顿时间（毫秒）</li><li>-XX:GCTimeRatio 设置吞吐量大小</li></ul><p>Parallel Scavenge 收集器的运行过程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/ParallelScavenge.png" alt="image"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。</p><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；</p><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</p><p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</p><p>最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p><p>优点： </p><ul><li>低停顿、并发执行</li></ul><p>缺点：</p><ul><li>并发执行，对CPU资源压力大</li><li>无法处理在处理过程中产生的垃圾，可能导致FullGC</li><li>采用的标记-清除算法会导致大量碎片，在分配大对象时可能触发FullGC</li></ul><p>参数：</p><ul><li>-XX:+UseConcMarkSweepGC 使用ParNew + CMS + Serial Old的收集器组合，Serial Old将作为CMS出错后的后备收集器</li><li>-XX:CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发回收，默认80%</li></ul><p>CMS 收集器的运行过程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/CMS.png" alt="image"></p><h3 id="Garbage-First-收集器"><a href="#Garbage-First-收集器" class="headerlink" title="Garbage First 收集器"></a>Garbage First 收集器</h3><p>G1（Garbage First）是一款主要面向服务端应用的垃圾收集器。与其他收集器相比，具有以下特点：</p><ol><li>G1把内存划分成多个独立的区域（Region），最多2048个Region，Java 8u20以后上限为4096个</li><li>G1仍采用分代思想，保留了新生代和老年代，但是不再是物理隔离，而是一部分Region集合，且不需要Region是连续的，Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</li><li>G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部使用复制算法，不会产生内存碎片</li><li>G1停顿可预测，能明确指定在一段时间内，消耗在垃圾收集上的最大时间</li><li>G1跟踪各个Region里面的垃圾价值大小，在后台维护优先列表，每次根据允许的时间回收价值最大的区域，从而保证在有限时间内高效收集</li></ol><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/G1-Region.png" alt="image"></p><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><ul><li>初始标记（Initial Marking）：</li></ul><p>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p><ul><li>并发标记（Concurrent Marking）：</li></ul><p>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p><ul><li>最终标记（Final Marking）：</li></ul><p>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p><ul><li>筛选回收（Live Data Counting and Evacuation）：</li></ul><p>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p><p>G1 收集器的运行过程如下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/G1.png" alt="image"></p><p>开启参数：-XX:+UseG1GC 开启G1 JDK9开始默认开启</p><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>ZGC是Java 11引入的低延迟垃圾收集器，经过了多个实验阶段，自Java 15成为正式特性。</p><p>ZGC是一个重新设计的并发的垃圾回收器，可以极大的提升GC的性能。支持任意堆大小而保持稳定的低延迟（10ms以内），性能非常可观。</p><p>打开参数：-XX:+UseZGC</p><h2 id="GC-性能指标"><a href="#GC-性能指标" class="headerlink" title="GC 性能指标"></a>GC 性能指标</h2><ul><li>吞吐量 = 运行用户代码时间 / 运行总时间</li><li>GC复核，与吞吐量相反，是GC时间 / 运行总时间</li><li>GC频率，GC在一段时间发生的次数</li><li>暂停时间，就是Stop The World的总时间</li><li>反应速度，从对象成为垃圾到被回收的时间</li></ul><h2 id="JVM内存配置原则"><a href="#JVM内存配置原则" class="headerlink" title="JVM内存配置原则"></a>JVM内存配置原则</h2><ol><li><p>新生代尽可能设置大，设置太小可能会导致：</p><ul><li>YGC次数频繁</li><li>可能导致YGC后的对象进入老年代，从而触发FGC</li></ul></li><li><p>对于老年代：</p><ul><li>针对响应时间优先的应用，由于老年代通常采用并发收集器，因此其大小设置要综合考虑并发量和并发持续时间等参数<ul><li>如果设置过小，可能造成内存碎片，高回收频率会导致应用暂停</li><li>如果设置过大，会需要较长的回收时间</li></ul></li><li>针对吞吐量优先的应用，通常设置较大的新生代和较小的老年代，尽可能回收大部分短期对象，减少中期对象，而老年代尽可能存放长期存活的对象</li></ul></li><li><p>依据对象的存活周期分类，对象优先在新生代分配，长时间存活的对象进入老年代</p></li><li><p>根据不同代的特点，选取合适的收集算法：少量对象存活，适合复制算法；大量对象存活，适合标记清除或标记整理算法</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哪些内存需要回收&quot;&gt;&lt;a href=&quot;#哪些内存需要回收&quot; class=&quot;headerlink&quot; title=&quot;哪些内存需要回收?&quot;&gt;&lt;/a&gt;哪些内存需要回收?&lt;/h2&gt;&lt;p&gt;垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）了。&lt;/p&gt;
&lt;h3 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h3&gt;&lt;p&gt;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：实现简单。效率高&lt;/li&gt;
&lt;li&gt;缺点：不能解决对象之间的循环引用的问题&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：字节码执行引擎</title>
    <link href="https://haifuns.com/2020/12/26/jvm-3/"/>
    <id>https://haifuns.com/2020/12/26/jvm-3/</id>
    <published>2020-12-26T09:19:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JVM字节码执行引擎功能基本上就是输入字节码文件，然后对字节码进行解析并处理，最后输出执行结果。实现方式可能有通过解释器直接解释执行字节码，或者通过即时编译器产生本地代码，也就是编译执行，也可能两者皆有。</p><span id="more"></span><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧是用于支持JVM进行方法调用和方法执行的数据结构，栈帧随方法调用创建，方法结束销毁。栈帧中存储方法局部变量表、操作数栈、动态连接、方法返回地址等信息。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/stackframe.png" alt="image"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表用来存放方法参数和方法内部定义的局部变量存储空间。</p><ul><li>以变量槽slot为单位，目前一个slot存放32位以内的数据类型</li><li>对于64位数占两个slot</li><li>对于实例方法，第0位slot存放this，然后从1到n，依次分配给参数列表</li><li>根据方法体内部定义的变量顺序和作用域分配slot</li><li>slot是复用的，以节省栈帧空间，这种设计可能会影响系统垃圾回收行为</li></ul><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>后入先出栈，操作数栈用来存放运行期间，各个指令操作的数据。</p><ul><li>操作数栈中元素的数据类型必须和字节码指令的顺序严格匹配</li><li>虚拟机在实现栈帧的时候可能会做一些优化，让两个栈帧出现部分重叠区域，用来存放公共数据</li></ul><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧持有一个指向运行时常量池中该栈帧所属方法的引用，以支持方法调用过程的动态连接</p><h4 id="静态解析"><a href="#静态解析" class="headerlink" title="静态解析"></a>静态解析</h4><p>类加载时或第一次使用时，符号引用就转换成直接引用</p><h4 id="动态连接-1"><a href="#动态连接-1" class="headerlink" title="动态连接"></a>动态连接</h4><p>运行期间转换为直接引用</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法执行返回的地址，当一个方法开始执行后，只有两种方式可以退出这个方法。</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令，是否有返回值和返回值类型根据遇到何种方法返回指令决定，这种退出方法简称正常完成出口</p></li><li><p>在方法的执行过程中遇到了异常，并且异常没有在方法体中处理，这种退出方法简称异常完成出口</p></li></ol><p>无论何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用就是确定调用方法的版本即调用哪一个方法，不涉及方法内部执行过程</p><ul><li>解析调用：部分方法是直接在类加载解析阶段就确定了直接引用关系</li><li>分派调用：对于实例方法，也称虚方法，因为重载和多态，需要在运行期动态委派</li></ul><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>所有依赖静态类型来定位方法执行版本的分派信息，比如：重载方法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 方法静态分派演示</span><br><span class="line"> */</span><br><span class="line">public class StaticDispatch {</span><br><span class="line"></span><br><span class="line">    static abstract class Human{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    static class Man extends Human{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    static class Women extends Human{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public  void sayHello(Human guy){</span><br><span class="line">        System.out.println("hello human");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public  void sayHello(Man guy){</span><br><span class="line">        System.out.println("hello man");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public  void sayHello(Women guy){</span><br><span class="line">        System.out.println("hello women");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args){</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human women = new Women();</span><br><span class="line">        StaticDispatch sr = new StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(women);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello human</span><br><span class="line">hello human</span><br></pre></td></tr></tbody></table></figure><p>Human man = new Man() 这行代码中的我们把这行代码中“Human”称为变量的静态类型，后面的Man称为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下面的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实际类型变化</span><br><span class="line">Human human = (new Random()).nextBoolean() ? new Man() : new Woman();</span><br><span class="line">// 静态类型变化</span><br><span class="line">sr.sayHello((Man)man);</span><br><span class="line">sr.sayHello((Women)man);</span><br></pre></td></tr></tbody></table></figure><p>对象human的实际类型是可变的，编译期间到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>根据运行期的实际类型来定位方法执行版本的分派方式，比如：覆盖方法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 方法动态分派演示</span><br><span class="line">*/</span><br><span class="line">public class DynamicDispatch {</span><br><span class="line">    static abstract class Human {</span><br><span class="line">        protected abstract void sayHello();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    static class Man extends Human {</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() {</span><br><span class="line">            System.out.println("man say hello");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    static class Woman extends Human {</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() {</span><br><span class="line">            System.out.println("woman say hello");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></tbody></table></figure><p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？</p><p>这就要从invokevirtual指令入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找。根据《Java虚拟机规范》，<br>invokevirtual指令的运行时解析过程大致分为以下几步：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果<br>通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><p>invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><p>方法的接受者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择。多分派则是根据多于一个宗量对目标方法选择。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;JVM字节码执行引擎功能基本上就是输入字节码文件，然后对字节码进行解析并处理，最后输出执行结果。实现方式可能有通过解释器直接解释执行字节码，或者通过即时编译器产生本地代码，也就是编译执行，也可能两者皆有。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：内存分配</title>
    <link href="https://haifuns.com/2020/12/26/jvm-2/"/>
    <id>https://haifuns.com/2020/12/26/jvm-2/</id>
    <published>2020-12-26T09:17:00.000Z</published>
    <updated>2025-02-23T13:53:31.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/jvm.png" alt="image"></p><span id="more"></span><h3 id="程序计数器-x2F-PC寄存器"><a href="#程序计数器-x2F-PC寄存器" class="headerlink" title="程序计数器/PC寄存器"></a>程序计数器/PC寄存器</h3><p><code>线程私有</code>，程序计数器是一块较小的内存空间，当前线程所执行的字节码的行号指示器。</p><p>字节码解释器工作时就是通过改变计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p><p>如果线程在执行java方法，计数器记录的是正在执行的虚拟机字节码指令地址。如果执行的是Native方法，计数器值为空。</p><p>此内存区域是唯一一个在Java虚拟器规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><code>线程私有</code>，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧。</p><p>栈帧用于储存局部变量表、操作数栈、常量池指针、动态链接、方法返回值等信息。每个方法的调用到完成对应着栈帧在虚拟机栈中的入栈到出栈。</p><p>每一次方法调用创建一个帧，并压栈，退出方法时，修改栈顶指针就可以把栈帧中的内容销毁。</p><p>局部变量表存放了编译期可知的各种基本数据类型和引用数据类型，每个slot(插槽)存放32位的数据，long、double占两个槽位。</p><p>栈的优点：存取速度比堆快，仅次于寄存器</p><p>栈的缺点：存在栈中的数据大小、生存期是在编译器决定的，缺乏灵活性</p><p>此区域可能出现的两种异常：</p><ul><li>如果出现方法递归调用出现死循环的话就会造成栈帧过多：抛出StackOverflowError异常</li><li>线程请求的栈深度大于虚拟机所允许的深度：抛出StackOverflowError异常</li><li>扩展时无法申请到足够内存：抛出OutOfMemoryError异常</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>作用与虚拟机栈相似，区别是虚拟机栈为虚拟机执行的Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用的Native方法服务。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p><code>线程共享区域</code>，是整个虚拟机内存中最大的一块。在虚拟机启动时创建，用于存放对象实例。</p><p>垃圾收集器管理的主要区域，从垃圾回收角度看，由于现在收集器基本采用分代回收算法,Java堆可细分为：<code>新生代</code>和<code>老年代</code>；再细致有<code>Eden</code>空间、<code>From Survivor</code>空间、<code>To Survivor</code>空间等。</p><p>堆的优点：运行期动态分配内存大小，自动进行垃圾回收</p><p>堆的缺点：效率相对较慢</p><p>可利用参数 <code>-Xms</code> <code>-Xmx</code> 进行堆内存控制。</p><p>此区域可能出现的异常：</p><ul><li>如果堆中没有完成实例分配，并且堆无法扩展：抛出OutOfMemoryError异常</li></ul><h3 id="方法区-JDK1-7"><a href="#方法区-JDK1-7" class="headerlink" title="方法区(JDK1.7)"></a>方法区(JDK1.7)</h3><p><code>线程共享区域</code>，方法区主要用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。 这块区域也被称为永久代。</p><p>可利用参数 <code>-XX:PermSize</code> <code>-XX:MaxPermSize</code> 控制初始化方法区和最大方法区大小。</p><p>此区域可能出现的异常：</p><ul><li>当方法区无法满足内存分配需求时：抛出OutOfMemoryError异常</li></ul><h3 id="元数据区-JDK1-8"><a href="#元数据区-JDK1-8" class="headerlink" title="元数据区(JDK1.8)"></a>元数据区(JDK1.8)</h3><p>在 JDK1.8 中已经移除了方法区（永久代），并使用了一个元数据区域进行代替（Metaspace）。</p><p>默认情况下元数据区域会根据使用情况动态调整，避免了在 1.7 中由于加载类过多从而出现 java.lang.OutOfMemoryError: PermGen。但也不能无线扩展，因此可以使用 <code>-XX:MaxMetaspaceSize</code>来控制最大内存。</p><p>元数据区由一个或多个虚拟空间（Virtual Space）组成。虚拟空间是操作系统的连续存储空间，是按需分配的。当被分配时向操作系统预留空间，但是没有提交。</p><p>元数据区的预留空间（reserve）指全部虚拟空间，虚拟空间的最小分配单元是Chunk，当新的Chunk被分配到虚拟空间时，与Chunk相关的内存空间会被提交（committed），元数据区的提交区域（committed）指所有Chunk占有空间。<br>每个Chunk占据空间不同，当一个类加载器被回收时，与之关联的Chunk会被释放（freed）。元数据区的容量（capacity）指所有未被释放的Chunk占据的空间。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。是Class文件中每个类或接口的常量池表，在运行期间的表示形式，通常包括：类的版本、字段、方法、接口等信息</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分。它是通过在堆内存中的 <code>DirectByteBuffer</code> 对象操作的堆外内存，避免了<code>堆内存</code>和<code>堆外内存</code>来回复制交换复制。</p><p>既然是内存，那也得是可以被回收的。但由于堆外内存不直接受 JVM 管理，所以常规 GC 操作并不能回收堆外内存。它是借助于老年代产生的 fullGC 顺便进行回收。同时也可以显式调用 System.gc() 方法进行回收（前提是没有使用 -XX:+DisableExplicitGC 参数来禁止该方法）。</p><p>值得注意的是：由于堆外内存也是内存，是由操作系统管理。如果应用有使用堆外内存则需要平衡虚拟机的堆内存和堆外内存的使用占比。避免出现堆外内存溢出。</p><h2 id="对象的创建、内存布局、访问定位"><a href="#对象的创建、内存布局、访问定位" class="headerlink" title="对象的创建、内存布局、访问定位"></a>对象的创建、内存布局、访问定位</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>（以下探讨的对象限于java对象，不包含数组和Class对象）</p><ol><li>虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有必须先执行相应的类加载过程。</li><li>在类加载检查完成后，虚拟机将为新生对象从Java堆中分配内存。</li><li>虚拟机将分配到的内存空间初始化为零值（不包括对象头），接下来将对象是哪个类的实例、如何找到类的元数据信息、对象哈希码、对象的GC分代年龄等信息存放到对象头（Object Header）。至此对象在虚拟机视角已经产生了，但是从java程序时间看，对象创建才刚开始，new指令后会执行<init>方法，对象按程序员意愿进行初始化，真正可用的对象才创建完成。</init></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中的存储布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头包含两部分：</p><ol><li>第一部分存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。长度在32位和64位的虚拟机中分别为32bits 和 64bits 空间。</li><li>第二部分为类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>（如果对象是Java数组，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组元数据中无法确认数组大小）。32位虚拟机环境下占用32bits 空间，在64位虚拟机开启压缩指针的环境下占用32bits 空间，不开启压缩指针占用64bits 空间。</li></ol><p>32位HotSpot虚拟机对象头Mark Word内容如图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/markword.png" alt="image"></p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>存放对象实例数据</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>不一定存在，占位符，没有特殊含义，HotSpot要求对象起始地址必须是8的整数倍，对象实例部分没有对齐时需要通过对齐填充补齐。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象的访问定位取决于具体的虚拟机实现。创建对象实例后，需要通过虚拟机栈中的reference类型数据来操作堆上的对象。现在主流的访问方式有使用句柄和直接指针两种：</p><h4 id="使用句柄访问"><a href="#使用句柄访问" class="headerlink" title="使用句柄访问"></a>使用句柄访问</h4><p>Java堆会划分一块内存作为句柄池，reference中存的是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息。</p><p>优势：reference中存储的是稳定的句柄指针，对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/handle-reference.png" alt="image"></p><h4 id="使用直接内存访问"><a href="#使用直接内存访问" class="headerlink" title="使用直接内存访问"></a>使用直接内存访问</h4><p>优势：速度更快，节省了一次指针定位开销。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/reference.png" alt="image"></p><h2 id="Trace追踪和参数配置"><a href="#Trace追踪和参数配置" class="headerlink" title="Trace追踪和参数配置"></a>Trace追踪和参数配置</h2><p><a href="https://docs.oracle.com/en/java/javase/11/gctuning/index.html">官方说明</a></p><ul><li>打印GC简要信息： -Xlog:gc  (jdk9+)</li><li>打印GC详细信息： -Xlog:gc*</li><li>指定GC log位置，以文件输出：-Xlog:gc:gc.log</li><li>每次GC后打印堆信息：-Xlog:gc+heap=debug</li></ul><p>GC日志格式（G1）：</p><ol><li>GC发生时间，即JVM启动以来秒数</li><li>日志级别信息、日志类型标记</li><li>GC识别号</li><li>GC类型和说明GC原因</li><li>容量：GC前容量-&gt;GC后容量（该区域总容量）</li><li>GC持续时间，单位秒</li></ol><p>参数：</p><ul><li>-Xms ：初始堆大小，默认物理内存1/64</li><li>-Xmx ：最大堆大小，默认物理内存1/4</li><li>-Xmn ：新生代大小，默认物理内存3/8，推荐大小为总堆大小25%-50%</li><li>-XX:+UseConcMarkSweepGC 使用CMS垃圾回收器</li><li>-XX:NewRatio 老年代与新生代比值</li><li>-XX:SurvivorRatio eden区与survivor区比值</li><li>-XX:+HeapDumpOnOutOfMemoryError导出内存溢出的堆信息</li><li>-XX:HeapDumpPath 指定dump导出路径</li><li>-XX:MetaspaceSize 元空间初始大小</li><li>-XX:MaxMetaspaceSize 元空间最大内存，默认无限制</li><li>-XX:MinMetaspaceSizeFreeRatio GC后最小元空间剩余容量百分比</li><li>-XX:MaxMetaspaceSizeFreeRatio GC后最大元空间剩余容量百分比</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/jvm.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】：类从加载、连接、初始化到卸载</title>
    <link href="https://haifuns.com/2020/12/26/jvm-1/"/>
    <id>https://haifuns.com/2020/12/26/jvm-1/</id>
    <published>2020-12-26T09:15:00.000Z</published>
    <updated>2025-02-23T13:53:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载、类加载器，双亲委派模型"><a href="#类加载、类加载器，双亲委派模型" class="headerlink" title="类加载、类加载器，双亲委派模型"></a>类加载、类加载器，双亲委派模型</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><ol><li>通过类的全限定名获取该类的二进制字节流</li><li>把二进制字节流转化为方法区的运行时数据结构</li><li>在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供访问方法区内数据结构的接口</li></ol><ul><li>常见方式：本地文件、jar等归档文件中加载</li><li>动态方式：将java源文件动态编译成class</li><li>其它方式：网络下载、从专有数据库中加载等<span id="more"></span><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3></li></ul><p>Java虚拟机自带加载器包括以下几种：</p><ul><li>启动类加载器（BootstrapClassLoader）</li><li>平台类加载器（PlatformClassLoader）jdk9, jdk8：扩展类加载器（ExtensionClassLoader）</li><li>应用程序类加载器（AppClassLoader）</li><li>模块类加载器（Module Class Loader）jdk9</li><li>用户自定义加载器，是java.lang.ClassLoader的子类，用户可以定制类的加载方式，自定义加载器加载顺序在所有系统类加载器之后</li></ul><h3 id="类加载器的关系"><a href="#类加载器的关系" class="headerlink" title="类加载器的关系"></a>类加载器的关系</h3><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/jvm/classloader.png" alt="image"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM中的ClassLoader通常采用双亲委派模型，要求除启动类加载器外，其余的类加载器都应该有自己的父加载器。加载器间是组合关系而非继承。工作过程如下：</p><ol><li>类加载器接收到类加载请求后。首先搜索它的内建加载器定义的所有“具名模块”</li><li>如果找到了合适的模块定义，将会使用该加载器来加载</li><li>如果class没有在这些加载器定义的具名模块中找到，那么将会委托给父加载器，直到启动类加载器</li><li>如果父加载器反馈不能完成请求，比如在它的搜索路径下找不到这个类，那子类加载器自己来加载</li><li>在类路径下找到的类成为这些加载器的无名模块</li></ol><p>双亲委派模型说明：</p><ol><li>双亲委派模型有利于保证Java程序的稳定</li><li>实现双亲委派的代码在java.class.ClassLoader的loadClass()方法中，自定义类加载器推荐重写findClass()方法</li><li>如果有一个类加载器能加载某个类，成为定义类加载器，所有能成功返回该类的Class的类加载器都被称为初始类加载器</li><li>如果没有指定父加载器，默认就是启动类加载器</li><li>每个类加载器都有自己的命名空间，命名空间由该加载器及其所有父加载器所加载的类构成，不同的命名空间可以出现类的全路径相同的情况</li><li>运行时包由同一个类加载器的类构成，决定两个类是否属于同一个运行时包不仅要看全路径是否一样，还要看定义类加载器是否相同。只有属于同一个运行时包的类才能实现相互包可见</li></ol><p>自定义类加载器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loaderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String loaderName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">this</span>.loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) {</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        name = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream(); InputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(</span><br><span class="line">                <span class="string">"target/"</span> + name + <span class="string">".class"</span>))){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((size = in.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            data = out.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCloaderMain</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"myClassLoader1"</span>);</span><br><span class="line"></span><br><span class="line">        Class cls = classLoader.loadClass(<span class="string">"classloader.MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"cls class loader == "</span> + cls.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"cls parent class loader == "</span> + cls.getClassLoader().getParent());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制台打印:</span></span><br><span class="line"><span class="comment">cls class loader == classloader.MyClassLoader@3caeaf62</span></span><br><span class="line"><span class="comment">cls parent class loader == sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>破坏双亲委派模型：</p><ul><li>双亲委派模型问题： 父加载器无法向下识别子加载器加载的资源</li></ul><p>为了解决这个问题，引入线程上下文类加载器，可以通过Thread的setContextClassLoader()进行设置，例如数据库连接驱动加载</p><ul><li>另一种典型情况是实现热替换，比如OSGI的模块热部署，它的类加载器不再是严格按照双亲委派模型，很多可能就在平级的类加载器中执行了</li></ul><h2 id="类连接"><a href="#类连接" class="headerlink" title="类连接"></a>类连接</h2><p>将已经读入内存的类二进制数据合并到JVM运行环境中去，包含以下几个步骤：</p><ol><li>验证：确保被加载类的正确性<ul><li>类文件结构验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li>解析：把常量池中的符号引用换为直接引用</li></ol><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><p>为类的静态变量赋初始值，或者说执行类的构造器<client>方法</client></p><ol><li>如果类未加载或连接，先进行加载连接</li><li>如果存在父类且父类未初始化，先初始化父类</li><li>如果类中存在初始化语句，依次执行</li><li>如果是接口<ul><li>初始化类不会先初始化它实现的接口</li><li>初始化接口不会初始化父接口</li><li>只有程序首次使用接口中的变量或调用接口方法时，接口才会初始化</li></ul></li><li>ClassLoader类的loadClass()方法装载类不会初始化这个类，不是对类的主动使用</li></ol><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><p>Java程序对类的使用分成： 主动使用和被动使用。JVM必须在每个类或接口“首次主动使用”时才会初始化它们，被动使用的类不会导致类的初始化。</p><p>主动使用的情况：</p><ol><li>创建类实例</li><li>访问类或接口的静态变量</li><li>调用类的静态方法</li><li>反射某个类</li><li>初始化子类，父类还没初始化</li><li>JVM启动时运行的主类</li><li>定义了default方法的接口，当接口实现类初始化</li></ol><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><p>当代表类的Class对象不再被引用，那么Class对象生命周期就结束了，对应方法区的数据也会被卸载。</p><p>JVM自带的类加载器装载的类不会卸载，由用户自定义的类加载器加载的类可以被卸载。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;类加载、类加载器，双亲委派模型&quot;&gt;&lt;a href=&quot;#类加载、类加载器，双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;类加载、类加载器，双亲委派模型&quot;&gt;&lt;/a&gt;类加载、类加载器，双亲委派模型&lt;/h2&gt;&lt;h3 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;通过类的全限定名获取该类的二进制字节流&lt;/li&gt;
&lt;li&gt;把二进制字节流转化为方法区的运行时数据结构&lt;/li&gt;
&lt;li&gt;在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供访问方法区内数据结构的接口&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;常见方式：本地文件、jar等归档文件中加载&lt;/li&gt;
&lt;li&gt;动态方式：将java源文件动态编译成class&lt;/li&gt;
&lt;li&gt;其它方式：网络下载、从专有数据库中加载等&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://haifuns.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://haifuns.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 网络分区&amp;扩展</title>
    <link href="https://haifuns.com/2020/12/26/rabbitmq-4/"/>
    <id>https://haifuns.com/2020/12/26/rabbitmq-4/</id>
    <published>2020-12-26T09:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h1><h2 id="网络分区意义"><a href="#网络分区意义" class="headerlink" title="网络分区意义"></a>网络分区意义</h2><p>RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。</p><p>当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。</p><p>RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：</p><span id="more"></span><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png" alt="image"></p><p>图中为某队列配置了4 个镜像，其中A 节点作为 master 节点，其余B、C、D 节点为 slave 节点，4 个镜像节点组成一个环形结构。</p><p>假如需要确认(ack)一条消息，先会在A 节点即master 节点上执行确认命令，之后转向B 节点，然后是C 节点，最后由D 将执行操作返回给A 节点，这样才真正确认了一条消息，之后才可以继续相应的处理。</p><p>这种复制原理与ZooKeeper 的Quorum 原理不同，它可以保证更强的一致性。在这种一致性数据模型下，如果出现网络波动或者网络故障等异常情况，那么整个数据链的性能就会大大降低。如果C 节点网络异常，那么整个 A -&gt; B -&gt; C -&gt; D -&gt; A 数据链就会被阻塞，继而相关服务也会被阻塞，所以这里就需要引入网络分区来将异常的节点剥离出整个分区，以确保 RabbitMQ 服务的可用性及可靠性。等待网络恢复之后，可以进行相应的处理来将此前的异常节点加入集群中。</p><h2 id="网络分区判定"><a href="#网络分区判定" class="headerlink" title="网络分区判定"></a>网络分区判定</h2><p>RabbitMQ 集群节点内部通信端口默认为25672 ，两两节点之间都会有信息交互，如果某节点出现网络故障，或者是端口不通，会致使与此节点的交互出现中断，这里就会有个超时判定机制，继而判定网络分区。</p><p>对于网络分区的判定是与 net_ticktime 参数息息相关的，此参数默认值为60 秒。注意与heartbeat_time 的区别heartbeat_time 是指客户端与 RabbitMQ 服务之间通信的心跳时间，针对 5672 端口而言。如果发生超时则会有 net_tick_timeout 的信息报出RabbitMQ 集群内部的每个节点之间会每隔四分之一的 net_ticktime 次应答(tick)。如果有任何数据被写入节点中，则此节点被认为已经被应答(ticked)了。如果连续4 次，某节点都没有被 ticked，则可以判定此节点已处于 “down” 状态，其余节点可将此节点剥离出当前分区。</p><p>将连续4 次的 tick 时间记为 T，那么T 的取值范围为 <code>0.75 * net_ticktime &lt; T &lt; 1.25 * net_ticktime</code>。下图可以形象地描绘出这个取值范围的缘由：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition2.png" alt="image"></p><p>图中每个节点代表一次 tick 判定的时间戳，在2 个临界值 0.75  * net_ticktime 和<br>1.25 * net_ticktime 之间可以连续执行4 次的 tick 判定。默认情况下，在 45s &lt; T &lt; 75s 之间会判定出net_tick_timeout。</p><p>RabbtMQ 不仅会将队列、交换器及绑定等信息存储在 Mnesia 数据库中，而且许多围绕网络分区的一些细节也都和这个 Mneia 的行为相关。如果一个节点不能在T 时间连上另一个节点，那么 Mnesia 通常认为这个节点己经挂了，就算之后两个节点又重新恢复了内部通信，但是这两个节点都会认为对方已经挂了，Mnesia 此时认定了发生网络分区的情况。这些会被记录到RabbitMQ 的服务日志之中如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mnesia('rabbit@node1'): ** ERROR ** mnesia event got</span><br><span class="line">{inconsistent_database, running_partitioned_network, 'rabbit@node2'}</span><br></pre></td></tr></tbody></table></figure><p>除了通过查看 RabbitMQ 服务日志的方式，还有以下3 种方法可以查看是否出现网络分区：</p><ol><li>采用 rabbitmqctl 工具来查看，即采用<code>rabbitmqctl cluster_status</code>，通过这条命令可以看到集群相关信息，未发生网络分区时的情形举例如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node2,rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitio, []}]</span><br></pre></td></tr></tbody></table></figure>由上面的信息可知，集群中一共有3 个节点，分别为rabbit@node1、rabbit@node2、rabbit@node3。在partitions这一项中没有相关记录，则说明没有产生网络分区。如果partitions 项中有相关容，则说明产生了网络分区，例如：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitions, [{rabbit@node3,[rabbit@node2]},{rabbit@node1,[rabbit@node2]}]}]</span><br></pre></td></tr></tbody></table></figure>上面partitions 项中的内容表示：</li></ol><ul><li>rabbit@node3与rabbit@node2 发生了分区，即 {rabbit@node3,[rabbit@node2]}</li><li>rabbit@node1与rabbit@node2 发生了分区，即 {rabbit@node1,[rabbit@node2]}</li></ul><ol start="2"><li>通过 Web 管理界面的方式查看。如果发生了网络分区页面会出现警告。推荐采用这种方式来检测是否发生了网络分区。</li><li>通过 HTTP API 的方式调取节点信息来检测是否发生网络分区，比如通过 curl 命令来调取节点信息：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -u root:root123 -H "content-type:application/json" -X GET http://localhost:15672/api/nodes</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="模拟网络分区"><a href="#模拟网络分区" class="headerlink" title="模拟网络分区"></a>模拟网络分区</h2><p>正常情况下，很难观察到 RabbitMQ 网络分区的发生。为了更好地理解网络分区，需要采取某些手段将其模拟出来，以便对其进行相应的分析处理，进而在实际应用环境中遇到类似情形可以处理游刃有余。往长远方面讲，也可以采取一些要的手段去规避网络分区的发生，或者可以监控网络分区以及准备相关的处理预案。</p><p>模拟网络分区的方式有多种，主要分为以下三大类:</p><ul><li>iptables 封禁/解封 IP 地址或者端口号；</li><li>关闭/开启网卡；</li><li>挂起/恢复操作系统；</li></ul><h2 id="网络分区的影响"><a href="#网络分区的影响" class="headerlink" title="网络分区的影响"></a>网络分区的影响</h2><h3 id="未配置镜像"><a href="#未配置镜像" class="headerlink" title="未配置镜像"></a>未配置镜像</h3><p>node1、node2、node3 三个节点组成一个RabbitMQ 集群，且在这三个节点中分别创建queue1、queue2、queue3这三个队列，并且相应的交换器与绑定关系如下：</p><table><thead><tr><th>节点名称</th><th>交换器</th><th>绑定</th><th>队列</th></tr></thead><tbody><tr><td>node1</td><td>exchange</td><td>rk1</td><td>queue1</td></tr><tr><td>node2</td><td>exchange</td><td>rk2</td><td>queue2</td></tr><tr><td>node3</td><td>exchange</td><td>rk3</td><td>queue3</td></tr></tbody></table><p><strong>客户端分别连接node1 和node2 并分别向/从queue1 和queue2 发送/消费消息</strong></p><table><thead><tr><th>客户端</th><th>节点名称</th><th>交换器</th><th>绑定</th><th>队列</th></tr></thead><tbody><tr><td>client1(producer)</td><td>node1</td><td>exchange</td><td>rk1</td><td>queue1</td></tr><tr><td>client2(producer)</td><td>node2</td><td>exchange</td><td>rk2</td><td>queue2</td></tr><tr><td>client3(consumer)</td><td>node1</td><td>exchange</td><td>rk1</td><td>queue1</td></tr><tr><td>client4(consumer)</td><td>node2</td><td>exchange</td><td>rk2</td><td>queue2</td></tr></tbody></table><p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，对于消息生产端client1、client2 而言，没有任何异常，消息正常发送也没有消息丢失。消费端client3、client4 也都能正常消费，无任何异常发生。</p><p><strong>客户端分别连接node1 和node2 并分别向/从queue2 和queue1 发送/消费消息</strong></p><table><thead><tr><th>客户端</th><th>节点名称</th><th>交换器</th><th>绑定</th><th>队列</th></tr></thead><tbody><tr><td>client1(producer)</td><td>node1</td><td>exchange</td><td>rk2</td><td>queue2</td></tr><tr><td>client2(producer)</td><td>node2</td><td>exchange</td><td>rk1</td><td>queue1</td></tr><tr><td>client3(consumer)</td><td>node1</td><td>exchange</td><td>rk2</td><td>queue2</td></tr><tr><td>client4(consumer)</td><td>node2</td><td>exchange</td><td>rk1</td><td>queue1</td></tr></tbody></table><p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，client1 不能将消息正确地送达到queue2 ，同样client2 不能将消息送达到queue1 中。如果客户端中设置了ReturnListener 来监听 Basic.Return 的信息，并附带有消息重传机制，那么在整个网络分区前后的过程中可以保证发送端的消息不丢失。</p><p>在网络分区之前queue1 进程存在于node1 节点中，queue2 进程存在于node2 节点中。<br>在网络分区之后，在node1 所在的分区并不会创建新的queue2 进程，同样在node2 所在的分区也不会创建新的queue1 的进程。这样在网络分区发生之后，虽然可以通过 <code>rabbitmqctl list_queues name</code> 命令在node1 节点上查看到queue2，但是在node1 上已经没有真实的queue2 进程的存在。</p><p>client1 将消息发往交换器exchange 之后并不能路由到queue2 中，因此消息也就不能存储。如果客户端没有设置mandatory 参数并且没有通过ReturnListener 进行消息重试(或者其他措施)来保障消息可靠性，那么在发送端就会有消息丢失。</p><p>对于消费端client3、client4，客户端没有异常报错，且可以消费到相关数据，但是此时会有一些怪异的现象发生，比如对于已消费消息的ack 失效。在从网络分区中恢复之后，数据不会丢失。</p><p>如果分区之后，重启client3 或者有个新的客户端client5 连接node1 IP 来消费queue2 则会报错。</p><p><strong>小结</strong></p><p>对于未配置镜像的集群，网络分区发生之后，队列也会伴随着宿主节点而分散在各自的分区之中。对于消息发送方而言，可以成功发送消息，但是会有路由失败的现象，要需要配合mandatory 等机制保障消息的可靠性。对于消息消费方来说，有可能会有诡异、不可预知的现象发生，比如对于已消费消息的ack 会失效。如果网络分区发生之后，客户端与某分区重新建立通信链路，其分区中如果没有相应的队列进程，则会有异常报出。如果从网络分区中恢复之后，数据不会丢失，但是客户端会重复消费。</p><h3 id="已配置镜像"><a href="#已配置镜像" class="headerlink" title="已配置镜像"></a>已配置镜像</h3><p>如果集群中配置了镜像队列，那么在发生网络分区时，情形比未配置镜像队列的情况复杂得多，尤其是发生多个网络分区的时候。这里先简单地从3 个节点分裂成2 个网络分区的情形展开讨论。如前文所述，集群中有node1、node2、node3 三个节点，分别在这些节点上创建队列queue1、queue2、queue3 并配置镜像队列。采用iptables 的方式将集群模拟分裂[node1,node3] [node2] 这两个网络分区。</p><p>镜像队列的相关配置可以参考如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ha-mode:exactly </span><br><span class="line">ha-param:2 </span><br><span class="line">ha-sync-mode:automatic</span><br></pre></td></tr></tbody></table></figure><p>首先来分析第一种情况。如下表示，3 个队列的master 镜像和slave 镜像分别做相应分布。</p><p>分区之前：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node3</td></tr><tr><td>queue2</td><td>node2</td><td>node3</td></tr><tr><td>queue3</td><td>node3</td><td>node2</td></tr></tbody></table><p>分区之后：</p><p>[node1,node3]分区：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node3</td></tr><tr><td>queue2</td><td>node3</td><td>node1</td></tr><tr><td>queue3</td><td>node3</td><td>node1</td></tr></tbody></table><p>在发生网络分区之后 [node1,node3] 分区中的队列有了新的部署。除了queue1 未发生改变，queue2 于原宿主节点node2 被剥离当前分区，那么node3 提升为master ，同时选择node1 作为slave 。在queue3 重新选择node1 作为其新的slave。</p><p>[node2]分区：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node3</td></tr><tr><td>queue2</td><td>node2</td><td>[]</td></tr><tr><td>queue3</td><td>node2</td><td>[]</td></tr></tbody></table><p>对于[node2] 分区而言，queue2、queue3的分布比较容易理解，此分区中只有一个节点，所有slave 列为空。但是对于queue1而言，其部署还是和分区前如出一辙。不管是在网络分区前，还是在网络分区之后，再或者是又从网络分区中恢复，对于queue1而言生产和消费消息都不会受到任何的影响，就如未发生过网络分区一样。对于队列queue2、queue3 情形可以参考上面未配置镜像的相关细节，从网络分区中恢复(即恢复成之前的[node1,node2,node3] 组成的完整分区)之后可能会有数据丢失。</p><p>再考虑另一种情形，分区之前如下所示：</p><p>分区之前：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node2</td></tr><tr><td>queue2</td><td>node2</td><td>node3</td></tr><tr><td>queue3</td><td>node3</td><td>node1</td></tr></tbody></table><p>分区之后：</p><p>[node1,node3]分区：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node3</td></tr><tr><td>queue2</td><td>node3</td><td>node1</td></tr><tr><td>queue3</td><td>node3</td><td>node1</td></tr></tbody></table><p>[node2]分区：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node2</td><td>[]</td></tr><tr><td>queue2</td><td>node2</td><td>[]</td></tr><tr><td>queue3</td><td>node3</td><td>node1</td></tr></tbody></table><h2 id="手动处理网络分区"><a href="#手动处理网络分区" class="headerlink" title="手动处理网络分区"></a>手动处理网络分区</h2><p>为了从网络分区中恢复，首先需要挑选一个信任分区，这个分区才有决定Mnesia 内容的权限，发生在其他分区的改变将不会被记录到Mnesia 中而被直接丢弃。在挑选完信任分区之后，重启非信任分区中的节点，如果此时还有网络分区的告警，紧接着重启信任分区中的节点。</p><p>这里有3 个要点需要详细阐述：</p><ul><li>如何挑选信任分区？</li><li>如何重启节点？</li><li>重启的顺序有何考究？</li></ul><h3 id="如何挑选信任分区？"><a href="#如何挑选信任分区？" class="headerlink" title="如何挑选信任分区？"></a>如何挑选信任分区？</h3><p>挑选信任分区一般可以按照这几个指标进行：</p><ul><li>分区中要有disc 节点；</li><li>分区中的节点数最多；</li><li>分区中的队列数最多；</li><li>分区中的客户端连接数最多；</li></ul><p>优先级从前到后，例如信任分区中要有disc 节点；如果有两个或者多个分区满足，则挑选节点数最多的分区作为信任分区；如果又有两个或者多个分区满足，那么挑选队列数最多的分区作为信任分区。依次类推如果有两个或者多个分区对于这些指标都均等，那么可以随机挑选一个分区。</p><h3 id="如何重启节点？"><a href="#如何重启节点？" class="headerlink" title="如何重启节点？"></a>如何重启节点？</h3><p>RabbitMQ 中有两种重启方式：</p><ul><li>使用 <code>rabbitmqctl stop</code> 命令关闭，然后再用 <code>rabbitmq-server -detached</code>命令启动</li><li>使用 <code>rabbitmqctl stop_app</code> 关闭，然后使用 <code>rabbitmqctl start_app</code>命令启动。</li></ul><p>第一种方式需要同时重启erlang 虚拟机和RabbitMQ 应用，而第二种方式只是重启RabbitMQ 应用。两种方式都可以从网络分区中恢复，但是更加推荐使用第二种方式，包括后面的自动处理网络分区的方式，其内部是采用的第二种方式进行重启节点。</p><h3 id="重启的顺序有何考究？"><a href="#重启的顺序有何考究？" class="headerlink" title="重启的顺序有何考究？"></a>重启的顺序有何考究？</h3><p>RabbitMQ 的重启顺序也比较讲究，必须在以下两种重启顺序中择其一进行重启操作：</p><ol><li>停止其他非信任分区中的所有节点，然后再启动这些节点。如果此时还有网络分区的告警，则再重启信任分区中的节点以去除告警。</li><li>关闭整个集群中的节点，然后再启动每一个节点，这里需要确保启动的第一个节点在<br>信任的分区之中。</li></ol><p>在选择哪种重启顺序之前 首先考虑一下队列“漂移”的现象。所谓的队列“漂移”是在配置镜像队列的情况下才会发生的。在配置镜像的集群中重启会有队列“漂移”的情况发生，造成负载不均衡。</p><blockquote><p>注意：一定要按照前面提及的两种方式择其一进行重启，如果选择挨个节点重启的方式，同样可以处理网络分区，但是这里会有一个严重的问题，即Mnesia 内容权限的归属问题。比如有两个分区[node1,node2] [node3,node4]，其中[node1,node2] 为信任分区，此时若按照挨个重启的方式进行重启，比如先重启node3 ，在node3 节点启动之时无法判断其节点的Mnesia 内容是向[node1,node2] 分区靠齐还是向node4 节点靠齐，至此，如果挨个一轮重启之后，最终集群中的Mnesia 数据是[node3 node4] 这个非信任分区，就会造成无法估量的损失。挨个节点重启也有可能会引起二次网络分区的发生。</p></blockquote><p>如果原本配置了镜像队列，从发生网络分区到恢复的过程中队列可能会出现“漂移”的现象。可以重启之前先删除镜像队列的配置，这样能够在一定程度上阻止队列的“过分漂移”，即阻止可能所有队列都“漂移”到一个节点上的情况。</p><p>删除镜像队列的配置可以采用 rabbitmqctl 工具删除：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_policy [-p vhost] {mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure><p>可以通过 Web 管理界面进行删除，也可以通过 HTTPAPI 的方式进行删除:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -u {username:password} -X DELETE http://localhost:15672/api/policies/default/{mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure><h3 id="网络分区处理步骤"><a href="#网络分区处理步骤" class="headerlink" title="网络分区处理步骤"></a>网络分区处理步骤</h3><ul><li>步骤 1：挂起生产者和消费者进程。这样可以减少消息不必要的丢失，如果进程数过多，情形又比较紧急，也可跳过此步骤。</li><li>步骤 2：删除镜像队列的配置。</li><li>步骤 3：挑选信任分区。</li><li>步骤 4：关闭非信任分区中的节点。采用 <code>rabbitmqctl stop_app</code> 命令关闭。</li><li>步骤 5：启动非信任分区中的节点。采用与步骤4 对应的 <code>rabbitmqctl start_app</code> 命令启动。</li><li>步骤 6：检查网络分区是否恢复，如果已经恢复则转步骤8，如果还有网络分区的报警则转步骤7。</li><li>步骤 7：重启信任分区中的节点。</li><li>步骤 8：添加镜像队列的配置。</li><li>步骤 9：恢复生产者和消费者的进程。</li></ul><h2 id="自动处理网络分区"><a href="#自动处理网络分区" class="headerlink" title="自动处理网络分区"></a>自动处理网络分区</h2><p>RabbitMQ 提供了三种方法自动地处理网络分区pause-minority 模式、pause-if-all-down 模式和autoheal 模式。默认是 ignore 模式，即不自动处理网络分区，所以在这种模式下，当网络分区的时候需要人工介入。在 rabbitmq.config 配置文件中配置<code>cluster_partition_handling</code> 参数即可实现相应的功能。默认的 ignore 模式的配置如下，注意最后有个点号：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, ignore}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><h3 id="pause-minority-模式"><a href="#pause-minority-模式" class="headerlink" title="pause-minority 模式"></a>pause-minority 模式</h3><p>在pause-minority 模式下，当发生网络分区时，集群中的节点在观察到某些节点”down”的时候，会自动检测其自身是否处于”少数派”(分区中的节点小于或者等于集群中一半的节点数)，RabbitMQ 会自动关闭这些节点的运作。根据 CAP 原理，这里保障了P，即分区耐受性。这样确保了在发生网络分区的情况下，大多数节点(当然这些节点得在同一个分区中)可以继续运行。”少数派”中的节点在分区开始时会关闭，当分区结束时又会启动。这里关闭是指RabbitMQ 应用的关闭，而Erlang 虚拟机并不关闭，类似于执行了 <code>rabbitmqctl stop_app</code> 命令。处于关闭的节点会每秒检测一次是否可连通到剩余集群中，如果可以则启动自身的应用。相当于执行 <code>rabbitmqctl start_app</code> 命令。</p><p>pause-minority 模式相应的配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, pause-minority}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是RabbitMQ 会关闭不是严格意义上的大多数，比如在一个集群中只有两个节点的时候并不适合采用pause-minority 的模式，因为其中任何一个节点失败而发生网络分区时，两个节点都会关闭。当网络恢复时有可能两个节点会自动启动恢复网络分区，也有可能仍保持关闭状态，然而如果集群中的节点数远大于2 个时，pause-minority 模式比 ignore 模式更加可靠，特别是网络分区通常是由单节点网络故障而脱离原有分区引起的。</p><p>当对等分区出现时，会关闭这些分区内的所有节点，对于前面的[node1,node2] [node3,node4] 的例子而言，这四个节点上的RabbitMQ 应用都会被关闭，只有等待网络恢复之后，才会自动启动所有的节点以求从网络分区中恢复。</p><h3 id="pause-if-all-down-模式"><a href="#pause-if-all-down-模式" class="headerlink" title="pause-if-all-down 模式"></a>pause-if-all-down 模式</h3><p>在pause-if-all-down 模式下，RabbitMQ 集群中的节点在和所配置的列表中的任何节点不能交互时才会关闭 语法为 {pause_if_all_down, [nodes], ignore|autoheal}，其中[nodes]为受信节点，参考配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, {pause_if_all_down, ['rabbit@node1'], ignore}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><p>如果一个节点与 rabbit@node1 节点无法通信时，则会关闭自身的 RabbitMQ 应用。如果是rabbit@node1 本身发生了故障造成网络不可用，而其他节点都是正常的情况下，这种规则会让所有的节点中 RabbitMQ 应用都关闭，待rabbit@node1 中的网络恢复之后，各个节点再启动自身应用以从网络分区中恢复。</p><p>pause-if-all-down 模式下有ignore 和autoheal 两种不同的配置。考虑前面pause-minority 模式中提及的一种情形，node1、node2 部署在机架A 上，而node3、node4 部署在机架B，此时配置{cluster_partition_handling,{pause_if_all_down,[‘rabbit@node1’ ,‘rabbit@node3’], ignore}}，那么当机架A 和机架B 通信出现异常时，由于node1、node2 保持着通信，node3、node4 保持着通信，这4 个节点都不会自行关闭，但是会形成两个分区，所以这样不能实现自动处理的功能。所以如果将配置中的ignore 替换成autoheal 就可以处理此种情形。</p><h3 id="autoheal-模式"><a href="#autoheal-模式" class="headerlink" title="autoheal 模式"></a>autoheal 模式</h3><p>在autoheal 模式下，当认为发生网络分区时，RabbitMQ 会自动决定一个获胜(winning)的分区，然后重启不在这个分区中的节点来从网络分区中恢复。一个获胜的分区是指客户端连接最多的分区，如果产生一个平局，即有两个或者多个分区的客户端连接数一样多，那么节点数最多的一个分区就是获胜分区，如果此时节点数也一样多，将以节点名称的字典序来挑选获胜分区。</p><p>autoheal 模式参考配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, autoheal}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：在autoheal 模式下，如果集群中有节点处于非运行状态，那么当发生网络分区的时候，将不会有任何自动处理的动作。</p></blockquote><h3 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h3><p>允许RabbitMQ 够自动处理网络分区并不一定会有正面的成效，也有可能会带来更多的问题。网络分区会导致RabbitMQ 集群产生众多的问题，需要对遇到的问题做出一定的选择。如果置RabbitMQ 于一个不可靠的网络环境下，需要使用Federation 或者Shovel。就算从网络分区中恢复了之后，也要谨防发生二次网络分区。</p><p>每种模式都有自身的优缺点，没有哪种模式是万无一失的，要根据实际情形做出相应的选择，下面简要概论以下4 个模式：</p><ul><li>ignore 模式：发生网络分区时，不做任何动作，需要人工介入；</li><li>pause-minority 模式：对于对等分区的处理不够优雅，可能会关闭所有的节点。一般情况下，可应用于非跨机架、奇数节点数的集群中；</li><li>pause-if-all-down 模式：对于受信节点的选择尤为考究，尤其是在集群中所有节点硬件配置相同的情况下。此种模式可以处理对等分区的情形；</li><li>autoheal 模式：可以处于各个情形下的网络分区。但是如果集群中有节点处于非运行状态，则此种模式会失效；</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><h3 id="Firehose"><a href="#Firehose" class="headerlink" title="Firehose"></a>Firehose</h3><p>在RabbitMQ 中可以使用Firehose 功能来实现消息追踪，Firehose 可以记录每一次发送或者<br>消费消息的记录，方便RabbitMQ 的使用者进行调试、排错等。</p><p>开启Firehose 命令: <code>rabbitmqctl trace_on [-p vhost]</code> 其中 [-p vhost] 是可选参数用来指定虚拟主机vhost 。对应的关闭命令为 <code>rabbitmqctl trace_off [-p vhost]</code>。</p><p>Firehose 默认情况下处于关闭状态，并且Firehose 的状态也是非持久化的，会在RabbitMQ 服务重启的时候还原成默认的状态。Firehose 开启之后多少会影响RabbitMQ 整体服务的性能，因为它会引起额外的消息生成、路由和存储。</p><h3 id="rabbitmq-tracing-插件"><a href="#rabbitmq-tracing-插件" class="headerlink" title="rabbitmq_tracing 插件"></a>rabbitmq_tracing 插件</h3><p>rabbitrnq_tracing 插件相当于Firehose 的GUI 版本，它同样能跟踪RabbitMQ 中消息的流入流出情况。rabbitrnq_tracing 插件同样会对流入流出的消息进行封装，然后将封装后的消息日志存入相应的trace 文件之中。</p><p>可以使用<code>rabbitmq-plugins enable rabbitrnq_tracing</code> 命令来启动rabbitmq_tracing 插件。对应的关闭插件的命令是 <code>rabbitrnq-plugins disable rabbitrnq_tracing</code>。</p><p>开启后在Web 管理界面会多Tracing 页签。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li><p>客户端内部实现负载均衡</p></li><li><p>使用HAProxy实现负载均衡</p></li><li><p>使用Keepalived实现高可靠负载均衡</p></li><li><p>使用Keepalived+LVS实现负载均衡</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络分区&quot;&gt;&lt;a href=&quot;#网络分区&quot; class=&quot;headerlink&quot; title=&quot;网络分区&quot;&gt;&lt;/a&gt;网络分区&lt;/h1&gt;&lt;h2 id=&quot;网络分区意义&quot;&gt;&lt;a href=&quot;#网络分区意义&quot; class=&quot;headerlink&quot; title=&quot;网络分区意义&quot;&gt;&lt;/a&gt;网络分区意义&lt;/h2&gt;&lt;p&gt;RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。&lt;/p&gt;
&lt;p&gt;当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。&lt;/p&gt;
&lt;p&gt;RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://haifuns.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 存储&amp;告警&amp;流控&amp;镜像队列</title>
    <link href="https://haifuns.com/2020/12/26/rabbitmq-3/"/>
    <id>https://haifuns.com/2020/12/26/rabbitmq-3/</id>
    <published>2020-12-26T08:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h1><p>不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。持久化的消息在到达队列时就被写入到磁盘，并且如果可以，持久化的消息也会在内存中保存一份备份，这样可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。这两种类型的消息的落盘处理都在RabbitMQ 的”持久层”中完成。</p><p>持久层是一个逻辑上的概念，实际包含两个部分队列索引(rabbit_queue_index) 和消息存储 (rabbit_msg_store)。</p><ul><li>rabbit_queue_index 负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付给消费者、是否已被消费者 ack 等。</li><li>rabbit_msg_store 以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。rabbit_msg_store 具体还可以分为：<ul><li>msg_store_persistent 负责持久化消息的持久化，重启后消息不会丢失。</li><li>msg_store_transient 负责非持久化消息的持久化，重启后消息会丢失。</li></ul></li></ul><span id="more"></span><p>消息(包括消息体、属性和 headers) 可以直接存储在 rabbit_queue_index 中，也可以被保存在rabbit_msg_store 中。默认在 <code>$RABBITMQ_HOME/var/lib/mnesia/rabbit@$HOSTNAME/</code> 路径下包含 queues 、msg_store_persistent 、msg_store_transient 文件夹，其分别存储对应的信息。</p><p>最佳的配备是较小的消息存储在 rabbit_queue_index 中而较大的消息存储在rabbit_msg_store 中。这个消息大小的界定可以通过 <code>queue_index_embed_msgs_below</code><br>来配置，默认大小为 4096 B。注意这里的消息大小是指消息体、属性及 headers 整体的大小。当一个消息小于设定的大小阈值时就可以存储在 rabbit_queue_index 中，这样可以得到性能上的优化。</p><p>rabbit_queue_index 中以顺序(文件名从0开始累加) 的段文件来进行存储，后缀为”.idx”，每个段文件中包含固定的 <em>SEGMENT_ENTRY_COUNT</em> 条记录，<br><em>SEGMENT_ENTRY_COUNT</em> 默认值为 16384 。每个 rabbit_queue_index 从磁盘中读取消息的时候至少要在内存中维护一个段文件，所以设置 <code>queue_index_embed_msgs_below</code> 值的时候要格外谨慎，一点点增大也可能会引起内存爆炸式的增长。</p><p>经过 rabbit_msg_store 处理的所有消息都会以追加的方式写入到文件中，当文件的大小超过指定的限制(file_size_limit) 则关闭这个文件再创建一个新的文件以供新的消息写入。文件名(文件后缀是”.rdq”) 开始进行累加。因此文件名最小的文件也是最老的文件。</p><ul><li>在进行消息的存储时，RabbitMQ 会在 ETS (Erlang Term Storage) 表中记录消息在文件中的位置映射(Index)和文件的相关信息(FileSummary)。</li><li>在读取消息的时候，先根据消息的 ID (msg_id) 找到对应存储的文件，如果文件存在并且未被锁住，则直接打开文件，从指定位置读取消息的内容。如果文件不存在或者被锁住了，则发送请求由 rabbit_msg_store 进行处理。</li></ul><p>消息的删除只是从 ETS 表删除指定消息的相关信息，同时更新消息对应的存储文件的相关信息。执行消息删除操作时，并不立即对在文件中的消息进行删除，也就是说消息依然在文件中，仅仅是标记为垃圾数据而己。当一个文件中都是垃圾数据时可以将这个文件删除。当检测到前后两个文件中的有效数据可以合并在一个文件中，并且所有的垃圾数据的大小和所有文件(至少有3个文件存在的情况下)的数据大小的比值超过设置的阈值 <em>GARBAGE_FRACTION</em> (默认值为 0.5) 时才会触发垃圾回收将两个文件合并。</p><h2 id="队列的结构"><a href="#队列的结构" class="headerlink" title="队列的结构"></a>队列的结构</h2><p>通常队列由 rabbit_amqqueue_process 和backing_queue 这两部分组成：</p><ul><li>rabbit_amqqueue_process 负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack)。</li><li>backing queue 是消息存储的具体形式和引擎，并向 rabbit_amqqueue_process 提供相关的接口以供调用。</li></ul><p>如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。消息存入队列后，不是固定不变的，它会随着系统的负载在队列中不断地流动，消息的状态会不断发生变化。RabbitMQ中的队列消息可能会处于以下4 种状态：</p><ol><li>alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中</li><li>beta: 消息内容保存在磁盘中，消息索引保存在内存中</li><li>gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有</li><li>delta: 消息内容和索引都在磁盘中</li></ol><p>对于持久化的消息，消息内容和消息索引都必须先保存在磁盘上，才会处于上述状态中的gamma 状态的消息是只有持久化的消息才会有的状态。</p><p>RabbitMQ 在运行时会根据统计的消息传送速度定期计算一个当前内存中能够保存的最大消息数量 (target_ram_count) ，如果 alpha 状态的消息数量大于此值时，就会引起消息的状态转换，多余的消息可能会转换到 beta 状态、gamma 状态或者 delta 状态。</p><p>区分这状态的主要作用是满足不同的内存和 CPU 需求：</p><ul><li>alpha 状态最耗内存，但很少消耗 CPU；</li><li>delta 状态基本不消耗内存，但是需要消耗更多的 CPU 和磁盘I/O 操作。delta 状态需要执行两次I/O 操作才能读取到消息，一次是读消息索引(从 rabbit_queue_index 中)，一次是读消息内容(从 rabbit_msg_store 中)；</li><li>beta 和gamma 状态都只需要一次I/O 操作就可以读取到消息(从 rabbit_msg_store 中)；</li></ul><p>对于普通的没有设置优先级和镜像的队列来说， backing_queue 的默认实现是rabbit_variable_queue，其内部通过5 个子队列 Q1、Q2、Delta、Q3、Q4 来体现消息的各个状态。整个队列包括 rabbit_amqqueue_process、backing_queue 的各个子队列。</p><p>队列的结构可以参考下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-queue.png" alt="image"></p><p>其中：</p><ul><li>Q1、Q4 只包含 alpha 状态的消息</li><li>Q2、Q3 包含 beta 和 gamma 状态的消息</li><li>Delta 只包 delta 状态的消息</li></ul><p>一般情况下，消息按照 Q1 -&gt; Q2 -&gt; Delta -&gt; Q3 -&gt; Q4 这样的顺序步骤进行流动，但并不是每一条消息都一定会经历所有的状态，这个取决于当前系统的负载状况。从 Q1 至 Q4 基本经历内存到磁盘，再由磁盘到内存这样的一个过程，如此可以在队列负载很高的情况下，能够通过将部分消息由磁盘保存来节省内存空间，而在负载降低的时候，这部分消息又渐渐回到内存被消费者获取，使得整个队列具有很好的弹性。</p><p>消费者获取消息也会引起消息的状态转换。当消费者获取消息时</p><ol><li>首先会从 Q4 中获取消息，如果获取成功则返回。如果 Q4 空，则尝试从Q3 中获取消息。</li><li>系统首先会判断 Q3 是否为空<ul><li>如果为空，返回队列为空，即此时队列中无消息。</li><li>如果 Q3 不为空，则取出 Q3 中的消息，进而再判断此时 Q3 和 Delta 中的长度<ul><li>如果都为空，则可以认为 Q2、Delta、Q3、Q4 全部为空，此时将 Q1 中的消息直接转移至Q4，下次直接从 Q4 中获取消息。</li><li>如果 Q3 为空， Delta 不为空，则将 Delta 消息转移至 Q3 中，下次可以直接从 Q3 中获取消息。</li></ul></li></ul></li></ol><p>在将消息从 Delta 转移到 Q3 过程中是按照索引分段读取的，首先读取某一段，然后判断读取的消息的个数与 Delta 消息的个数是否相等，如果相等，则可以判定此时 Delta 中已无消息 ，则直接将 Q2 刚读取到的消息一并放入到 Q3 中。如果不相等，仅将此次读取到的消息转移到 Q3。</p><p>这里就有两处疑问:</p><p><strong>为什么 Q3 为空则可以认定整个队列为空？</strong></p><p><strong>为什么 Q3 Delta 为空时，则可以认为 Q2 Delta Q3 Q4 全部为空？</strong></p><p>试想一下，</p><ul><li>如果 Q3 为空，Delta 不为空，那么在 Q3 取出最后一条消息的时候，Delta 上的消息就会被转移 Q3，这样与 Q3 为空矛盾；</li><li>如果 Delta 为空且 Q2 不为空，则在 Q3 取出最后一条消息时会将 Q2 的消息并入到 Q3 ，这样 Q3 也与 Q3 为空矛盾；</li><li>在 Q3 取出 最后一条消息之后，如果 Q2、Delta、Q3 都为空，且 Q1 不为空时，则 Q1 的消息会被转移到 Q4 这与 Q4 为空矛盾。</li></ul><p>通常在负载正常时，如果消息被消费的速度不小于接收新消息的速度，对于不需要保证可靠不丢失的消息来说，极有可能只会处于 alpha 状态。对于 durable 属性设置为 true 的消息，它一定会进入 gamma 状态，并且在开启 publisher confirm 机制时，只有到了 gamma 状态时才会确认该消息已被接收，若消息消费速度足够快、内存充足，这些消息也不会继续走到下一个状态。</p><p>在系统负载较高时，已接收到的消息若不能很快被消费掉，这些消息就会进入到很深的队列中去，这样会增加处理每个消息的平均开销。因为要花更多的时间和资源处理”堆积”的消<br>息，如此用来处理新流入的消息的能力就会降低，使得后流入的消息又被积压到很深的队列中继续增大处理每个消息的平均开销，继而情况变得越来越恶化，使得系统的处理能力大大降低。</p><p>应对这一问题一般有3 种措施：</p><ol><li>增加 prefetch_count 的值，即一次发送多条消息给消费者，加快消息被消费的速度；</li><li>采用 multiple ack，降低处理 ack 带来的开销；</li><li>流量控制，详细内容可以参考下文<a href="#%E6%B5%81%E6%8E%A7">流控</a>；</li></ol><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>RabbitMQ 从3.6.0 版本开始引入了惰性队列(Lazy Queue)的概念。惰性队列会尽可能地将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、岩机或者由于维护而关闭等)致使长时间 内不能消费消息而造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能地存储在内存之中，这样可以更加快速地将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</p><p>惰性队列会将接收到的消息直接存入文件系统中，而不管是持久化的或者是非持久化的，这样可以减少了内存的消耗，但是会增加I/O 的使用，如果消息是持久化的，那么这样的I/O 操作不可避免，惰性队列和持久化的消息可谓是”最佳拍档”。注意如果惰性队列中存储的是非持久化的消息，内存的使用率会一直很稳定，但是重启之后消息一样会丢失。</p><p>队列具备两种模式: default 和 lazy 。默认的为 default 模式，在 3.6.0 之前的版本无<br>须做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式，那么只能先删除队列，然后再重新声明一个新的。</p><p>在队列声明的时候可以通过 <code>x-queue-mode</code> 参数来设置队列的模式，取值为 default 和lazy 。下面示例演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></tbody></table></figure><p>对应的 Policy 设置方式为:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmqctl set_policy Lazy "^myqueue$" '{"queue-mode":"lazy"}' --apply-to queues</span><br></pre></td></tr></tbody></table></figure><blockquote><p>惰性队列和普通队列相比，只有很小的内存开销。这里很难对每种情况给出一个具体的数<br>值，但是我们可以类比一下:发送1 千万条消息，每条消息的大小为1 KB，并且此时没有任何的消费者，那么普通队列会消耗 1.2GB 的内存，而惰性队列只消耗1.5MB 的内存。</p></blockquote><blockquote><p>据官方测试数据显示，对于普通队列，如果要发送1 千万条消息，需要耗费 801 秒，平均发送速度约为 13000 条/秒。如果使用惰性队列，那么发送同样多的消息时，耗时是 421 秒，平均发送速度约为 24000 条/秒。出现性能偏差的原因是普通队列会由于内存不足而不得不将消息换页至磁盘。如果有消费者消费时，惰性队列会耗费将近 40M 的空间来发送消息，对于一个消费者的情况，平均的消费速度约为 14000 条/秒。</p></blockquote><h1 id="内存及磁盘告警"><a href="#内存及磁盘告警" class="headerlink" title="内存及磁盘告警"></a>内存及磁盘告警</h1><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时，RabbitMQ 都会暂时阻塞(block)客户端的连接(Connection)，并停止接收从客户端发来的消息，以此避免服务崩溃。与此同时，客户端与服务端的心跳检测也会失效。可以通过 <code>rabbitmqctl list_connections</code> 命令或者Web 管理界面来查看它的状态。</p><p>被阻塞的 Connection 的状态要么是 blocking ，要么是 blocked 。前者对应于并不试图发送消息的 Connection ，比如消费者关联的 Connection ，这种状态下的 Connection 可以继续运行。而后者对应于一直有消息发送的 Connection ，这种状态下的 Connection 会被停止发送消息。</p><p>注意在一个集群中，如果 Broker 节点的内存或者磁盘受限，都会引起整个集群中所有的Connection 被阻塞。</p><p>理想的情况是当发生阻塞时可以在阻止生产者的同时而又不影响消费者的运行。但是在 <em>AMQP</em> 协议中，一个信道 (Channel) 上可以同时承载生产者和消费者，同一个 Connection 中也可以同时承载若干个生产者的信道和消费者的信道，这样就会使阻塞逻辑错乱，虽然大多数情况下并不会发生任何问题，但还是建议生产和消费的逻辑可以分摊到独立的 Connection 之上而不发生任何交集。客户端程序可以通过添加 BlockedListener 来监昕相应连接的阻塞信息。</p><h2 id="内存告警"><a href="#内存告警" class="headerlink" title="内存告警"></a>内存告警</h2><p>RabbitMQ 服务器会在启动或者执行 <code>rabbitmqctl set_vm_memory_high_watermark fraction</code> 命令时计算系统内存的大小。默认情况下 vm_memory_high_watermark 的值为 0.4，即内存阈值为 0.4，表示当 RabbitMQ 使用的内存超过 40% 时，就会产生内存告警并阻塞所有生产者的连接。一旦告警被解除(有消息被消费或者从内存转储到磁盘等情况的发生)，一切都会恢复正常。</p><p>默认情况下将 RabbitMQ 所使用内存的阈值设置为 40%，这并不意味着此时 RabbitMQ 能使用超过 40% 的内存，这仅仅只是限制了 RabbitMQ 消息生产者。在最坏的情况下，Erlang 的垃圾回收机制会导致两倍的内存消耗，也就是 80% 的使用占比。</p><blockquote><p>如果设置fraction 为0 ，所有的生产者都会被停止发送消息，这个功能可以适用于需要集群中所有消息发布的情况。正常情况下建议 vm_memory_high_watermark 取值在 0.4 到 0.66 之间，不建议取值超过 0.7。</p></blockquote><p>内存阈值可以通过 rabbitmq.config 配置文件来配置，下面示例中设置了默认的内存阈值为 0.4:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 按比例配置</span></span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {vm_memory_high_watermark, 0.4}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 设置内存阈值的绝对值（默认单位B，1024 MB = 1024 * 1024 * 1024 = 1073741824 B）</span></span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {vm_memory_high_watermark, {absolute, 1073741824}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 设置单位内存阈值</span></span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {vm_memory_high_watermark, {absolute, "1024M"}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可用单位：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> k, kiB: kibibytes (2^10 bytes)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M, MiB: mebibytes (2^20)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> G, GiB: gibibytes (2^30)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kB: kilobytes (10^3)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MB: megabytes (10^6)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GB: gigabytes (10^9)</span></span><br></pre></td></tr></tbody></table></figure><p>与此配置对应的 rabbitmqctl 系列的命令为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1. 按比例</span><br><span class="line">$ rabbitmqctl set_vm_memory_high_watermark {fraction}</span><br><span class="line"></span><br><span class="line"># 2. 按绝对值</span><br><span class="line">$ rabbitmqctl set_vm_memory_high_watermark absolute {memory_limit}</span><br></pre></td></tr></tbody></table></figure><p>在服务器重启之后使用命令方式所设置的阈值会失效，而通过配置文件的方式设置的阈值则不会在重启之后失效，但是修改后的配置需要在重启之后才能生效。</p><p>在某个 Broker 节点触及内存并阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间。持久化和非持久化的消息都会被转储到磁盘中，其中持久化的消息本身就在磁盘中有1 份副本，这里会将持久化的消息从内存中清除掉。</p><p>默认情况下，在内存到达内存阐值的 50% 会进行换页动作。也就是说，在默认的内存阈值为 0.4 的情况下，当内存超过 0.4 * 0.5 = 0.2 时会进行换页动作。可以通过在配置文件中配置<br><code>vm_memory_high_watermark_paging_ratio</code> 项来修改此值，下面示例中将换页比率从默认的 0.5 修改为 0.75：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {vm_memory_high_watermark_paging_ratio, 0.75},</span><br><span class="line">            {vm_memory_high_watermark, 0.4}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><p>上面的配置会在 RabbitMQ 存使用率达到 0.3 时进行换页动作，并在 40% 时阻塞生产者。可以将 <code>vm_memory_high_watermark_paging_ratio</code> 值设置为大于1 的浮点数，这种配置相当于禁用了换页功能。注意这里 RabbitMQ 中并没有类似 rabbitmqctl vm_memory_high_watermark_paging_ratio {xxx} 的命令。</p><p>如果 RabbitMQ 无法识别所在的操作系统，那么在启动的时候会在日志文件中追加一些信息，并将内存的值假定为 1GB 相应的日志信息参考如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unknown total memory size for your OS {unix,magic_homebrew_os}. Assuming memory size is 1024MB.</span><br></pre></td></tr></tbody></table></figure><p>对应 <code>vm_memory_high_watermark</code> 为 0.4 的情形来说，RabbitMQ 的内存阈值就约为 410MB。如果操作系统本身的内存大小为 8GB ，可以将 <code>vm_memory_high_watermark</code> 设置3 ，这样内存阁值就提高到了 3GB。</p><h2 id="磁盘告警"><a href="#磁盘告警" class="headerlink" title="磁盘告警"></a>磁盘告警</h2><p>当剩余磁盘空间低于确定的阈值时，RabbitMQ 同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。默认情况下，磁盘阈值为 50MB，这意味着当磁盘剩余空间低于 50MB 时会阻塞生产者并停止内存中消息的换页动作。这个阈值的设置可以减小但不能完全消除因磁盘耗尽而导致崩溃的可能性，比如在两次磁盘空间检测期间内，磁盘空间从大于 50MB 被耗尽到 0MB。一个相对谨慎的做法是将磁盘阈值设置为与操作系统所显示的内存大小一致。</p><p>Broker 节点启动的时候会默认开启磁盘检测的进程，相对应的服务日志为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Disk free limit set to 50MB</span><br></pre></td></tr></tbody></table></figure><p>对于不识别的操作系统而言，磁盘检测功能会失效，对应的服务日志为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Disabling disk free space monitoring</span><br></pre></td></tr></tbody></table></figure><p>RabbitMQ 会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关。正常情况下，每 10 秒执行一次检测，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。当要到达磁盘阈值时，检测频率为每秒 10 次，这样有可能会增加系统的负载。</p><p>可以通过在配置文件中配置 <code>disk_free_limit</code> 项来设置磁盘阈值。下面示例中将磁盘阈值设置为 1G 左右：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {disk_free_limit, 1000000000}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单位设置</span></span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {disk_free_limit, "1GB"}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><p>还可以参考机器内存的大小为磁盘阈值设置一个相对的比值。比如将磁盘阈值设置为与集群内存一样大：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {disk_free_limit, {mem_relative, 1.0}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure><p>与绝对值和相对值这两种配置对应的 rabbitmqctl 系列的命令为: <code>rabbitmqctl set_disk_free_limit {disk_limit}</code> 和 <code>rabbitmqctl set_disk_free_limit mem_relative {fraction}</code>，和内存阈值的设置命令一样，Broker 重启之后将会失效。同样，通过配置文件的方式设置的阈值则不会在重启之后失效，但是修改后的配置需要在重启之后才能生效。正常情况下，建议相对内存比值取值为1.0 和2.0 之间。</p><h1 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h1><p>RabbitMQ 可以对内存和磁盘使用量设置阈值，当达到阈值后，生产者将被阻塞(block)直到对应项恢复正常。除了这两个阈值，从 2.8.0 版本开始，RabbitMQ 还引入了流控 (<em>Flow Control</em>) 机制来确保稳定性。流控机制是用来避免消息的发送速率过快而导致服务器难以支撑的情形，内存和磁盘告警相当于全局的流控 (<em>Global Flow Control</em>) ，一旦触发会阻塞集群中所有的 Connection ，而本节的流控是针对单个 Connection 的，可以称之为 <em>Per-Connection Flow Control</em> 或者 <em>Intemal Flow Control</em> 。</p><h2 id="流控原理"><a href="#流控原理" class="headerlink" title="流控原理"></a>流控原理</h2><p>Erlang 进程之间并不共享内存(binary类型的除外)，而是通过消息传递来通信，每个进程都有自己的进程邮箱(mailbox) 。默认情况下 Erlang 并没有对进程邮箱的大小进行限制，所以当有大量消息持续发往某个进程时，会导致该进程邮箱过大，最终内存溢出并崩溃。RabbitMQ 中，如果生产者持续高速发送，而消费者消费速度较低时，如果没有流控，很快就使内部进程邮箱的大小达到内存阀值。</p><p>RabbitMQ 使用了一种基于信用证算法 (credit-based algorithm) 的流控机制来限制发送消息的速率以解决前面所提出的问题，它通过监控各个进程的进程邮箱，当某个进程负载过高而来不及处理消息时，这个进程的进程邮箱就会开始堆积消息。当堆积到一定量时，就会阻塞而不接收上游的新消息。从而慢慢地，上游进程的进程邮箱也会开始堆积消息。当堆积到一定量时也会阻塞而停止接收上游的消息，最后就会使负责网络数据包接收的进程阻塞而暂停接收新的数据。</p><p>以下图为例，进程A 接收消息并转发至进程B ，进程B 接收消息并转发至进程C 。每个进程中都有一对关于收发消息的credit 值。以进程B 为例， {{credit_from, C}, value} 表示能发送多少条消息给C ，每发送一条消息该值减 1，当为 0 时，进程B 不再往进程C 发送消息也不再接收进程 A 的消息。 {{credit_to, A}, value} 表示再接收多少条消息就向进程A 发送增加 credit 值的通知，进程A 接收到该通知后就增加 {{credit_from, B}, value} 所对应的值，这样进程A 就能持续发送消息。当上游发送速率高于下游接收速率时，credit<br>值就会被逐渐耗光，这时进程就会被阻塞，阻塞的情况会一直传递到最上游。当上游进程收到来自下游进程的增加 credit 值的通知时，若此时上游进程处于阻塞状态则解除阻塞，开始接收更上游进程的消息，一个个传导最终能够解除最上游的阻塞状态。由此可知，基于信用证的流控机制最终将消息发送进程的发送速率限制在消息处理进程的处理能力范围之内。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-flowcontrol1.png" alt="image"></p><p>一个连接 (Connection) 触发流控时会处于 “flow” 的状态，也就意味着这个 Connection 的状态每秒在 blocked 和unblocked 之间来回切换数次，这样可以将消息发送的速率控制在服务器能够支撑的范围之内。可以通过 <code>rabbitmqctl_list_connections</code> 命令或者 Web 管理页面来查看Connection 状态。</p><p>处于 flow 状态的 Connection 和处于 running 状态的 Connection 并没有什么不同，这个状态只是告诉系统管理员相应的发送速率受限了，而对于客户端而言，它看到的只是服务器的带宽要比正常情况下要小一些。</p><p>流控机制不只是作用于Connection ，同样作用于信道(Channel)和队列。从Connection 到Channel，再到队列，最后是消息持久化存储形成一个完整的流控链，对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞，也就是说，如果某个进程达到性能瓶颈，必然会导致上游所有的进程被阻塞。所以我们可以利用流控机制的这个特点找出瓶颈之所在。处理消息的几个关键进程及其对应的顺序关系如下图所示：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-flowcontrol2.png" alt="image"></p><p>其中的各个进程如下所述：</p><ul><li>rabbit_reader: Connection 的处理进程，负责接收、解析 AMQP 协议数据包等；</li><li>rabbit_channel: Channel 的处理进程，负责处理 AMQP 协议的各种方法、进行路由解析等；</li><li>rabbit_amqqueue_process: 队列的处理进程，负责实现队列的所有逻辑；</li><li>rabbit_msg_store: 负责实现消息的持久化；</li></ul><p>当某个 Connection 处于 flow 状态，但这个 Connection 没有一个 Channel 处于 flow 状态时，这就意味这个 Connection 中有一个或者多个 Channel 出现了性能瓶颈。某些 Channel 程的运作(比如处理路由逻辑)会使得服务器 CPU 的负载过高从而导致了此种情形。尤其是在发送大量较小的非持久化消息时，此种情形最易显现。</p><p>当某个 Connection 处于 flow 状态，并且这个 Connection 中也有若干个 Channel 处于 flow 状态，但没有任何一个对应的队列处于 flow 状态时，这就意味着有一个或者多个队列出现了性能瓶颈。这可能是由于将消息存入队列的过程中引起服务器 CPU 负载过高，或者是将队列中的消息存入磁盘的过程中引起服务器I/O 负载过高而引起的此种情形。尤其是在发送大量较小的持久化消息时，此种情形最易显现。</p><p>当某个 Connection 处于 flow 状态，同时这个 Connection 中也有若干个 Channel 处于 flow<br>状态，并且也有若干个对应的队列处于 flow 状态时，这就意味着在消息持久化时出现了性能瓶颈。在将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较大的持久化消息时，此种情形最易显现。</p><h1 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h1><p>如果 RabbitMQ 集群是由多个 Broker 节点组成的，那么从服务的整体可用性上来讲，该集群对于单点故障是有弹性的，但是同时也需要注：尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上的存储的消息却不行，这是因为队列进程及其内容仅仅维持在单个节点之上，所以一个节点的失效表现为其对应的队列不可用。</p><p>引入镜像队列 (Mirror Queue) 的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。在通常的用法中，针对每一个配置镜像的队列(以下简称镜像队列)都包含一个主节点(master) 和若干个从节点(slave)，相应的结构可以参考下图：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-mirror-queue.png" alt="image"></p><p>slave 会准确地按照 master 执行命令的顺序进行动作，故slave 与master 上维护的状态应该是相同的。如果master 由于某种原因失效，那么”资历最老”的slave 会被提升为新的 master。根据slave 加入的时间排序，时间最长的slave即为”资历最老”。发送到镜像队列的所有消息会<br>被同时发往master 和所有的slave 上，如果此时master 挂掉了，消息还会在slave 上，这样slave 提升为master 的时候消息也不会丢失。除发送消息(Basic.Publish) 外的所有动作都只会向master 发送，然后再由master 将命令执行的结果广播给各个slave。</p><p>如果消费者与slave 建立连接并进行订阅消费，其实质上都是从master 上获取消息。比如消费者与slave 建立了TCP 连接之后执行一个 Basic.Get 的操作，那么首先是由slave 将 Basic.Get 请求发往master ，再由master 准备好数据返回给slave ，最后由slave 投递给消费者。</p><blockquote><p>这里大多的读写压力都落到了master 上，是否负载会做不到有效的均衡？或者说是否可以像 MySQL 一样能够实现master 写而slave 读呢？注意这里的master 和slave 是针对队列而言的，而队列可以均匀地散落在集群的各Broker 节点中以达到负载均衡的目的，因为真正的负载还是针对实际的物理机器而言的，而不是内存中驻留的队列进程。</p></blockquote><p>注意要点：</p><p>RabbitMQ 的镜像队列同时支持 publisher confirm 和事务两种机制。在事务机制中，只有当前事务在全部镜像中执行之后，客户端才会收到Tx.Commit-Ok 的消息。同样的，在publisher confirm 机制中生产者进行当前消息确认的前提是该消息被全部进行所接收了。</p><p>不同于普通的非镜像队列，镜像队列的 backing_queue 比较特殊，其实现并非是 <code>rabbit_variable_queue</code>，它内部包裹了普通 backing_queue 进行本地消息消息持久化处理，在此基础上增加了将消息和ack 复制到所有镜像的功能。镜像队列的结构可以参考下图，master 的backing_queue 采用的是 <code>rabbit_mirror_queue_master</code>，而slave 的backing queue 实现是 <code>rabbit_mirror_queue_slave</code>。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-mirror-queue2.png" alt="image"></p><p>所有对 <code>rabbit_mirror_queue_master</code> 的操作都会通过组播 GM (Guaranteed Multicast) 的方式同步到各个slave 中。GM 负责消息的广播，<code>rabbit_mirror_queue_slave</code> 负责回调处理，而 master 上的回调处理是由 coordinator 负责完成的，如前所述，除了Basic.Publish，所有的操作都是通过master 来完成的，master 消息进行处理的同时将消息的处理通过 GM 广播给所有的 slave，slave GM 收到消息后，通过回调交由<br><code>rabbit_mirror queue_slave</code> 进行实际的处理。</p><p>GM 模块实现的是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到，它的实现大致为：</p><p>将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上，当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。在master 和slave 上的这些 GM 形成一个组(gm_group)，这个组的信息<br>会记录在Mnesia 中。不同的镜像队列形成不同的组。操作命令从master 对应的GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表，master 对应的GM 最终会收<br>到自己发送的操作命令，这个时候master 就知道该操作命令都同步到了所有的slave 上。</p><p>当slave 挂掉之后，除了与slave 相连的客户端连接全部断开，没有其他影响。当master 挂掉之后，会有以下连锁反应：</p><ol><li>与master 连接的客户端连接全部断开；</li><li>选举最老的slave 作为新的master ，因为最老的slave 与旧的master 之间的同步状态应该是最好的。如果此时所有slave 处于未同步状态，则未同步的消息会丢失；</li><li>新的master 重新入队所有 unack 的消息，因为新的slave 无法区分这些unack 的消息是否已经到达客户端，或者是ack 信息丢失在老的master 链路上，再或者是丢失在老的master 组播ack 消息到所有slave 的链路上，所以出于消息可靠性的考虑，重新入队所有unack 的消息，不过此时客户端可能会有重复消息；</li><li>如果客户端连接着slave ，并且Basic.Consume 消费时指定了 <code>x-cancel-on-ha-failover</code> 参数，那么断开之时客户端会收到一个 Consumer Cancellation Notification 的通知，消费者客户端中会回调Consumer 接口的handleCancel 方法。如果未指定 <code>x-cancel-on-ha-failover</code> 参数，那么消费者将无法感知master 宕机；</li></ol><p>镜像队列的配置主要是通过添加相应的Policy 来完成的，</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to) {name} {pattern} {definition}</span><br></pre></td></tr></tbody></table></figure><p>命令中的definition 部分，对于镜像队列的配置来说，需要包含3 个部分：ha-mode、ha-params 和ha-sync-mode。</p><ul><li>ha-mode：指明镜像队列的模式，有效值为all、exactly、nodes，默认为all；<ul><li>all 表示在集群中所有的节点上进行镜像；</li><li>exactly 表示在指定个数的节点上进行镜像，节点个数由 ha-params 指定；</li><li>nodes 表示在指定节点上进行镜像，节点名称通过 ha-params 指定，节点的名称通常类似于rabbit@hostname ，可以通过<code>rabbitmqctl cluster_status</code>命令查看到；</li></ul></li><li>ha-params：不同的 ha mode 配置中需要用到的参数；</li><li>ha-sync-mode：队列中消息的同步方式，有效值为automatic 和manual；</li></ul><p>举个例子，对队列名称以 “queue_” 开头的所有队列进行镜像，并在集群的两个节点上完成镜像，Policy 的设置命令为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "^queue_" '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</span><br></pre></td></tr></tbody></table></figure><p>ha-mode 参数对排他队列并不生效，因为排他队列是连接独占的，当连接断开时队列会自动删除，所以实际上这个参数对排他队列没有任何意义。</p><p>将新节点加入已存在的镜像队列时，默认情况下 ha-sync-mode 取值为 manual，镜像队列中的消息不会主动同步到新的 slave 中，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行其他操作，直到同步完成。当 ha-sync-mode 设置为 automatic 时，新加入的 slave 会默认同步已知的镜像队列，由于同步过程的限制，所以不建议对生产环境中正在使用的队列进行操作。使用 <code>rabbitmqctl list_queues {name} slave_pids synchronised_slave_pids</code> 命令可以查看哪些 slaves 已经完成同步。通过手动方式同步一个队列的命令为 <code>rabbitrnqctl sync_queue {name}</code> ，同样也可以取消某个队列的同步操作: <code>rabbitmqctl cancel_sync_queue {name}</code>。</p><p>当所有 slave 都出现未同步状态，并且 <code>ha-promote-on-shutdown</code> 设置为 <code>when-synced</code><br>(默认)时，如果 master 因为主动原因停掉，比如通过 <code>rabbitmqctl stop</code> 命令或者优雅关闭操作系统，那么 slave 不会接管 master ，也就是此时镜像队列不可用；但是如果 master 因为被动原因停掉，比如 Erlang 虚拟机或者操作系统崩溃，那么 slave 会接管 master。这个配置项隐含的价值取向是保证消息可靠不丢失，同时放弃了可用性。如果<code>ha-promote-on-shutdown</code> 设置为always ，那么不论 master 因为何种原因停止，slave 都会接管 master，优先保证可用性，不过消息可能会丢失。</p><p>镜像队列中最后一个停止的节点会是 master ，启动顺序必须是 master 先启动。如果 slave 先启动，它会有 30 秒的等待时间，等待 master 的启动，然后加入到集群中。如果 30 秒内 master<br>没有启动，slave 会自动停止。当所有节点因故(断电等)同时离线时，每个节点都认为自己不是最后一个停止的节点，要恢复镜像队列，可以尝试在 30 秒内启动所有节点。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;存储机制&quot;&gt;&lt;a href=&quot;#存储机制&quot; class=&quot;headerlink&quot; title=&quot;存储机制&quot;&gt;&lt;/a&gt;存储机制&lt;/h1&gt;&lt;p&gt;不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。持久化的消息在到达队列时就被写入到磁盘，并且如果可以，持久化的消息也会在内存中保存一份备份，这样可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。这两种类型的消息的落盘处理都在RabbitMQ 的”持久层”中完成。&lt;/p&gt;
&lt;p&gt;持久层是一个逻辑上的概念，实际包含两个部分队列索引(rabbit_queue_index) 和消息存储 (rabbit_msg_store)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rabbit_queue_index 负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付给消费者、是否已被消费者 ack 等。&lt;/li&gt;
&lt;li&gt;rabbit_msg_store 以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。rabbit_msg_store 具体还可以分为：&lt;ul&gt;
&lt;li&gt;msg_store_persistent 负责持久化消息的持久化，重启后消息不会丢失。&lt;/li&gt;
&lt;li&gt;msg_store_transient 负责非持久化消息的持久化，重启后消息会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://haifuns.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 集群</title>
    <link href="https://haifuns.com/2020/12/26/rabbitmq-2/"/>
    <id>https://haifuns.com/2020/12/26/rabbitmq-2/</id>
    <published>2020-12-26T08:16:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩溃的情况下继续运行，它可以通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端能够重新连接到集群中的任何其他节点并继续生产或者消费。</p><p>不过 RabbitMQ 集群不能保证消息的万无一失，即将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式。当集群中一个 RabbitMQ 节点崩溃时，该节点上的所有队列中的消息也会丢失。</p><p>RabbitMQ 集群中的所有节点都会备份所有的元数据信息，包括以下内容：</p><ul><li>队列元数据：队列的名称及属性；</li><li>交换器：交换器的名称及属性；</li><li>绑定关系元数据：交换器与队列或者交换器与交换器之间的绑定关系；</li><li>vhost 元数据：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性;</li></ul><p>但是<strong>不会备份消息</strong>(当然通过特殊的配置比如镜像队列可以解决这个问题，以后会有介绍)。基于存储空间和性能的考虑，在RabbitMQ 集群中创建队列，集群只会在单个节点而不是在所有节点上创建队列的进程并包含完整的队列信息(元数据 、状态、内容)。这样只有队列的宿主节点即所有者节点知道队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者会丢失其所订阅的信息，并且任何匹配该队列绑定信息的新消息也都会消失。</p><p>不同于队列那样拥有自己的进程，交换器其实只是一个名称和绑定列表。当消息发布到交换器时，实际上是由所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后再路由消息。当创建一个新的交换器时，RabbitMQ 所要做的就是将绑定列表添加到集群中的所有节点上。这样，每个节点上的每条信道都可以访问到新的交换器了。</p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><span id="more"></span><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>准备三台虚拟机，主机名分别为node1、node2、node3</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/hosts</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加ip 主机名映射</span></span><br><span class="line"></span><br><span class="line">192.168.0.90 node1</span><br><span class="line">192.168.0.91 node2</span><br><span class="line">192.168.0.81 node3</span><br></pre></td></tr></tbody></table></figure></li><li><p>分别安装rabbitmq</p></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加erlang 源至yum存储库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -Uvh https://download.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget https://packages.erlang-solutions.com/erlang-19.0.4-1.el7.centos.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -Uvh erlang-19.0.4-1.el7.centos.x86_64.rpm</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装erlang</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum -y install erlang</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入RabbitMQ源</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -Uvh https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装RabbitMQ公共库秘钥</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装RabbitMQ</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加mq开机自启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chkconfig rabbitmq-server on</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以守护进程方式后台运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-server -detached</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动RabbitMQ服务 端口5672</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server start</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭RabbitMQ服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看RabbitMQ服务状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server status</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl status</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已开启插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins list</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启管理页面 端口15672</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除默认用户 guest/guest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl delete_user guest</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl add_user  {username} {password}</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_user_tags {username} administrator</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限（最大）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl set_permissions -p / {username} <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看确认权限赋予是否成功</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_user_permissions {username}</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_password {username} {new_password}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="交换密钥令牌"><a href="#交换密钥令牌" class="headerlink" title="交换密钥令牌"></a>交换密钥令牌</h3><p>编辑 RabbitMQ cookie 文件，以确保各个节点的 cookie 文件使用的是同一个值。</p><p>可以读取 node1 节点的 cookie 然后将其复制到 node2 node3 节点中 cookie 文件默认路径为 /var/lib/rabbitmq/.erlang.cookie。</p><p>cookie 相当于密钥令牌，集群中的 RabbitMQ 节点需要通过交换密钥令牌以获得相互认证，如果节点的密钥令牌不一致，那么在配置节点时就会报错。</p><h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>配置集群有三种方式:</p><ul><li>通过 rabbitmqctl 工具的方式配置集群，这种方式也是最常用的方式，下面的演示也将使用rabbitmqctl 进行配置</li><li>rabbitmq.config 配置文件配置</li><li>通过 rabbitmq-autocluster 插件配置</li></ul><p>任选一个节点（以node1为例）为基准，将另外的节点加入选中节点集群</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node2 &amp; node3</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭RabbitMQ 应用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将节点重置还原到最初状态。包括从原来所在的集群中删除此节点，从管理数据库中删除所有的配置数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl reset</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将节点加入指定集群中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动RabbitMQ 应用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app</span></span><br></pre></td></tr></tbody></table></figure><p>查看各节点状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br></pre></td></tr></tbody></table></figure><p>如果关闭了集群中的所有节点，则需要确保在启动的时候最后关闭的那个节点是第一个启动。如果第一个启动的不是最后关闭的节点，那么这个节点会等待最后关闭的节点启动。这个等待时间是30 秒，如果没有等到，那么这个先启动的节点也会失败。在最新的版本中会有重试机制，默认重试30 秒以等待最后关闭的节点启动。</p><p>如果最后一个关闭的节点最终由于某些异常而无法启动，则可以通过 <code>rabbitmqctl forget_cluster_node</code> 命令来将此节点剔出当前集群。</p><p>例如，集群中节点按照 node3 node2 node1 顺序关闭，此时如果要启动集群，就要先启动 node1 节点。这里可以在 node2 节点中执行命令将 node1 节点剔除出当前集群：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --offline 参数可以在非运行状态下将 node1 剥离出当前集群</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node rabbit@node1 --offline</span></span><br></pre></td></tr></tbody></table></figure><p>如果集群中的所有节点由于某些非正常因素，比如断电而关闭，那么集群中的节点都会认为还有其他节点在它后面关闭，此时需要调用以下命令来启动一个节点，之后集群才能正常启动。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl force_boot</span></span><br></pre></td></tr></tbody></table></figure><h2 id="集群节点类型"><a href="#集群节点类型" class="headerlink" title="集群节点类型"></a>集群节点类型</h2><p>在使用 <code>rabbitmqctl cluster_status</code> 命令来查看集群状态时会有 {nodes [{disc, [rabbit@nodel, rabbit@node2, rabbit@node3]}]} 一项信息，其中的 disc 标注了RabbitMQ 节点的类型。</p><ul><li>disc 磁盘节点</li><li>ram 内存节点</li></ul><p>内存节点将所有的队列、交换器、绑定关系、用户、权限和 host 的元数据定义都存储在内存中，而磁盘节点则将这些信息存储到磁盘中。</p><p>单节点的集群中必然只有磁盘类型的节点，否则当重启MQ之后，所有关于系统的配置信息都会丢失。不过在集群中，可以选择配置部分节点为内存节点，这样可以获得更高的性能。</p><p>比如将node2 节点加入node1 节点的时候可以指定node2 节点的类型为内存节点（默认磁盘节点）：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl join_cluster rabbit@node1 --ram</span></span><br></pre></td></tr></tbody></table></figure><p>如果集群已经搭建好了，可以使用<code>rabbitmqctl change_cluster_node_type {disc ram}</code>命令来切换节点的类型：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将node2 从内存节点转换为磁盘节点</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl change_cluster_node_type disc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl start_app</span></span><br></pre></td></tr></tbody></table></figure><h2 id="剔除单个节点"><a href="#剔除单个节点" class="headerlink" title="剔除单个节点"></a>剔除单个节点</h2><p>有两种方式将 node2 剥离出当前集群:</p><p>第一种： 在 node2 节点上执行<code>rabbitmqctl stop_app</code>或者<code>rabbitmqctl stop</code> 命令来关闭RabbitMQ 服务。之后再在 node1 节点或者 node3 节点上执行<code>rabbitmqctl forget_cluster_node rabbit@node2</code>命令将 node1 节点剔除出去。这种方式适合 node2 节点不再运行RabbitMQ 情况。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl stop_app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> node1 | node3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node rabbit@node2</span> </span><br></pre></td></tr></tbody></table></figure><p>第二种： 在 node2 上执行 <code>rabbitmqctl reset</code> 命令。如果不是由于启动顺序的缘故而不得不删除一个集群节点，建议采用这种方式。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl forget_cluster_node rabbit@node1 --offline</span></span><br></pre></td></tr></tbody></table></figure><p><code>rabbitmqctl reset</code> 命令将清空节点的状态并将其恢复到空白状态。当重设的节点是集群中的一部分时，该命令也会和集群中的磁盘节点进行通信，告诉它们该节点正在离开集群。不然集群会认为该节点出了故障 并期望其最终能够恢复过来。</p><h2 id="集群节点升级"><a href="#集群节点升级" class="headerlink" title="集群节点升级"></a>集群节点升级</h2><h3 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h3><p>如果 RabbitMQ 集群由单独的一个节点组成，那么升级版本很容易，只需关闭原来的服务，然后解压新的版本再运行即可。不过要确保原节点的 Mnesia 中的数据不被变更，且新节点中的 Mnesia 路径的指向要与原节点中的相同。或者说保留原节点 Mnesia 数据 然后解压新版本到相应的目录，再将新版本的 Mnesia 路径指向保留的 Mnesia数据的路径（也可以直接复制保留 Mnesia 数据到新版本中相应的目录），最后启动新版本的服务即可。</p><h3 id="多节点"><a href="#多节点" class="headerlink" title="多节点"></a>多节点</h3><p>如果 RabbitMQ 集群由多个节点组成，那么也可以参考单个节点的情形。具体步骤如下：</p><ol><li>关闭所有节点的服务 注意采用 <code>rabbitmqctl stop</code> 命令关闭。</li><li>保存各个节点的 Mnesia 数据</li><li>解压新版本的 RabbitMQ 到指定的目录</li><li>指定新版本的 Mnesia 路径为步骤2保存的 Mnesia 数据路径</li><li>启动新版本的服务，注意先重启原版本中最后关闭的那个节点</li></ol><p>其中步骤4步骤5可以一起操作，比如执行 <code>RABBITMQ MNESIA BASE=/opt/mnesia rabbitmq-server-detached</code> 命令，其中 /opt/mnesia 为原版本保存 Mnesia 数据的路径。</p><h2 id="服务日志"><a href="#服务日志" class="headerlink" title="服务日志"></a>服务日志</h2><p>RabbitMQ 的日志默认存放在$RABBITMQ_HOME/var/log/rabbitmq 文件夹内。在这个文件夹内 RabbitMQ 会创建两个日志文件 RABBITMQ_NODENAME-sasl.log 和 RABBITMQ_NODENAME.log 。</p><ul><li>RABBITMQ_NODENAME-sasl.log 记录 Erlang 相关信息，例如查看 Erlang 崩溃报告。</li><li>RABBITMQ_NODENAME.log 记录 RabbitMQ 应用服务日志。</li></ul><h2 id="单节点故障恢复"><a href="#单节点故障恢复" class="headerlink" title="单节点故障恢复"></a>单节点故障恢复</h2><p>RabbitMQ 使用过程中，或多或少都会遇到一些故障，对于集群层面来说，更多的是单点故障。所谓的单点故障是指集群中单个节点发生了故障，有可能会引起集群服务不可用、数据丢失等异常。配置数据节点冗余（镜像队列）可以有效地防止由于单点故障而降低整个集群的可用性、可靠性。</p><p>单节点故障包括：机器硬件故障、机器掉电、网络异常、服务进程异常。</p><h3 id="机器硬件故障"><a href="#机器硬件故障" class="headerlink" title="机器硬件故障"></a>机器硬件故障</h3><p>单节点机器硬件故障包括机器硬盘、内存、主板等故障造成的死机，无法从软件角度来恢复，此时需要在集群中的其他节点中执行<code>rabbitmqctl forget_cluster_node {nodename}</code> 命令来将故障节点剔除。</p><p>如果之前有客户端连接到此故障节点上，在故障发生时会有异常报出，此时需要将故障节点的ip地址从连接列表里删除，并让客户端重新与集群中的节点建立连接，以恢复整个应用。如果此故障机器修复或者原本有备用机器，那么也可以选择性的添加到集群中。</p><h3 id="机器掉电故障"><a href="#机器掉电故障" class="headerlink" title="机器掉电故障"></a>机器掉电故障</h3><p>当遇到机器掉电故障，需要等待电源接通之后重启机器。此时这个机器节点上的 RabbitMQ 处于 stop 状态，但是此时不要盲目重启服务，否则可能会引起网络分区。</p><p>此时同样需要在其他节点上执行 <code>rabbitmqctl forget_cluster_node {nodename}</code> 命令将此节点从集群中剔除，然后删除当前故障机器的 RabbitMQ 中的 Mnesia<br>数据（相当于重置），然后再重启 RabbitMQ 服务，最后再将此节点作为一个新的节点加入到当前集群中。</p><h3 id="网络异常"><a href="#网络异常" class="headerlink" title="网络异常"></a>网络异常</h3><p>网线松动或者网卡损坏都会引起网络故障的发生。</p><ul><li><p>对于网线松动，无论是彻底断开，还是“藕断丝连”，只要它不降速，RabbitMQ 集群就没有任何影响，但是为了保险起见，建议先关闭故障机器的 RabbitMQ 进程，然后对网线进行更换或者修复操作，之后再考虑是否重新开启RabbitMQ 进程。</p></li><li><p>而网卡故障极易引起网络分区的发生，如果监控到网卡故障而网络分区尚未发生时，理应第一时间关闭此机器节点上的 RabbitMQ 进程，在网卡修复之前不建议再次开启，如果己经发生了网络分区，可以进行手动恢复网络分区。</p></li></ul><h3 id="服务进程异常"><a href="#服务进程异常" class="headerlink" title="服务进程异常"></a>服务进程异常</h3><p>对于服务进程异常，如 RabbitMQ 进程非预期终止，需要预先思考相关风险是否在可控范围之内。如果风险不可控，可以选择抛弃这个节点。一般情况下，重新启动 RabbitMQ 服务进程即可。</p><h2 id="集群迁移"><a href="#集群迁移" class="headerlink" title="集群迁移"></a>集群迁移</h2><h3 id="元数据重建"><a href="#元数据重建" class="headerlink" title="元数据重建"></a>元数据重建</h3><p>元数据重建是指在新的集群中创建原集群的队列、交换器、绑定关系、host 、用户、权限和Parameter 等数据信息。元数据重建之后才可将原集群中的消息及客户端连接迁移过来。</p><p>有很多种方法可以重建元数据，比如通过手工创建或者使用客户端创建。通过人工的方式来整理元数据是极其烦琐、低效的，且时效性太差，不到万不得已不建议使用，可以通过 Web 管理界面的方式重建，直接在 <em>Import / export definitions</em> 下载集群的元数据信息json文件。然后导入新集群。</p><p>这种方式需要考虑三个问题：</p><p><strong>1. 如果原集群突发故障，又或者开启 RabbitMQ Management 插件的那个节点机器故障不可修复，就无法导出原集群的元数据。</strong></p><p>这个问题 很好解决，采取一个通用的备份任务在元数据有变更或者达到某个存储周期时将最新的元数据配置备份至另一处安全的地方。这样在遇到需要集群迁移时，可以获取到最新的元数据。</p><p><strong>2. 如果新旧集群的 RabbitMQ 版本不一致时会出现异常情况。</strong></p><p>比如新建立了3.6.10 版本的集群，旧集群版本为3.5.7 ，这两个版本元数据就不相同。3.5.7 版本中的user 项的内容 3.6.10 版本的加密算法是不一样。</p><p>这里可以简单地在 Shell 控制台输入变更密码的方式来解决这个问题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmqctl change_password {username} {new_password}</span><br></pre></td></tr></tbody></table></figure><p>如果还是不能成功上传元数据，那么就需要进一步采取措施。首先对于用户、策略、权限这种元数据来说内容相对固定，且内容较少，手工重建的代价较小。相反集群中元数据最多且最复杂的要数队列、交换器和绑定这三项的内容，这三项内容还涉及其内容的参数设置，如果采用人工重建的方式代价太大，重建元数据的意义其实就在于重建队列、交换器及绑定这三项的相关信息。</p><ul><li>这里有个小窍门，可以将3.6.10 的元数据从 queues 这一项前面的内容，包括 rabbit_version 、users、vhosts、permissions、parameters、global_parameters和policies<br>这几项内容复制后替换 3.5.7 版本中的 queues 这一项前面的所有内容然后再保存。之后将修改<br>并保存过后的 3.5.7 版本的元数据 JSON 文件上传到新集群 3.6.10 版本的 Web 管理界面中，至此就完成了集群的元数据重建。</li></ul><p><strong>3. 如果采用上面的方法将元数据在新集群上重建，则所有的队列都只会落到同一个集群节点上，而其他节点处于空置状态，这样所有的压力将会集中到这单台节点之上。</strong></p><p>处理这个问题，有两种方式，都是通过程序（或者脚本）的方式在新集群上建立元数据，而非简单地在页面上上传元数据文件而己。</p><ul><li>第一种方式是通过 HTTPAPI 接口创建相应的数据</li><li>第二种方式是随机连接集群中不同的节点的地址，然后再创建队列。与前一种方式需要节点名称的列表不同，这里需要的是节点IP地址列表。</li></ul><h3 id="数据迁移和客户端连接切换"><a href="#数据迁移和客户端连接切换" class="headerlink" title="数据迁移和客户端连接切换"></a>数据迁移和客户端连接切换</h3><p>元数据重建为集群迁移前必要的准备工作，在迁移过程中的主要工作步骤如下：</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>首先需要将生产者的客户端与原 RabbitMQ 集群的连接断开，然后再与新的集群建立新的连接，这样就可以将新的消息流转入到新的集群中。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>一种是等待原集群中的消息全部消费完之后再将连接断开，然后与新集群建立连接进行消费作业。可以通过 Web 页面查看消息是否消费完成。也可以通过 <code>rabbitmqctl list_queues name messages messages_ready messages_unacknowledged</code> 命令来查看是否有未被消费的消息。</p><p>当原集群服务不可用或者出现故障造成服务质量下降而需要迅速将消息流切换到新的集群中时，此时就不能等待消费完原集群中的消息，这里需要及时将消费者客户端的连接切换到新的集群中，那么在原集群中就会残留部分未被消费的消息，此时需要做进一步的处理。如果原集群损坏，可以等待修复之后将数据迁移到新集群中，否则会丢失数据。</p><h4 id="数据迁移原理"><a href="#数据迁移原理" class="headerlink" title="数据迁移原理"></a>数据迁移原理</h4><p>数据迁移的主要原理是先从原集群中将数据消费出来，然后存入一个缓存区中，另一个线程读取缓存区中的消息再发布到新的集群中完成数据迁移。</p><p>RabbitMQ 本身提供的 Federation Shove 插件都可以实现此功能，确切地说 Shove 插件更贴近，不过自定义的迁移工具（可以称之为RabbitMQ ForwarMaker）可以让迁移系统更加高效、灵活。</p><h3 id="自动化迁移"><a href="#自动化迁移" class="headerlink" title="自动化迁移"></a>自动化迁移</h3><p>要实现集群自动化迁移，需要在使用相关资源时就做好一些准备工作，方便在自动化迁移过程中进行无缝切换。</p><p>与生产者和消费者客户端相关的是交换器、队列及集群的信息，如果这种类型的资源发生改变时需要让客户端迅速感知，以便进行相应的处理，则可以通过将相应的资源加载到 ZooKeeper 的相应节点中，然后在客户端为对应的资源节点加入 watcher 来感知变化，当然这个功能使用 etc 或者集成到公司层面的资源配置中心中会更加标准、高效。</p><p>如图所示，将整个 RabbitMQ 集群资源的使用分为三个部分：客户端、集群、 ZooKeeper配置管理。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-autobackup.png" alt="image"></p><p>在集群中创建元数据资源时都需要在 ZooKeeper 生成相应的配置，比如在 cluster1 集群中创建交换器 exchange1 之后，需要在 /rmqNode/exchanges 路径下创建实节点 exchange1 并赋予节点的数据内容为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster=cluster1 # 表示此交换器所在的集群名称</span><br><span class="line">exchangeType=direct # 表示此交换器的类型</span><br><span class="line">vhost=vhost1 # 表示此交换器所在的 vhost</span><br><span class="line">username=root # 表示用户名</span><br><span class="line">password=123 # 表示密码</span><br></pre></td></tr></tbody></table></figure><p>同样，在 cluster1 集群中创建队列 queue1 之后，需要在 /rmqNode/queues 路径下创建实节点 queue1 ，并赋予节点的数据内容为:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cluster=cluster1 </span><br><span class="line">bindings=exchange1 # 表示此队列所绑定的交换器</span><br><span class="line"># 如果有需要，也可以添加一些其他信息，比如路由键等</span><br><span class="line">vhost=vhost1</span><br><span class="line">userni me=root</span><br><span class="line">password=123</span><br></pre></td></tr></tbody></table></figure><p>对应集群的数据在 /rmqNode/clusters 路径下，比如 cluster1 集群，其对应节点的数据内容包含 IP 地址列表信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipList=192.168.0.1 ,192.168.0.2, 192.168.0.3 # 集群中各个节点的IP地址信息</span><br></pre></td></tr></tbody></table></figure><p>客户端程序如果与其上的交换器或者队列进行交互，那么需要在相应的 ZooKeeper 节点中添加 watcher ，以便在数据发生变更时进行相应的变更，从而达到自动化迁移的目的。</p><p>生产者客户端在发送消息之前需要先连接 ZooKeeper ，然后根据指定的交换器名称如exchange1 到相应的路径/rmqNode/exchanges 中寻找 exchange1 的节点，之后再读取节点中的数据，并同时对此节点添加 watcher 。在节点的数据第一条 “cluster=cluster1” 中找到交换器所在的集群名称，然后再从路径 /rmqNode/clusters 中寻找 cluster1 节点，然后读取其对应IP 地址列表信息。这样整个发送端所需要的连接串数据（IP地址列表、vhost、usename、password等）都已获取，接下就可以与 RabbitMQ 集群 cluster1 建立连接然后发送数据了。</p><p>对于消费者客户端而言，同样需要连接ZooKeeper，之后根据指定的队列名称（queue1）到相应的路径 /rmqNode/queues 中寻找 queue1 节点，继而找到相应的连接串，然后与RabbitMQ 集群cluster1 建立连接进行消费。当然对 /rmqNode/queues/queue1 节点的 watcher 必不可少。</p><p>当cluster1 集群需要迁移到 cluster2 集群时，首先需要将 cluster1 集群中的元数据在 cluster2 集群中重建。之后通过修改 channel 和 queue 元数据信息，比如原 cluster1 集群中有交换器exchange1、exchange2 和队列 queue1、queue2，现在通过脚本或者程序将其中的”cluster=cluster1”数据修改为”cluster=cluster2”。客户端会立刻感知节点的变化，然后迅速关闭当前连接之后再与新集群 cluster2 建立新的连接后生产和消费消息，在此切换客户端连接的过程中是可以保证数据零丢失的。迁移之后，生产者和消费者都会与cluster2 集群进行互通，此时原 cluster1 集群中可能还有未被消费完的数据，此时需要使用前文中描述的自定义迁移工具（RabbitMQ ForwarMaker）将cluster1 集群中未被消费完的数据同步到 cluster2 集群中。</p><p>如果没有准备 RabbitMQ ForwardMaker 工具，也不想使用 Federation 或者 Shovel 插件，那么在变更完交换器相关的 ZooKeeper 中的节点数据之后，需要等待原集群中的所有队列都消费完全之后，再将队列相关的 ZooKeeper 中的节点数据变更，进而使得消费者的连接能够顺利迁移到新的集群之上。可以通过下面的命令来查看是否有队列中的消息未被消费完：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmqctl list_queues -p / -q | awk '{if($2&gt;0} print $0}'</span><br></pre></td></tr></tbody></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="重置数据"><a href="#重置数据" class="headerlink" title="重置数据"></a>重置数据</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原有的数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /var/lib/rabbitmq/mnesia/*</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-server -detached</span></span><br></pre></td></tr></tbody></table></figure><h3 id="杀进程重启"><a href="#杀进程重启" class="headerlink" title="杀进程重启"></a>杀进程重启</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询mq的进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep rabbitmq</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将mq的进程杀掉</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep rabbitmq | grep -v grep | awk <span class="string">'{print $2}'</span> | xargs <span class="built_in">kill</span> -9</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-server -detached</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询mq的状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl status</span></span><br></pre></td></tr></tbody></table></figure><h1 id="跨越集群界限"><a href="#跨越集群界限" class="headerlink" title="跨越集群界限"></a>跨越集群界限</h1><p>RabbitMQ 可以通过3 种方式实现分布式部署：</p><ul><li>集群</li><li>Federation</li><li>Shovel</li></ul><p>这3 种方式不是互斥的，可以根据需要选择其中的一种或者以几种方式的组合来达到分布式部署的目的。Federation 、Shovel 可以为RabbitMQ 的分布式部署提供更高的灵活性，但同时也提高了部署的复杂性。</p><h2 id="Federation"><a href="#Federation" class="headerlink" title="Federation"></a>Federation</h2><p>Federation 插件的设计目标是使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群，该功能在很多场景下都非常有用：</p><ul><li>Federation 插件能够在不同管理域（可能设置了不同的用户和 vhost ，也可能运行在不同版本的 RabbitMQ Erlang 上）中的 Broker 或者集群之间传递消息。</li><li>Federation 插件基于 <em>AMQP 0-9-1</em> 协议在不同的Broker 之间进行通信，并设计成能够容忍不稳定的网络连接情况。</li><li>一个Broker 节点中可以同时存在联邦交换器（或队列）或者本地交换器（或队列），只需要对特定的交换器（或队列）创建 Federation 连接（Federation link）。</li><li>Federation 需要在 Broker 节点之间创建 <em>O(N^2)</em> 个连接（尽管这是最简单的使用方式），这也就意味 Federation 在使用时更容易扩展。</li></ul><p>Federation 插件可以让多个交换器或者多个队列进行联邦：</p><ul><li>一个联邦交换器（federated exchange）或者一个联邦队列（federated queue）接收上游（upstream）的消息，这里的上游是指位于其他 Broker 上的交换器或者队列。</li><li>联邦交换器能够将原本发送给上游交换器（upstream exchange）的消息路由到本地的某个队列中。</li><li>联邦队列允许一个本地消费者接收到来自上游队列（upstream queue）的消息。</li></ul><h3 id="联邦交换器"><a href="#联邦交换器" class="headerlink" title="联邦交换器"></a>联邦交换器</h3><p>假设下图中 broker1 部署在北京，broker2 部署在上海，而 broker3 部署在广州，彼此之间相距甚远，网络延迟是一个不得不面对的问题。</p><p>例如：有一个在广州的业务 ClientA 需要连接broker3 ，并向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，ClientA 可以迅速将消息发送至 exchangeA 中，就算在开启了 publisher confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有一个在北京的业务ClientB 需要向 exchangeA 发送消息，那么 ClientB broker3 之间有很大的网络延迟，ClientB 将发送消息至exchangeA 会经历一定的延迟，尤其是在开启了 publisher confirm 机制或者事务机制的情况下，ClientB 会等待很长的延迟时间来接收 broker3 的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。</p><p>使用 Federation 插件就可以很好地解决这个问题：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-federated-exchange.png" alt="image"></p><p>如下图所示，在 broker3 中为交换器exchangeA（broker3 中的队列 queueA 通过 “rkA” 与 exchangeA 进行了绑定）与广州的 broker1 之间建立一条单向的 Federation link 。</p><p>此时 Federation 插件会在 broker1 上会建立一个同名的交换器 exchangeA (这个名称可以配置，默认同名)，同时建立一个内部的交换器 “exchangeA -&gt; broker3 B” ，并通过路由键 “rkA” 将这两个交换器绑定起来。这个交换器”exchangeA -&gt; broker3 B” 名字中的 broker3 是集群名，可以通过 <code>rabbitmqctl set cluster name {new name} </code>命令进行修改。</p><p>与此同时 Federation 插件还会在 broker1 上建立一个队列 “federation: exchangeA -&gt; broker3 B” ，并与交换器 “exchangeA -&gt; broker3 B” 进行绑定。Federation 插件会在队列 “federation: exchangeA -&gt; broker3 B” broker3 中的交换器 exchangeA 之间建立一条 AMQP 连接来实时地消费队列 “federation: exchangeA -&gt; broker3 B” 中的数据。</p><p>这些操作都是内部的，对外部业务客户端来说这条 Federation link 建立在broker1 exchangeA 与broker3 exchangeA 之间。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-federation-link.png" alt="image"></p><p>回到前面的问题，部署在北京的业务 ClientB 可以连接 broker1 并向 exchangeA 发送消息，这样 ClientB 可以迅速发送完消息并收到确认信息，而之后消息通过 Federation link 转发到 broker3 交换器 exchangeA，最终消息会存入与 exchangeA 绑定的队列 queueA 中，消费者最终可以消费队列 queueA 中的消息。经过 Federation link 转发的消息会带有特殊的 headers 性标记。</p><h3 id="联邦队列"><a href="#联邦队列" class="headerlink" title="联邦队列"></a>联邦队列</h3><p>除了联邦交换器，RabbitMQ 还可以支持联邦队列 (federated queue)。联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列 (upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。</p><p>下图演示了：</p><ol><li><p>位于两个 Broker 中的几个联邦队列(灰色)和非联邦队列(白色) 队列 queue1、queue2 原本在 broker2 中，由于某种需求将其配置为 federated queue 并将 broker1 作为 upstream</p></li><li><p>Federation 插件会在 broker1 上创建同名的队列 queue1、queue2，与 broker2 中的队列 queue1、queue2 分别建立两条单向独立的 Federation link</p></li><li><p>当有消费者 ClinetA 连接 broker2 并通过Basic.Consume 消费队列 queue1 (或 queue2) 中的消息时：</p><ul><li>如果队列 queue1 (或 queue2)本身有若干消息堆积，那么 ClientA 直接消费这些消息，此时 broker2 中的 queue1 (或 queue2)并不会拉取 broker1 中的 queue1 (或 queue2) 的消息；</li><li>如果队列 queue1 (或 queue2) 中没有消息堆积或者消息被消费完了，那么它会通过 Federation link 拉取在 broker1 中的上游队列 queue1 (或queue2) 中的消息(如果有消息)，然后存储到本地，之后再被消费者 ClientA 进行消费。</li></ul></li></ol><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-federated-queue.png" alt="image"></p><p>消费者既可以消费 broker2 中的队列，又可以消费 broker1 中的队列，Federation 的这种分布式队列的部署可以提升单个队列的容量。如果在 broker1 端部署的消费者来不及消费队列queue1 中的消息，那么 broker2 端部署的消费者可以为其分担消费，也可以达到某种意义上的负载均衡。</p><p>与federated exchange 不同，一条消息可以在联邦队列间转发无限次，如图中两个队列queue 互为联邦队列。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-federated-queue-2.png" alt="image"></p><h3 id="Federation-的使用"><a href="#Federation-的使用" class="headerlink" title="Federation 的使用"></a>Federation 的使用</h3><p>为了能够使用 Federation 功能， 需要配置以下两个内容：</p><ol><li><p>需要配置一个或多个 upstream，每个 upstream 均定义了到其他节点的 Federation link，这个配置可以通过设置运行时的参数 (Runtime Parameter) 来完成，也可以通过 federation management 插件来完成。</p></li><li><p>需要定义匹配交换器或者队列的一种/多种策略 (Policy)。</p></li></ol><p>Federation 插件默认在 RabbitMQ 发布包中，开启 Federation 功能：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rabbitmq-plugins enable rabbitmq_federation</span><br></pre></td></tr></tbody></table></figure><p>Federation 内部基于 AMQP 协议拉取数据，所以在开启 <code>rabbitmq federation</code> 插件的时候，默认会开启 <code>amqp_c lient</code> 插件。如果要开启 Federation 的管理插件，需要执行 <code>rabbitmq-plugins enable rabbitmq_federation _management</code> 命令。</p><p>注意:</p><p>当需要在集群中使用 Federation 功能的时候，集群中所有的节点都应该开启 Federation 插件。</p><h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><p>与 Federation 具备的数据转发功能类似，Shovel 能够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker 上，也可以位于不同的 Broker 上。 Shovel 可以翻译为 “铲子”，这个”铲子”可以将消息从一方”挖到”另一方。Shovel 的行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><p>Shovel 的主要优势在于：</p><ul><li>松耦合。Shovel 可以移动位于不同管理域中的 Broker(或者集群)上的消息，这些 Broker (或者集群)可以包含不同的用户和 vhost，也可以使用不同的 RabbitMQ Erlang 版本。</li><li>支持广域网。Shovel 插件同样基于 AMQP 协议 Broker 之间进行通信，被设计成可以容忍时断时续的连通情形，并且能够保证消息的可靠性。</li><li>高度定制。当 Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li></ul><h3 id="Shovel-原理"><a href="#Shovel-原理" class="headerlink" title="Shovel 原理"></a>Shovel 原理</h3><p>下图为 Shovel 的结构示意图：</p><p>这里有两个 Broker: broker1、broker2，broker1 中有交换器 exchange1 和队列 queue1，且这两者通过路由键 “rk1” 进行绑定；broker2 中有交换器 exchange2 和队列 queue2 ，且这两者通过路由键”rk2” 进行绑定。在队列 queue1 和交换器 exchange2 之间配置一个 Shovel link。</p><p>当一条内容为 “shovel test payload” 的消息从客户端发送至交换器 exchange1 的时候，这条消息会经过图图示中的数据流转最后存储在队列 queue2 中。如果在配置 Shovel link 时设置了<br><code>add-forward-headers</code> 参数为 true，则在消费到队列 queue2 中这条消息的时候会有特殊headers 属性标记。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-shovel.png" alt="image"></p><p>通常情况下，使用 shovel 时配置队列作为源端，交换器作为目的端。同样可以将队列配置为目的端，如下图所示：</p><p>虽然看起来队列 queue2 是通过 Shovel link 直接将消息转发至 queue2 ，其实中间也是经由 brokr2 的交换器转发，只不过这个交换器是默认的交换器而己。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-shovel2.png" alt="image"></p><p>如下图所示，配置交换器为源端也是可行的。虽然看起来交换器 exchange1 是通过 Shovel link 直接将消息转发至exchange2 上的，实际上在 broker1 中会新建一个队列(名称由 RabbitMQ 自定义，比如图中的 “amq.gen-ZwolUsoUchY6a7xaPyrZZH”) 并绑定 exchange1，消息从交换器 exchange1 过来先存储在这个队列中，然后 Shovel 再从这个队列中拉取消息进而转发至换器 exchange2。</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-shovel3.png" alt="image"></p><p>前面所阐述的 broker1 broker2 中的 exchange1 queue1 exchange2 queue2 都可以在 Shovel 成功连接源端或者目的端 Broker 之后再第一次创建(执行一系列相应的 AMQP 配置声明时)，它们并不一定需要在 Shovel link 建立之前创建。Shovel 可以为源端或者目的端配置多个 Broker 的地址，这样可以使得源端或者目的端的 Broker 失效后能够重连到其他 Broker 之上(随机挑选)，可以设置 <code>reconnect_delay</code> 参数以避免由于重连行为导致的网络泛洪，或者可以在重连失败后直接停止连接。针对源端和目的端的所有配置声明连成功之后被新发送。</p><h3 id="Shovel-使用"><a href="#Shovel-使用" class="headerlink" title="Shovel 使用"></a>Shovel 使用</h3><p>Shovel 插件默认 RabbitMQ 发布包中，开启方式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br></pre></td></tr></tbody></table></figure><p>Shovel 内部也是基于 AMQP 协议转发数据的，所以在开启 <code>rabbitmq_shovel</code> 插件的时候也是默认开启 <code>amqp_client</code> 插件。</p><p>同时，如果要开启 Shovel 的管理插件需要执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h1&gt;&lt;p&gt;RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩溃的情况下继续运行，它可以通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端能够重新连接到集群中的任何其他节点并继续生产或者消费。&lt;/p&gt;
&lt;p&gt;不过 RabbitMQ 集群不能保证消息的万无一失，即将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式。当集群中一个 RabbitMQ 节点崩溃时，该节点上的所有队列中的消息也会丢失。&lt;/p&gt;
&lt;p&gt;RabbitMQ 集群中的所有节点都会备份所有的元数据信息，包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列元数据：队列的名称及属性；&lt;/li&gt;
&lt;li&gt;交换器：交换器的名称及属性；&lt;/li&gt;
&lt;li&gt;绑定关系元数据：交换器与队列或者交换器与交换器之间的绑定关系；&lt;/li&gt;
&lt;li&gt;vhost 元数据：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是&lt;strong&gt;不会备份消息&lt;/strong&gt;(当然通过特殊的配置比如镜像队列可以解决这个问题，以后会有介绍)。基于存储空间和性能的考虑，在RabbitMQ 集群中创建队列，集群只会在单个节点而不是在所有节点上创建队列的进程并包含完整的队列信息(元数据 、状态、内容)。这样只有队列的宿主节点即所有者节点知道队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。因此当集群节点崩溃时，该节点的队列进程和关联的绑定都会消失。附加在那些队列上的消费者会丢失其所订阅的信息，并且任何匹配该队列绑定信息的新消息也都会消失。&lt;/p&gt;
&lt;p&gt;不同于队列那样拥有自己的进程，交换器其实只是一个名称和绑定列表。当消息发布到交换器时，实际上是由所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后再路由消息。当创建一个新的交换器时，RabbitMQ 所要做的就是将绑定列表添加到集群中的所有节点上。这样，每个节点上的每条信道都可以访问到新的交换器了。&lt;/p&gt;
&lt;h2 id=&quot;集群搭建&quot;&gt;&lt;a href=&quot;#集群搭建&quot; class=&quot;headerlink&quot; title=&quot;集群搭建&quot;&gt;&lt;/a&gt;集群搭建&lt;/h2&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://haifuns.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>docker入门指南</title>
    <link href="https://haifuns.com/2020/06/14/docker/"/>
    <id>https://haifuns.com/2020/06/14/docker/</id>
    <published>2020-06-14T04:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><h2 id="为什么要使用-Docker？"><a href="#为什么要使用-Docker？" class="headerlink" title="为什么要使用 Docker？"></a>为什么要使用 Docker？</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><span id="more"></span><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(ContinuousDelivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的 类 和 实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>Docker Registry 是集中的存储、分发镜像的服务，Docker Registry中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。</p><p>Docker Hub是官方也是默认的Registry，包含大量优质官方镜像。由于某些原因，在国内访问可能会比较慢，可以使用国内镜像仓库提高下载速度，下文安装过程将会介绍。</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。<br>官方网站上有各种环境下的 <a href="https://docs.docker.com/engine/install/">安装指南</a>。以下将以centos为例进行安装：</p><ol><li><p>卸载旧版本</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></tbody></table></figure></li><li><p>安装依赖包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加 yum 软件源</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"># 下载阿里的dockerCE版的yum源</span><br><span class="line">$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>安装 Docker CE</li></ol><ul><li>更新 yum 软件源缓存，并安装 docker-ce <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="5"><li>启动 Docker CE<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></tbody></table></figure></li><li>建立 docker 用户组</li></ol><ul><li>建立 docker 组：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></tbody></table></figure></li><li>将当前用户加入 docker 组：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="7"><li>镜像加速</li></ol><ul><li>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在新建该文件touch daemon.json）<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://bvitsvy3.mirror.aliyuncs.com"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>之后重新启动服务<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="8"><li>其他操作</li></ol><ul><li>设置docker开机启动<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></tbody></table></figure>显示：Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</li><li>更新xfsprogs<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update xfsprogs</span><br></pre></td></tr></tbody></table></figure></li><li>查看docker版本<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></tbody></table></figure><p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><ul><li><p>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker<br>Hub。</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 Docker<br>Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。</p></li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">redis latest 5f515359c7f8 5 days ago 183 M</span><br><span class="line">B</span><br><span class="line">nginx latest 05a60462f8ba 5 days ago 181 M</span><br><span class="line">B</span><br><span class="line">mongo 3.2 fe9198c04d62 5 days ago 342 M</span><br><span class="line">B</span><br><span class="line">&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 M</span><br><span class="line">B</span><br><span class="line">ubuntu 16.04 f753707788c5 4 weeks ago 127 M</span><br><span class="line">B</span><br><span class="line">ubuntu latest f753707788c5 4 weeks ago 127 M</span><br><span class="line">B</span><br><span class="line">ubuntu 14.04 1e0c3dd64ccd 4 weeks ago 188 M</span><br><span class="line">B</span><br></pre></td></tr></tbody></table></figure><p>列表包含了 仓库名 、 标签 、 镜像 ID 、 创建时间 以及 所占用的空间 。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>Docker Hub 中显示的体积是压缩后的体积。docker image ls显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和。</p><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none> 。：</none></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 M</span><br><span class="line">B</span><br></pre></td></tr></tbody></table></figure><p>这个镜像原本是有镜像名和标签的mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull 时， mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none> 。除了 docker pull 可能导致<br>这种情况， docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</none></none></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=true</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB</span><br></pre></td></tr></tbody></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></tbody></table></figure><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果<br>希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -a</span><br></pre></td></tr></tbody></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。</p><h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line"></span><br><span class="line"># 配合docker image ls</span><br><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></tbody></table></figure><p>其中， &lt;镜像&gt; 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要 。</p><h3 id="docker-commit将容器保存为镜像"><a href="#docker-commit将容器保存为镜像" class="headerlink" title="docker commit将容器保存为镜像"></a>docker commit将容器保存为镜像</h3><p>docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。</p><p>docker commit 的语法格式为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></tbody></table></figure><p>可以通过 docker diff 命令看到具体的改动。</p><h3 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h3><ul><li>FROM 指定基础镜像</li></ul><p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作<br>为镜像第一层开始存在。</p><ul><li>RUN 执行命令:<ul><li>shell 格式： RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></tbody></table></figure></li><li>exec 格式： RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。</li></ul></li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件所在目录执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build [选项] &lt;上下文路径/URL/-&gt;</span><br><span class="line"></span><br><span class="line">$ docker build -t nginx:v3 .</span><br></pre></td></tr></tbody></table></figure><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>docker build 命令最后有一个 . 。 . 表示当前目录， 但是此目录不是指定Dockerfile路径，而是在指定上下文路径。</p><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker<br>Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。</p><p>当构建的时候，用户会指定构建镜像上下文的路径， docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。如果在 Dockerfile 中这么写：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></tbody></table></figure><p>这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制Dockerfile 所在目录下的 package.json ，而是复制 上下文（context） 目录下的package.json 。</p><p>在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为<br>Dockerfile。这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile ，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为Dockerfile 。</p><h3 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h3><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfie 官方文档</a></p><p><a href="https://docs.docker.com/engine/userguide/engimage/dockerfile_best-practices/">Dockerfile 最佳实践文档</a></p><p><a href="https://github.com/docker-library/docs">Docker 官方镜像 Dockerfile</a></p><h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</span><br></pre></td></tr></tbody></table></figure><h4 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h4><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如 &lt;源路径&gt; 可以是一个 URL。<br>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</p><h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h4><p>CMD 指令的格式和 RUN 相似，也是两种格式：</p><ul><li>shell 格式： CMD &lt;命令&gt;</li><li>exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…]</li><li>参数列表格式： CMD [“参数1”, “参数2”…] 。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</li></ul><h4 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h4><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。<br>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。<br>当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span><br></pre></td></tr></tbody></table></figure><h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h4><p>格式有两种：</p><ul><li>ENV <key> <value></value></key></li><li>ENV <key1>=<value1> <key2>=<value2>…</value2></key2></value1></key1></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">NAME="Happy Feet"</span><br></pre></td></tr></tbody></table></figure><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像Dockerfile 中，就有类似这样的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line">RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta</span><br><span class="line">r.xz" \</span><br><span class="line">&amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \</span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">&amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">&amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=</span><br><span class="line">1 \</span><br><span class="line">&amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">&amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></tbody></table></figure><h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>格式： ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p><p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密<br>码之类的信息，因为 docker history 还是可以看到所有值的。</p><p>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><h4 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h4><p>格式为：</p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li><li>VOLUME &lt;路径&gt;</li></ul><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></tbody></table></figure><p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设<br>置。比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></tbody></table></figure><p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了Dockerfile 中定义的匿名卷的挂载配置。</p><h4 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h4><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…] 。</p><p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P </code>时，会自动随机映射 EXPOSE 的端口。</p><p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 <code>-p</code> ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h4><p>格式为 WORKDIR &lt;工作目录路径&gt; 。<br>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录。</p><h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h4><p>格式： USER &lt;用户名&gt;</p><p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。当然，和 WORKDIR 一样， USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ "redis-server" ]</span><br></pre></td></tr></tbody></table></figure><p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"># 下载 gosu</span><br><span class="line">RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/</span><br><span class="line">gosu-amd64" \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"># 设置 CMD，并以另外的用户执行</span><br><span class="line">CMD [ "exec", "gosu", "redis", "redis-server" ]</span><br></pre></td></tr></tbody></table></figure><h4 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h4><p>格式：<br>HEALTHCHECK [选项] CMD &lt;命令&gt; ：设置检查容器健康状况的命令<br>HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p><h4 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h4><p>格式： ONBUILD &lt;其它指令&gt; 。<br>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><h3 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h3><h4 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></tbody></table></figure><h4 id="docker-save-和-docker-load"><a href="#docker-save-和-docker-load" class="headerlink" title="docker save 和 docker load"></a>docker save 和 docker load</h4><p>Docker提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。<br>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br><span class="line">$ docker load -i alpine-latest.tar.gz</span><br></pre></td></tr></tbody></table></figure><h2 id="操作-Docker-容器"><a href="#操作-Docker-容器" class="headerlink" title="操作 Docker 容器"></a>操作 Docker 容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><ul><li>新建并启动<br>所需要的命令主要为 docker run 。<br>例如:<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/#</span><br></pre></td></tr></tbody></table></figure>其中， -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i则让容器的标准输入保持打开。</li></ul><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>使用 <code>-d</code> 参数</p><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p><code>docker container start </code></p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p><code>docker container stop</code></p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><ul><li><code>docker attach [OPTIONS]</code></li><li><code>docker exec -it [OPTIONS]</code></li></ul><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS</span><br><span class="line">PORTS NAMES</span><br><span class="line">7691a814370e ubuntu:14.04 "/bin/bash" 36 hours ago Exited</span><br><span class="line">(0) 21 hours ago test</span><br><span class="line">$ docker export 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></tbody></table></figure><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTU</span><br><span class="line">AL SIZE</span><br><span class="line">test/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3</span><br><span class="line">MB</span><br></pre></td></tr></tbody></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></tbody></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用<code> docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></tbody></table></figure><p>如果要删除一个运行中的容器，可以添加<code>-f</code>参数。Docker 会发送 SIGKILL 信号给容器。</p><h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><h3 id="数据卷（Volumes）"><a href="#数据卷（Volumes）" class="headerlink" title="数据卷（Volumes）"></a>数据卷（Volumes）</h3><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></tbody></table></figure><h4 id="查看所有的-数据卷"><a href="#查看所有的-数据卷" class="headerlink" title="查看所有的 数据卷"></a>查看所有的 数据卷</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">local my-vol</span><br></pre></td></tr></tbody></table></figure><p>在主机里使用以下命令可以查看指定 数据卷 的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">{</span><br><span class="line">"Driver": "local",</span><br><span class="line">"Labels": {},</span><br><span class="line">"Mountpoint": "/var/lib/docker/volumes/my-vol/_data",</span><br><span class="line">"Name": "my-vol",</span><br><span class="line">"Options": {},</span><br><span class="line">"Scope": "local"</span><br><span class="line">}</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>在主机里使用以下命令可以查看 web 容器的信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></tbody></table></figure><h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次docker run 中可以挂载多个 数据卷 。<br>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line"># -v my-vol:/wepapp \</span><br><span class="line">--mount source=my-vol,target=/webapp \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></tbody></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></tbody></table></figure><p>删除未使用的数据卷</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></tbody></table></figure><h3 id="挂载主机目录-Bind-mounts"><a href="#挂载主机目录-Bind-mounts" class="headerlink" title="挂载主机目录 (Bind mounts)"></a>挂载主机目录 (Bind mounts)</h3><p>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line"># -v /src/webapp:/opt/webapp \</span><br><span class="line">--mount type=bind,source=/src/webapp,target=/opt/webapp \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></tbody></table></figure><p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。使用 -v 参数时如果本地目录不存在 Docker 会自动创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 读写 ，用户也可以通过增加 readonly 指定为 只读 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line"># -v /src/webapp:/opt/webapp:ro \</span><br><span class="line">--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></tbody></table></figure><p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会<br>显示如下错误</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/webapp # touch new.txt</span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker中的网络功能"><a href="#Docker中的网络功能" class="headerlink" title="Docker中的网络功能"></a>Docker中的网络功能</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。<br>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有:</p><ol><li>ip:hostPort:containerPort : 映射到指定地址的指定端口</li><li>ip::containerPort : 映射到指定地址的任意端口</li><li>hostPort:containerPort : 映射所有接口地址</li></ol><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></tbody></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></tbody></table></figure><p>-d 参数指定 Docker 网络类型，有 bridge overlay 。其中 overlay 网络类型用于Swarm mode。</p><h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 my-net 网络</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></tbody></table></figure><p>打开新的终端，再运行一个容器并加入到 my-net 网络</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></tbody></table></figure><p>这样， busybox1 容器和 busybox2 容器建立了互联关系。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><a href="https://github.com/docker/compose">Docker Compose</a> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p><p>Compose允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个项目（project）。<br>Compose 中有两个重要的概念：</p><ul><li>服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。</li></ul><p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。<br>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p><h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><p>Docker for Mac 、 Docker for Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.25.0, build 0a186604</span><br></pre></td></tr></tbody></table></figure><p>linux:直接下载对应的二进制包。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sodo curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>docker-compose.yml<br>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">        build: .</span><br><span class="line">        ports:</span><br><span class="line">            - "5000:5000"</span><br><span class="line">    redis:</span><br><span class="line">        image: "redis:alpine"</span><br></pre></td></tr></tbody></table></figure><p>运行 compose 项目</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></tbody></table></figure><h3 id="Compose-命令说明"><a href="#Compose-命令说明" class="headerlink" title="Compose 命令说明"></a>Compose 命令说明</h3><p>docker-compose 命令的基本的使用格式是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></tbody></table></figure><h4 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h4><ul><li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml ，可以<br>多次指定。</li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li><li>–x-networking 使用 Docker 的可拔插网络后端特性</li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</li><li>–verbose 输出更多调试信息。</li><li>-v, –version 打印版本并退出。</li></ul><h4 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h4><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>格式为 <code>docker-compose build [options] [SERVICE...] </code>。构建（重新构建）项目中的服务容器。<br>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务。选项包括：</p><ul><li>–force-rm 删除构建过程中的临时容器。</li><li>–no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li>–pull 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h5 id="down"><a href="#down" class="headerlink" title="down"></a>down</h5><p>此命令将会停止 up 命令所启动的容器，并移除网络</p><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>进入指定的容器。</p><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><p>获得一个命令的帮助。</p><h5 id="images"><a href="#images" class="headerlink" title="images"></a>images</h5><p>列出 Compose 文件中包含的镜像。</p><h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p>格式为 <code>docker-compose kill [options] [SERVICE...] </code>。通过发送 SIGKILL 信号来强制停止服务容器。<br>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。<br><code>$ docker-compose kill -s SIGINT</code></p><h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><p>格式为 <code>docker-compose logs [options] [SERVICE...] </code>。查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。该命令在调试问题的时候十分有用。</p><h5 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h5><p>格式为 <code>docker-compose pause [SERVICE...]</code> 。<br>暂停一个服务容器。</p><h5 id="port"><a href="#port" class="headerlink" title="port"></a>port</h5><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code> 。打印某个容器端口所映射的公共端口。<br>选项：</p><ul><li>–protocol=proto 指定端口协议，tcp（默认值）或者 udp。</li><li>–index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>格式为 <code>docker-compose ps [options] [SERVICE...] </code>。列出项目中目前的所有容器。<br>选项：</p><ul><li>-q 只打印容器的 ID 信息。</li></ul><h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>格式为 <code>docker-compose pull [options] [SERVICE...] </code>。拉取服务依赖的镜像。<br>选项：</p><ul><li>–ignore-pull-failures 忽略拉取镜像过程中的错误。</li></ul><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h5><p>格式为 <code>docker-compose restart [options] [SERVICE...] </code>。重启项目中的服务。<br>选项：</p><ul><li>-t, –timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>格式为 <code>docker-compose rm [options] [SERVICE...] </code>。删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。<br>选项：</p><ul><li>-f, –force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li>-v 删除容器所挂载的数据卷。</li></ul><h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...] </code>。在指定服务上执行一个命令。<br>例如：<br><code>$ docker-compose run ubuntu ping docker.com</code><br>将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行<br>中。该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：<br>给定命令将会覆盖原有的自动运行命令；<br>不会自动创建端口，以避免冲突。</p><p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如<br><code>$ docker-compose run --no-deps web python manage.py shell</code><br>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li>-d 后台运行容器。</li><li>–name NAME 为容器指定一个名字。</li><li>–entrypoint CMD 覆盖默认的容器启动指令。</li><li>-e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li>-u, –user=”” 指定运行容器的用户名或者 uid。</li><li>–no-deps 不自动启动关联的服务容器。</li><li>–rm 运行命令后自动删除容器， d 模式下将忽略。</li><li>-p, –publish=[] 映射容器端口到本地主机。</li><li>–service-ports 配置服务端口并映射到本地主机。</li><li>-T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h5 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h5><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...] </code>。设置指定服务运行的容器个数。<br>通过 service=num 的参数来设置数量。例如：<br><code>$ docker-compose scale web=3 db=2</code><br>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。<br>选项：</p><ul><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><p>格式为 <code>docker-compose start [SERVICE...] </code>。启动已经存在的服务容器。</p><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>格式为 <code>docker-compose stop [options] [SERVICE...] </code>。停止已经处于运行状态的容器，但不删除它。</p><p>选项：</p><ul><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>格式为 <code>docker-compose top [SERVICE...] </code>。查看各个服务容器内运行的进程。</p><h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h5><p>格式为 <code>docker-compose unpause [SERVICE...] </code>。恢复处于暂停状态中的服务。</p><h5 id="up"><a href="#up" class="headerlink" title="up"></a>up</h5><p>格式为 <code>docker-compose up [options] [SERVICE...] </code>。该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联<br>服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态。可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况， <code>docker-compose up </code>启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。当通过 Ctrl-C 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d </code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在， <code>docker-compose up </code>将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --norecreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; </code>来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li>-d 在后台运行服务容器。</li><li>–no-color 不使用颜色来区分不同的服务的控制台输出。</li><li>–no-deps 不启动服务所链接的容器。</li><li>–force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</li><li>–no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使<br>用。</li><li>–no-build 不自动构建缺失的服务镜像。</li><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>格式为 <code>docker-compose version </code>。打印版本信息。</p><h4 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h4><p>默认的模板文件名称为 docker-compose.yml ，格式为 YAML 格式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">    webapp:</span><br><span class="line">        image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">        - "80:80"</span><br><span class="line">    volumes:</span><br><span class="line">        - "/data"</span><br></pre></td></tr></tbody></table></figure><p>每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。<br>如果使用 build 指令，在 Dockerfile 中设置的选项(例如： CMD , EXPOSE , VOLUME , ENV等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。</p><h5 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h5><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">    webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></tbody></table></figure><p>也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。<br>使用 dockerfile 指令指定 Dockerfile 文件名。<br>使用 arg 指令指定构建镜像时的变量;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">    webapp:</span><br><span class="line">    build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile-alternate</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></tbody></table></figure><p>使用 cache_from 指定构建镜像的缓存</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">    context: .</span><br><span class="line">    cache_from:</span><br><span class="line">        - alpine:latest</span><br><span class="line">        - corp/web_app:3.14</span><br></pre></td></tr></tbody></table></figure><h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h4><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">- ALL</span><br></pre></td></tr></tbody></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_drop:</span><br><span class="line">- NET_ADMIN</span><br></pre></td></tr></tbody></table></figure><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: echo "hello world"</span><br></pre></td></tr></tbody></table></figure><h4 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h4><p>仅用于 Swarm mode</p><h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>指定父 cgroup 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 cgroups_1 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: cgroups_1</span><br></pre></td></tr></tbody></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></tbody></table></figure><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>仅用于 Swarm mode</p><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射关系。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">    - "/dev/ttyUSB1:/dev/ttyUSB0"</span><br></pre></td></tr></tbody></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">        - db</span><br><span class="line">        - redis</span><br><span class="line">    redis:</span><br><span class="line">        image: redis</span><br><span class="line">    db:</span><br><span class="line">        image: postgres</span><br></pre></td></tr></tbody></table></figure><p>注意： web 服务不会等待 redis db 「完全启动」之后才启动。</p><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 114.114.114.114</span><br></pre></td></tr></tbody></table></figure><h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">dns_search:</span><br><span class="line">    - domain1.example.com</span><br><span class="line">    - domain2.example.com</span><br></pre></td></tr></tbody></table></figure><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line">tmpfs:</span><br><span class="line">    - /run</span><br><span class="line">    - /tmp</span><br></pre></td></tr></tbody></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。<br>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">env_file:</span><br><span class="line">    - ./common.env</span><br><span class="line">    - ./apps/web.env</span><br><span class="line">    - /opt/secrets.env</span><br></pre></td></tr></tbody></table></figure><p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># common.env: Set development environment</span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></tbody></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。你可以使用数组或字典两种格式。<br>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SESSION_SECRET:</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV=development</span><br><span class="line">    - SESSION_SECRET</span><br></pre></td></tr></tbody></table></figure><p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括<br><code>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code></p><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">    - "3000"</span><br><span class="line">    - "8000"</span><br></pre></td></tr></tbody></table></figure><h4 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h4><p>注意：不建议使用该指令。</p><p>链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line">    - redis_1</span><br><span class="line">    - project_db_1:mysql</span><br><span class="line">    - project_db_1:postgresql</span><br></pre></td></tr></tbody></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line">    - "googledns:8.8.8.8"</span><br><span class="line">    - "dockerhub:52.1.157.61"</span><br></pre></td></tr></tbody></table></figure><p>会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。<br>8.8.8.8 googledns<br>52.1.157.61 dockerhub</p><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">    test: ["CMD", "curl", "-f", "http://localhost"]</span><br><span class="line">    interval: 1m30s</span><br><span class="line">    timeout: 10s</span><br><span class="line">    retries: 3</span><br></pre></td></tr></tbody></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在， Compose 将会尝试拉取这个镜像。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></tbody></table></figure><h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">    com.startupteam.description: "webapp for a startup team"</span><br><span class="line">    com.startupteam.department: "devops department"</span><br><span class="line">    com.startupteam.release: "rc3 for v1.0"</span><br></pre></td></tr></tbody></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>注意：不推荐使用该指令。</p><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">    driver: syslog</span><br><span class="line">    options:</span><br><span class="line">        syslog-address: "tcp://192.168.0.42:123"</span><br></pre></td></tr></tbody></table></figure><p>目前支持三种日志驱动类型。<br>driver: “json-file”<br>driver: “syslog”<br>driver: “none”</p><p>options 配置日志驱动的相关参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">    max-size: "200k"</span><br><span class="line">    max-file: "10"</span><br></pre></td></tr></tbody></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。使用和 docker run 的 –network 参数一样的值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: "bridge"</span><br><span class="line">network_mode: "host"</span><br><span class="line">network_mode: "none"</span><br><span class="line">network_mode: "service:[service name]"</span><br><span class="line">network_mode: "container:[container name/id]"</span><br></pre></td></tr></tbody></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">    some-service:</span><br><span class="line">        networks:</span><br><span class="line">            - some-network</span><br><span class="line">            - other-network</span><br><span class="line">networks:</span><br><span class="line">    some-network:</span><br><span class="line">    other-network:</span><br></pre></td></tr></tbody></table></figure><h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h4><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: "host"</span><br></pre></td></tr></tbody></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">    - "3000"</span><br><span class="line">    - "8000:8000"</span><br><span class="line">    - "49100:22"</span><br><span class="line">    - "127.0.0.1:8001:8001"</span><br></pre></td></tr></tbody></table></figure><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>存储敏感数据，例如 mysql 服务密码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">    mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">        MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">    secrets:</span><br><span class="line">        - db_root_password</span><br><span class="line">        - my_other_secret</span><br><span class="line">secrets:</span><br><span class="line">    my_secret:</span><br><span class="line">        file: ./my_secret.txt</span><br><span class="line">    my_other_secret:</span><br><span class="line">        external: true</span><br></pre></td></tr></tbody></table></figure><h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">    - label:user:USER</span><br><span class="line">    - label:role:ROLE</span><br></pre></td></tr></tbody></table></figure><h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></tbody></table></figure><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">    net.core.somaxconn: 1024</span><br><span class="line">    net.ipv4.tcp_syncookies: 0</span><br><span class="line">    </span><br><span class="line">sysctls:</span><br><span class="line">    - net.core.somaxconn=1024</span><br><span class="line">    - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></tbody></table></figure><h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的 ulimits 限制值。<br>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">    nproc: 65535</span><br><span class="line">    nofile:</span><br><span class="line">        soft: 20000</span><br><span class="line">        hard: 40000</span><br></pre></td></tr></tbody></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置宿主机路径 （ HOST:CONTAINER ） 或加上访问模式（ HOST:CONTAINER:ro ）。该指令中路径支持相对路径。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">    - /var/lib/mysql</span><br><span class="line">    - cache/:/tmp/cache</span><br><span class="line">    - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></tbody></table></figure><h4 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h4><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></tbody></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></tbody></table></figure><p>指定容器中工作目录。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></tbody></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: test</span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></tbody></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: true</span><br></pre></td></tr></tbody></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></tbody></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_only: true</span><br></pre></td></tr></tbody></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdin_open: true</span><br></pre></td></tr></tbody></table></figure><p>模拟一个伪终端。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty: true</span><br></pre></td></tr></tbody></table></figure><p>读取变量<br>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。<br>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入<br>执行的指令中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">db:</span><br><span class="line">image: "mongo:${MONGO_VERSION}"</span><br></pre></td></tr></tbody></table></figure><p>如果执行<code>MONGO_VERSION=3.2 docker-compose up</code>则会启动一个 mongo:3.2 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up </code>则会启动一个 mongo:2.8 镜像的容器。若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。在当前目录新建 .env 文件并写入以下内容。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></tbody></table></figure><p>执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。</p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><ul><li>获取镜像: docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</li><li>列出镜像：docker image ls<ul><li>-a: 列出中间层镜像</li></ul></li><li>查看镜像、容器、数据卷所占用的空间：docker system df</li><li>列出所有虚悬镜像：docker image ls -f dangling=true</li><li>删除未使用的镜像：docker image prune [OPTIONS]<ul><li>–all , -a:        Remove all unused images, not just dangling ones 删除所有未使用的映像，而不仅仅是悬空映像</li><li>–filter:        Provide filter values (e.g. ‘until=’) 提供过滤值（例如’until =“）</li><li>–force , -f:    Do not prompt for confirmation 不要提示确认</li></ul></li><li>容器停止：docker stop 容器名称</li><li>启动容器：docker start 容器名称</li><li>进入容器：<ul><li>docker attach [OPTIONS]</li><li>docker exec -it [OPTIONS]</li></ul></li><li>删除容器：docker rm 容器名称</li><li>删除镜像：docker rmi 镜像名称</li><li>查看运行的所有容器：docker ps</li><li>查看所有容器：docker ps -a</li><li>容器复制文件到物理机：docker cp 容器名称:容器目录 物理机目录</li><li>物理机复制文件到容器：docker cp 物理机目录 容器名称:容器目录</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h2&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-Docker？&quot;&gt;&lt;a href=&quot;#为什么要使用-Docker？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 Docker？&quot;&gt;&lt;/a&gt;为什么要使用 Docker？&lt;/h2&gt;&lt;p&gt;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。&lt;/p&gt;
&lt;h3 id=&quot;更高效的利用系统资源&quot;&gt;&lt;a href=&quot;#更高效的利用系统资源&quot; class=&quot;headerlink&quot; title=&quot;更高效的利用系统资源&quot;&gt;&lt;/a&gt;更高效的利用系统资源&lt;/h3&gt;&lt;p&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://haifuns.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://haifuns.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 连环问</title>
    <link href="https://haifuns.com/2020/06/14/rabbitmq-req/"/>
    <id>https://haifuns.com/2020/06/14/rabbitmq-req/</id>
    <published>2020-06-14T04:00:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用消息队列有什么优点？"><a href="#使用消息队列有什么优点？" class="headerlink" title="使用消息队列有什么优点？"></a>使用消息队列有什么优点？</h1><ol><li>解耦，减少系统间关联性。</li><li>异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。</li><li>削峰，并发量大的时候，请求压力可能加到到数据库，造成数据库连接异常。</li></ol><h1 id="使用消息队列有什么缺点？"><a href="#使用消息队列有什么缺点？" class="headerlink" title="使用消息队列有什么缺点？"></a>使用消息队列有什么缺点？</h1><ol><li>系统可用性降低，引入新系统，当其不可用时可能导致整个业务流程故障。</li><li>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证消息可靠传输等。</li></ol><h1 id="RabbitMQ-中的-broker-是指什么？cluster-又是指什么？"><a href="#RabbitMQ-中的-broker-是指什么？cluster-又是指什么？" class="headerlink" title="RabbitMQ 中的 broker 是指什么？cluster 又是指什么？"></a>RabbitMQ 中的 broker 是指什么？cluster 又是指什么？</h1><p>broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。</p><span id="more"></span><h1 id="什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？"><a href="#什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？" class="headerlink" title="什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？"></a>什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？</h1><p>在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在cluster 中是全 node 分布的。</p><h1 id="RAM-node-和-disk-node-的区别？"><a href="#RAM-node-和-disk-node-的区别？" class="headerlink" title="RAM node 和 disk node 的区别？"></a>RAM node 和 disk node 的区别？</h1><p>RAM node 仅将 fabric（即 queue、exchange 和 binding 等 RabbitMQ 基础构件）相关元数据保存到内存中，但 disk node 会在内存和磁盘中均进行存储。RAM node 上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址。要求在 RabbitMQ cluster中至少存在一个 disk node 。</p><h1 id="RabbitMQ-概念里的-channel、exchange-和-queue-是逻辑概念，还是对应着进程实体？分别起什么作用？"><a href="#RabbitMQ-概念里的-channel、exchange-和-queue-是逻辑概念，还是对应着进程实体？分别起什么作用？" class="headerlink" title="RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？"></a>RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？</h1><p>Queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表；channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel。channel 号为 0 的 channel 用于处理所有对于当前 connection 全局有效的帧，而 1-65535 号 channel 用于处理和特定 channel 相关的帧。AMQP 协议给出的 channel 复用模型如下其中每一个 channel 运行在一个独立的线程上，多线程共享同一个 socket。</p><h1 id="vhost-是什么？起什么作用？"><a href="#vhost-是什么？起什么作用？" class="headerlink" title="vhost 是什么？起什么作用？"></a>vhost 是什么？起什么作用？</h1><p>vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</p><h1 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h1><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p><h1 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h1><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p><h1 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h1><p>从概念上来说，消息路由必须有三部分：交换器、路由、绑定。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。</p><p>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列且没有其他设置（ mandatory参数或者备份交换器alternate-exchange），消息将丢失。</p><p>常用的交换器主要分为以下三种：</p><ul><li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li><li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li><li>topic：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符。比如：“*” 匹配特定位置的任意文本，“.” 把路由键分为了几部分，“#” 匹配所有规则等。</li></ul><p>特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由”.”隔开的一系列的标识符组成。</p><h1 id="在单node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？"><a href="#在单node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？" class="headerlink" title="在单node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？"></a>在单node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？</h1><p>当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部 node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘上的数据。</p><h1 id="如何确保消息正确地发送至RabbitMQ？"><a href="#如何确保消息正确地发送至RabbitMQ？" class="headerlink" title="如何确保消息正确地发送至RabbitMQ？"></a>如何确保消息正确地发送至RabbitMQ？</h1><p>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。</p><p>发送方确认模式：</p><p>将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p><p>还可以使用事务机制，将信道设置为事务模式，发送消息之后进行事务提交或回滚。</p><h1 id="如何确保消息接收方消费了消息？"><a href="#如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息接收方消费了消息？"></a>如何确保消息接收方消费了消息？</h1><p>接收方消息确认机制：</p><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。</p><p>下面罗列几种特殊情况：</p><p>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）<br>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</p><h1 id="如何避免消息重复投递或重复消费？"><a href="#如何避免消息重复投递或重复消费？" class="headerlink" title="如何避免消息重复投递或重复消费？"></a>如何避免消息重复投递或重复消费？</h1><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</p><p>这个问题针对业务场景来答分以下几点：</p><ol><li>比如，拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</li><li>再比如，拿到这个消息做redis的set的操作，那就容易了，不用解决，因为无论set几次结果都是一样的，set操作本来就算幂等操作。</li><li>如果上面两种情况还不行，准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt; 以 K-V 形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</li></ol><h1 id="如何解决丢数据的问题？"><a href="#如何解决丢数据的问题？" class="headerlink" title="如何解决丢数据的问题？"></a>如何解决丢数据的问题？</h1><p>1.生产者丢数据</p><p>生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p><p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p><p>然而缺点就是吞吐量下降了。因此，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果RabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><p>2.消息队列丢数据</p><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p><ol><li><p>将queue的持久化标识durable设置为true,则代表是一个持久的队列</p></li><li><p>发送消息的时候将deliveryMode=2</p></li></ol><p>这样设置以后，RabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p><ol start="3"><li>消费者丢数据</li></ol><p>启用手动确认模式可以解决这个问题</p><ol><li><p>自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。</p></li><li><p>手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。</p></li><li><p>不确认模式，acknowledge=”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</p></li></ol><h1 id="死信队列和延迟队列的使用？"><a href="#死信队列和延迟队列的使用？" class="headerlink" title="死信队列和延迟队列的使用？"></a>死信队列和延迟队列的使用？</h1><ol><li><p>死信消息：</p><ul><li>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false</li><li>消息过期了</li><li>队列达到最大的长度</li></ul></li><li><p>死信队列&amp;死信交换器：</p><ul><li>DLX 全称（Dead-Letter-Exchange），称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在<code>x-dead-letter-exchange</code>参数，那么它会被发送到<code>x-dead-letter-exchange</code>对应值的交换器上，这个交换器就称之为死信交换器</li><li>与这个死信交换器绑定的队列就是死信队列</li></ul></li><li><p>过期消息，在Rabbitmq 中存在2种方法可设置消息的过期时间：</p><ul><li>第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间（在队列申明的时候使用 x-message-ttl 参数，单位毫秒）</li><li>第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个死信消息。（设置消息属性的 expiration 参数的值，单位毫秒）</li></ul></li><li><p>延时队列：在rabbitmq中不存在延时队列，但是可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p></li></ol><h1 id="多个消费者监听一个队列时，消息如何分发"><a href="#多个消费者监听一个队列时，消息如何分发" class="headerlink" title="多个消费者监听一个队列时，消息如何分发?"></a>多个消费者监听一个队列时，消息如何分发?</h1><ul><li>轮询: 默认的策略，消费者轮流，平均地接收消息</li><li>公平分发: 根据消费者的能力来分发消息，给空闲的消费者发送更多消息</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当消费者有x条消息没有响应ACK时，不再给这个消费者发送消息</span></span><br><span class="line">channel.basicQos(<span class="keyword">int</span> x)</span><br></pre></td></tr></tbody></table></figure><h1 id="无法被路由的消息去了哪里"><a href="#无法被路由的消息去了哪里" class="headerlink" title="无法被路由的消息去了哪里?"></a>无法被路由的消息去了哪里?</h1><ol><li><p>无设置的情况下，无法路由（Routing key错误）的消息会被直接丢弃</p><ul><li>解决方案：将mandatory设置为true，并配合ReturnListener，实现消息的回发声明交换机时，指定备份的交换机</li></ul></li><li><p>设置备份交换机</p><ul><li>alternate-exchange”:”备份交换机”</li></ul></li></ol><h1 id="消息在什么时候会变成死信"><a href="#消息在什么时候会变成死信" class="headerlink" title="消息在什么时候会变成死信?"></a>消息在什么时候会变成死信?</h1><ul><li>消息拒绝并且没有设置重新入队</li><li>消息过期</li><li>消息堆积，并且队列达到最大长度，先入队的消息会变成DL</li></ul><h1 id="RabbitMQ如何实现延时队列"><a href="#RabbitMQ如何实现延时队列" class="headerlink" title="RabbitMQ如何实现延时队列?"></a>RabbitMQ如何实现延时队列?</h1><p>利用TTL（队列的消息存活时间或者消息存活时间），加上死信交换机</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置属性，消息10秒钟过期</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .expiration(<span class="string">"10000"</span>) <span class="comment">// TTL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定队列的死信交换机</span></span><br><span class="line">Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>,<span class="string">"DLX_EXCHANGE"</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="消息如何被优先消费？"><a href="#消息如何被优先消费？" class="headerlink" title="消息如何被优先消费？"></a>消息如何被优先消费？</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">Map&lt;String, Object&gt; argss = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">argss.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .priority(<span class="number">5</span>) <span class="comment">// 优先级，默认为5，配合队列的 x-max-priority 属性使用</span></span><br></pre></td></tr></tbody></table></figure><h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><p>一个队列只有一个消费者的情况下才能保证顺序，否则只能通过全局ID实现（每条消息都一个msgId，关联的消息拥有一个parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息）</p><h1 id="如何自动删除长时间没有消费的消息？"><a href="#如何自动删除长时间没有消费的消息？" class="headerlink" title="如何自动删除长时间没有消费的消息？"></a>如何自动删除长时间没有消费的消息？</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过队列属性设置消息过期时间</span></span><br><span class="line">Map&lt;String, Object&gt; argss = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">argss.put(<span class="string">"x-message-ttl"</span>,<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对每条消息设置过期时间TTL</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().expiration(<span class="string">"10000"</span>) </span><br></pre></td></tr></tbody></table></figure><h1 id="RabbitMQ的集群模式和集群节点类型？"><a href="#RabbitMQ的集群模式和集群节点类型？" class="headerlink" title="RabbitMQ的集群模式和集群节点类型？"></a>RabbitMQ的集群模式和集群节点类型？</h1><p>普通模式：默认模式，以两个节点（rabbit01，rabbit02）为例来进行说明，对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01，rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer，所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么等到rabbit01节点恢复，然后才可被消费。如果没有消息持久化，就会产生消息丢失的现象。</p><p>镜像模式：把需要的队列做成镜像队列，存在与多个节点属于RabibitMQ的HA方案，该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取，该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉，所以在对可靠性要求比较高的场合中适用节点分为内存节点（保存状态到内存，但持久化的队列和消息还是会保存到磁盘），磁盘节点（保存状态到内存和磁盘），一个集群中至少需要一个磁盘节点。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用消息队列有什么优点？&quot;&gt;&lt;a href=&quot;#使用消息队列有什么优点？&quot; class=&quot;headerlink&quot; title=&quot;使用消息队列有什么优点？&quot;&gt;&lt;/a&gt;使用消息队列有什么优点？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;解耦，减少系统间关联性。&lt;/li&gt;
&lt;li&gt;异步，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度。&lt;/li&gt;
&lt;li&gt;削峰，并发量大的时候，请求压力可能加到到数据库，造成数据库连接异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;使用消息队列有什么缺点？&quot;&gt;&lt;a href=&quot;#使用消息队列有什么缺点？&quot; class=&quot;headerlink&quot; title=&quot;使用消息队列有什么缺点？&quot;&gt;&lt;/a&gt;使用消息队列有什么缺点？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;系统可用性降低，引入新系统，当其不可用时可能导致整个业务流程故障。&lt;/li&gt;
&lt;li&gt;系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证消息可靠传输等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;RabbitMQ-中的-broker-是指什么？cluster-又是指什么？&quot;&gt;&lt;a href=&quot;#RabbitMQ-中的-broker-是指什么？cluster-又是指什么？&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 中的 broker 是指什么？cluster 又是指什么？&quot;&gt;&lt;/a&gt;RabbitMQ 中的 broker 是指什么？cluster 又是指什么？&lt;/h1&gt;&lt;p&gt;broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://haifuns.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate/Jpa扩展支持Json/Hstore</title>
    <link href="https://haifuns.com/2020/04/28/hibernatetypes-extend/"/>
    <id>https://haifuns.com/2020/04/28/hibernatetypes-extend/</id>
    <published>2020-04-28T15:45:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li>本文使用开源扩展 <a href="https://github.com/vladmihalcea/hibernate-types/">Hibernate Types</a> 实现操作postgresql json/jsonb/hstore数据类型</li></ul><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Hibernate 5.4, 5.3 and 5.2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vladmihalcea&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-types-52&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;${hibernate-types.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h4 id="声明Hibernate类型"><a href="#声明Hibernate类型" class="headerlink" title="声明Hibernate类型"></a>声明Hibernate类型</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@TypeDefs({</span><br><span class="line">        @TypeDef(name = "json", typeClass = JsonBinaryType.class),</span><br><span class="line">        @TypeDef(name = "jsonb", typeClass = JsonBinaryType.class),</span><br><span class="line">        @TypeDef(name = "hstore", typeClass = PostgreSQLHStoreType.class)</span><br><span class="line">})</span><br><span class="line">@Table(name = "STUDENT")</span><br><span class="line">public class Student implements Serializable {</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">    @Type(type = "hstore")</span><br><span class="line">    @Column(name = "BOOK", columnDefinition = "hstore")</span><br><span class="line">    private Map&lt;String,String&gt; book;</span><br><span class="line"></span><br><span class="line">    @Type(type = "json")</span><br><span class="line">    @Column(name = "INFO", columnDefinition = "json")</span><br><span class="line">    private Object info;</span><br><span class="line"></span><br><span class="line">    @Type(type = "jsonb")</span><br><span class="line">    @Column(name = "FRIEND", columnDefinition = "jsonb")</span><br><span class="line">    private Object friend;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>json/jsonb引用JsonBinaryType</li><li>hstore引用PostgreSQLHStoreType<ul><li>postgresql使用hstore需要安装扩展<code>CREATE EXTENSION hstore;</code></li></ul></li></ul><p>完成后即可以使用这些数据类型的高级查询功能：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = entityManager.createNativeQuery(</span><br><span class="line">    "SELECT jsonb_pretty(s.friend) " +</span><br><span class="line">    "FROM student s " +</span><br><span class="line">    "WHERE s.friend -&gt;&gt; 0 = '李四'")</span><br><span class="line">.getResultList();</span><br></pre></td></tr></tbody></table></figure><h4 id="JPA简单操作"><a href="#JPA简单操作" class="headerlink" title="JPA简单操作"></a>JPA简单操作</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(value = "SELECT s.* FROM student s WHERE s.friend -&gt;&gt; 0 = :name", nativeQuery = true)</span><br><span class="line">    List&lt;Student&gt; queryByFriend(@Param("name") String name);</span><br></pre></td></tr></tbody></table></figure><ul><li>json</li></ul><table><thead><tr><th>操作符</th><th>右操作类型</th><th>返回类型</th><th>描述</th><th>示例</th><th>示例结果</th></tr></thead><tbody><tr><td>-&gt;</td><td>int</td><td>json/jsonb</td><td>获取JSON数组元素（从零开始索引，从末数开始为负整数）</td><td>‘[{“a”:”foo”},{“b”:”bar”},{“c”:”baz”}]’::json-&gt;2</td><td>{“c”:”baz”}</td></tr><tr><td>-&gt;</td><td>text</td><td>json/jsonb</td><td>通过键获取JSON对象字段</td><td>‘{“a”: {“b”:”foo”}}’::json-&gt;’a’</td><td>{“b”:”foo”}</td></tr><tr><td>-&gt;&gt;</td><td>int</td><td>text</td><td>获取JSON数组元素为 <code>text</code></td><td>‘[1,2,3]’::json-&gt;&gt;2</td><td>3</td></tr><tr><td>-&gt;&gt;</td><td>text</td><td>text</td><td>获取JSON对象字段为 <code>text</code></td><td>‘{“a”:1,”b”:2}’::json-&gt;&gt;’b’</td><td>2</td></tr><tr><td>#&gt;</td><td>text[]</td><td>json/jsonb</td><td>在指定路径获取JSON对象</td><td>‘{“a”: {“b”:{“c”: “foo”}}}’::json#&gt;’{a,b}’</td><td>{“c”: “foo”}</td></tr><tr><td>#&gt;&gt;</td><td>text[]</td><td>text</td><td>在指定路径下获取JSON对象为 <code>text</code></td><td>‘{“a”:[1,2,3],”b”:[4,5,6]}’::json#&gt;&gt;’{a,2}’</td><td>3</td></tr></tbody></table><ul><li>store</li></ul><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th><th>示例结果</th></tr></thead><tbody><tr><td>hstore -&gt; text</td><td>获取密钥值（如果不存在<code>NULL</code>）</td><td>‘a=&gt;x, b=&gt;y’::hstore -&gt; ‘a’</td><td>x</td></tr><tr><td>hstore -&gt; text[]</td><td>获取密钥值（如果不存在<code>NULL</code>）</td><td>‘a=&gt;x, b=&gt;y, c=&gt;z’::hstore -&gt; ARRAY[‘c’,’a’]</td><td>{“z”,”x”}</td></tr><tr><td>hstore &amp;#124;&amp;#124; hstore</td><td>组合<code>hstore</code></td><td>‘a=&gt;b, c=&gt;d’::hstore &amp;#124;&amp;#124; ‘c=&gt;x, d=&gt;q’::hstore</td><td>“a”=&gt;”b”, “c”=&gt;”x”, “d”=&gt;”q”</td></tr><tr><td>hstore ? text</td><td>是否包含键</td><td>‘a=&gt;1’::hstore ? ‘a’</td><td>t</td></tr><tr><td>hstore ?&amp; text[]</td><td>是否包含所有指定的键</td><td>‘a=&gt;1,b=&gt;2’::hstore ?&amp; ARRAY[‘a’,’b’]</td><td>t</td></tr><tr><td>hstore ?&amp;#124; text[]</td><td>是否包含任意指定的键</td><td>‘a=&gt;1,b=&gt;2’::hstore ?&amp;#124; ARRAY[‘b’,’c’]</td><td>t</td></tr><tr><td>hstore @&gt; hstore</td><td>左包含右</td><td>‘a=&gt;b, b=&gt;1, c=&gt;NULL’::hstore @&gt; ‘b=&gt;1’</td><td>t</td></tr><tr><td>hstore &lt;@ hstore</td><td>左包含在右边</td><td>‘a=&gt;c’::hstore &lt;@ ‘a=&gt;b, b=&gt;1, c=&gt;NULL’</td><td>f</td></tr><tr><td>hstore - text</td><td>删除键</td><td>‘a=&gt;1, b=&gt;2, c=&gt;3’::hstore - ‘b’::text</td><td>“a”=&gt;”1”, “c”=&gt;”3”</td></tr><tr><td>hstore - text[]</td><td>删除多个键</td><td>‘a=&gt;1, b=&gt;2, c=&gt;3’::hstore - ARRAY[‘a’,’b’]</td><td>“c”=&gt;”3”</td></tr><tr><td>hstore - hstore</td><td>删除匹配对</td><td>‘a=&gt;1, b=&gt;2, c=&gt;3’::hstore - ‘a=&gt;4, b=&gt;2’::hstore</td><td>“a”=&gt;”1”, “c”=&gt;”3”</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>json/hstore更多语法移步<a href="https://www.postgresql.org/docs/devel/functions-json.html">JSON Functions and Operators</a>/<a href="https://www.postgresql.org/docs/devel/hstore.html">hstore</a>官方文档。中文版：<a href="http://postgres.cn/docs/9.6/functions-json.html">JSON Functions and Operators</a>/<a href="http://postgres.cn/docs/9.6/hstore.html">hstore</a></li><li>可能会遇到的语法包含特殊字符可参考<a href="https://stackoverflow.com/questions/50464741/how-to-escape-question-mark-character-with-spring-jparepository">How to escape question mark ? character with Spring JpaRepository</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文使用开源扩展 &lt;a href=&quot;https://github.com/vladmihalcea/hibernate-types/&quot;&gt;Hibernate Types&lt;/a&gt; 实现操作postgresql json/jsonb/hstore数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- Hibernate 5.4, 5.3 and 5.2 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;com.vladmihalcea&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;hibernate-types-52&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;${hibernate-types.version}&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://haifuns.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Hibernate" scheme="https://haifuns.com/tags/Hibernate/"/>
    
    <category term="PostgreSQL" scheme="https://haifuns.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring生命周期</title>
    <link href="https://haifuns.com/2019/11/21/flow/"/>
    <id>https://haifuns.com/2019/11/21/flow/</id>
    <published>2019-11-21T13:43:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/img/spring.png" alt="image"></p><ol><li>首先容器启动后，对bean进行初始化。</li><li>按照bean定义注入属性。</li><li>检测是否实现了XXAware接口，如BeanNameAware等，将相关信息注入到bean实例。</li><li>经过以上步骤，bean实例已正确构造，通过实现BeanPostProcessor#postProcessBeforeInitialzation进行前置处理。</li><li>BeanPostProcessor前置处理完成后，可以通过实现InitializingBean#afterPropertiesSet、@PostConstruct、init-method方法，增强自定义逻辑。</li><li>通过实现BeanPostProcessor#postProcessAfterInitialzation进行后置处理。</li><li>此时bean准备已完成，可以使用。</li><li>容器关闭后，如果bean实现了DisposableBean接口，会执行destory方法。</li><li>最后执行自定义的销毁前destory-method指定方法。</li><li>bean销毁完成。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://haif-cloud.oss-cn-beijing.aliyuncs.com/img/spring.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先容器启动后，对bean进行初始化。&lt;/li&gt;
&lt;li&gt;按照bean定义注</summary>
      
    
    
    
    <category term="Java" scheme="https://haifuns.com/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://haifuns.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis拦截器实现水平分表</title>
    <link href="https://haifuns.com/2019/11/21/mybatis-sharding/"/>
    <id>https://haifuns.com/2019/11/21/mybatis-sharding/</id>
    <published>2019-11-21T12:50:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mybatis插件（plugins）"><a href="#Mybatis插件（plugins）" class="headerlink" title="Mybatis插件（plugins）"></a>Mybatis插件（plugins）</h3><p>Mybatis允许在已映射的语句执行过程中某一点进行拦截。Mybatis允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>分别拦截以下方法调用：</p><ul><li>拦截执行器的方法</li><li>拦截参数的处理</li><li>拦截结果集的处理</li><li>拦截Sql语法构建的处理</li></ul><span id="more"></span><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Interceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.Invocation;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts({@Signature(</span></span><br><span class="line"><span class="meta">  type= Executor.class,method = "update",args = {MappedStatement.class,Object.class})</span></span><br><span class="line"><span class="meta"> })</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p><h3 id="水平分表实现"><a href="#水平分表实现" class="headerlink" title="水平分表实现"></a>水平分表实现</h3><h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"someProperty"</span> value=<span class="string">"100"</span>/&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></tbody></table></figure><p>SpringBoot中只需要使用@Component注解注册为bean即可</p><h4 id="选择拦截方法"><a href="#选择拦截方法" class="headerlink" title="选择拦截方法"></a>选择拦截方法</h4><p>实现分表主要是通过在sql构建时，对表名进行替换，所以选择拦截StatementHandler<br>注解为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts({</span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = "prepare", args = { Connection.class, Integer.class })</span></span><br><span class="line"><span class="meta">})</span></span><br></pre></td></tr></tbody></table></figure><h4 id="定义分区表、分表字段"><a href="#定义分区表、分表字段" class="headerlink" title="定义分区表、分表字段"></a>定义分区表、分表字段</h4><p>使用Mybatis实现分表我们期望分表灵活，即可以选择要分区的表，分区表分表字段，甚至指定哪些方法需要分表</p><p>自定义注解：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({ ElementType.TYPE, ElementType.METHOD })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TablesPartition {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否分表</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">split</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    TablePartition[] value();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target({})</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TablePartition {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="function">String <span class="title">field</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在Mapper接口/方法上定义注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TablesPartition({</span></span><br><span class="line"><span class="meta">        @TablePartition(value = "table_0", field = "field_0"),</span></span><br><span class="line"><span class="meta">        @TablePartition(value = "table_1", field = "field_0")   </span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NormalMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TablesPartition({</span></span><br><span class="line"><span class="meta">            @TablePartition(value = "table_0", field = "field_0")</span></span><br><span class="line"><span class="meta">    })</span></span><br><span class="line">    <span class="function">List&lt;NormalEntity&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="分表核心源码实现"><a href="#分表核心源码实现" class="headerlink" title="分表核心源码实现"></a>分表核心源码实现</h4><p>源码实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts({</span></span><br><span class="line"><span class="meta">   @Signature(type = StatementHandler.class, method = "prepare", args = { Connection.class, Integer.class })</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectFactory DEFAULT_OBJECT_FACTORY = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReflectorFactory REFLECTOR_FACTORY = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line"></span><br><span class="line">        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line">        MetaObject metaStatementHandler = MetaObject.forObject(statementHandler, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY,REFLECTOR_FACTORY);</span><br><span class="line"></span><br><span class="line">        Object parameterObject = metaStatementHandler.getValue(<span class="string">"delegate.boundSql.parameterObject"</span>);</span><br><span class="line">        partitionTable(metaStatementHandler,parameterObject);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标类是StatementHandler类型时，才包装目标类，否者直接返回目标本身,减少目标被代理的次数</span></span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> StatementHandler) {</span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionTable</span><span class="params">(MetaObject metaStatementHandler, Object param )</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        String originalSql = (String) metaStatementHandler.getValue(<span class="string">"delegate.boundSql.sql"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(originalSql)) {</span><br><span class="line"></span><br><span class="line">            MappedStatement mappedStatement = (MappedStatement) metaStatementHandler.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line">            String id = mappedStatement.getId();</span><br><span class="line">            String className = id.substring(<span class="number">0</span>, id.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            String methodName = id.substring(id.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            Method method = findMethod(clazz.getDeclaredMethods(), methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据配置自动生成分表SQL,不配置查主表</span></span><br><span class="line">            TablesPartition tablesPartition = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) {</span><br><span class="line">                tablesPartition = method.getAnnotation(TablesPartition.class);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tablesPartition  == <span class="keyword">null</span>) {</span><br><span class="line">                tablesPartition = clazz.getAnnotation(TablesPartition.class);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tablesPartition != <span class="keyword">null</span> &amp;&amp; tablesPartition.split()) {</span><br><span class="line"></span><br><span class="line">                TablePartition[] tablePartitionList = tablesPartition.value();</span><br><span class="line">                String convertedSql = originalSql;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (TablePartition tablePartition:tablePartitionList) {</span><br><span class="line"></span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(tablePartition.value());</span><br><span class="line"></span><br><span class="line">                    String resort = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span> (param <span class="keyword">instanceof</span> Map) {</span><br><span class="line">                        resort = (String)((Map) param).get(tablePartition.field());</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (param <span class="keyword">instanceof</span> String) {</span><br><span class="line">                        resort = (String)param;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isEmpty(resort)) {</span><br><span class="line">                        stringBuilder.append(<span class="string">"_"</span>);</span><br><span class="line">                        stringBuilder.append(resort);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 替换表名前先把包含表名的字段名*_替换为"thisIsSpecialColumn"</span></span><br><span class="line">                    convertedSql = convertedSql.replaceAll(<span class="string">"(?i)"</span> + tablePartition.value()+<span class="string">"_"</span>, <span class="string">"thisIsSpecialColumn"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 替换表名,不区分大小写</span></span><br><span class="line">                    convertedSql = convertedSql.replaceAll(<span class="string">"(?i)"</span> + tablePartition.value(), stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 替换表名完成把"thisIsSpecialColumn"替换回字段名*_</span></span><br><span class="line">                    convertedSql = convertedSql.replaceAll(<span class="string">"thisIsSpecialColumn"</span>, tablePartition.value()+<span class="string">"_"</span>);</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                log.debug(<span class="string">"分表后的SQL:\n"</span> + convertedSql);</span><br><span class="line"></span><br><span class="line">                metaStatementHandler.setValue(<span class="string">"delegate.boundSql.sql"</span>, convertedSql);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">findMethod</span><span class="params">(Method[] methods, String methodName)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) {</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(methodName)) {</span><br><span class="line">                <span class="keyword">return</span> method;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Mybatis插件（plugins）&quot;&gt;&lt;a href=&quot;#Mybatis插件（plugins）&quot; class=&quot;headerlink&quot; title=&quot;Mybatis插件（plugins）&quot;&gt;&lt;/a&gt;Mybatis插件（plugins）&lt;/h3&gt;&lt;p&gt;Mybatis允许在已映射的语句执行过程中某一点进行拦截。Mybatis允许使用插件来拦截的方法调用包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)&lt;/li&gt;
&lt;li&gt;ParameterHandler (getParameterObject, setParameters)&lt;/li&gt;
&lt;li&gt;ResultSetHandler (handleResultSets, handleOutputParameters)&lt;/li&gt;
&lt;li&gt;StatementHandler (prepare, parameterize, batch, update, query)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别拦截以下方法调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拦截执行器的方法&lt;/li&gt;
&lt;li&gt;拦截参数的处理&lt;/li&gt;
&lt;li&gt;拦截结果集的处理&lt;/li&gt;
&lt;li&gt;拦截Sql语法构建的处理&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://haifuns.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="ORM" scheme="https://haifuns.com/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>SVN报错Previous operation has not finished; run &#39;cleanup&#39; if it was interrupted解决</title>
    <link href="https://haifuns.com/2019/11/02/svn/"/>
    <id>https://haifuns.com/2019/11/02/svn/</id>
    <published>2019-11-02T13:21:00.000Z</published>
    <updated>2025-02-23T13:53:31.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>svn因为版本冲突等问题导致的报错，无法cleanup、update、commit，报错”Previous operation has not finished; run ‘cleanup’ if it was interrupted”</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><p>1.下载sqlite3.exe<br><a href="https://www.sqlite.org/2019/sqlite-tools-win32-x86-3300100.zip">https://www.sqlite.org/2019/sqlite-tools-win32-x86-3300100.zip</a></p><p>2.将sqlite3.exe复制到项目.svn文件夹中，通wc.db文件同目录</p><p>3.执行命令</p><p>cd 到.svn目录</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\SVN\***\.svn&gt;sqlite3.exe wc.db</span><br><span class="line">SQLite version 3.30.1 2019-10-10 20:19:45</span><br><span class="line">Enter ".help" for usage hints.</span><br><span class="line">sqlite&gt; .table</span><br><span class="line">ACTUAL_NODE    NODES          PRISTINE       WC_LOCK</span><br><span class="line">EXTERNALS      NODES_BASE     REPOSITORY     WORK_QUEUE</span><br><span class="line">LOCK           NODES_CURRENT  WCROOT</span><br><span class="line">sqlite&gt; DELETE FROM WORK_QUEUE;</span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></tbody></table></figure><p>4.执行svn的clean up操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;p&gt;svn因为版本冲突等问题导致的报错，无法cleanup、update、commit，报错”Previous operation has no</summary>
      
    
    
    
    <category term="工具" scheme="https://haifuns.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="SVN" scheme="https://haifuns.com/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透工具 -- Frp</title>
    <link href="https://haifuns.com/2019/11/02/frp/"/>
    <id>https://haifuns.com/2019/11/02/frp/</id>
    <published>2019-11-02T13:13:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。</p><blockquote><p>github:<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p></blockquote><h3 id="FRP-安装"><a href="#FRP-安装" class="headerlink" title="FRP 安装"></a>FRP 安装</h3><ul><li>软件包下载</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 服务端</span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line">tar xzvf frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line">mv frp_0.29.0_linux_amd64 frp</span><br><span class="line"></span><br><span class="line">-- 客户端</span><br><span class="line">https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_windows_amd64.zip</span><br></pre></td></tr></tbody></table></figure><blockquote><p>更多版本前往：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p></blockquote><span id="more"></span><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><blockquote><p>这里以linux作为服务端，windows作为客户端实现web服务http/https穿透</p></blockquote><h3 id="简单连接"><a href="#简单连接" class="headerlink" title="简单连接"></a>简单连接</h3><ul><li>服务端</li></ul><p>默认配置中监听的是 7000 端口，可根据自己实际情况修改</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ vi frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000 </span><br><span class="line"></span><br><span class="line"># 最大连接数 </span><br><span class="line">max_pool_count = 500   </span><br><span class="line"># 客户端映射的端口  </span><br><span class="line">vhost_http_port = 9527                                                                 </span><br><span class="line"># 服务器看板的访问端口                                                                 </span><br><span class="line">dashboard_port = 7500</span><br><span class="line"># 服务器看板账户       </span><br><span class="line">dashboard_user = root </span><br><span class="line"># 服务器看板密码</span><br><span class="line">dashboard_pwd = 123456 </span><br></pre></td></tr></tbody></table></figure><p>启动</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></tbody></table></figure><ul><li>客户端</li></ul><p>修改frpc.ini文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line"># server_addr 为 FRP 服务端的公网 IP</span><br><span class="line">server_addr = 127.0.0.1</span><br><span class="line"># server_port 为 FRP 服务端监听的端口</span><br><span class="line">server_port = 7000</span><br></pre></td></tr></tbody></table></figure><p>cmd cd到目录下执行.\frpc.exe -c frpc.ini<br>这样就可以成功在 FRP 服务端上成功建立一个客户端连接，此时我们还没有注册任何端口映射</p><h3 id="通过-TCP-访问内网机器"><a href="#通过-TCP-访问内网机器" class="headerlink" title="通过 TCP 访问内网机器"></a>通过 TCP 访问内网机器</h3><p>frpc.ini添加</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br></pre></td></tr></tbody></table></figure><p>这样就在 FRP 服务端上成功注册了一个端口为 6000 的服务，接下来我们就可以通过这个端口访问内网机器上 SSH 服务，假设用户名为 frp：<br>$ ssh -oPort=6000 frp@公网IP</p><h3 id="通过自定义域名访问部署于内网的-Web-服务"><a href="#通过自定义域名访问部署于内网的-Web-服务" class="headerlink" title="通过自定义域名访问部署于内网的 Web 服务"></a>通过自定义域名访问部署于内网的 Web 服务</h3><ul><li>服务端</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"># HTTP 访问端口以8080为例，自改</span><br><span class="line">vhost_http_port = 8080</span><br><span class="line"></span><br><span class="line">$ ./frps -c ./frps.ini</span><br></pre></td></tr></tbody></table></figure><ul><li>客户端</li></ul><p>frpc.ini添加</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[web]</span><br><span class="line"># type = https对应的服务端vhost_http_port改为vhost_https_port</span><br><span class="line">type = http</span><br><span class="line"># 内网端口</span><br><span class="line">local_port = 80</span><br><span class="line"># 使用域名需要将域名A记录解析到 FRP 服务器的公网 IP</span><br><span class="line">custom_domains = 服务端域名/ip</span><br></pre></td></tr></tbody></table></figure><p>启动客户端即可以通过 http://服务端域名/ip:8080访问内网<a href="http://ip:80服务">http://ip:80服务</a></p><h3 id="为本地-HTTP-服务启用-HTTPS"><a href="#为本地-HTTP-服务启用-HTTPS" class="headerlink" title="为本地 HTTP 服务启用 HTTPS"></a>为本地 HTTP 服务启用 HTTPS</h3><p>通过 https2http 插件可以让本地 HTTP 服务转换成 HTTPS 服务对外提供。</p><p>启用 frpc，启用 https2http 插件，配置如下:<br>frpc.ini</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[test_htts2http]</span><br><span class="line">type = https</span><br><span class="line">custom_domains = test.yourdomain.com</span><br><span class="line"></span><br><span class="line">plugin = https2http</span><br><span class="line">plugin_local_addr = 127.0.0.1:80</span><br><span class="line"></span><br><span class="line"># HTTPS 证书相关的配置</span><br><span class="line">plugin_crt_path = ./server.crt</span><br><span class="line">plugin_key_path = ./server.key</span><br><span class="line">plugin_host_header_rewrite = 127.0.0.1</span><br><span class="line">plugin_header_X-From-Where = frp</span><br></pre></td></tr></tbody></table></figure><p>通过浏览器访问 <a href="https://test.yourdomain.com/">https://test.yourdomain.com</a> 即可。</p><h3 id="自定义二级域名"><a href="#自定义二级域名" class="headerlink" title="自定义二级域名"></a>自定义二级域名</h3><p>在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。<br>只需要将 *.{subdomain_host} 解析到 frps 所在服务器。之后用户可以通过 subdomain 自行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomain_host} 来访问自己的 web 服务。</p><p>frps.ini</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">subdomain_host = frps.com</span><br><span class="line">将泛域名 *.frps.com 解析到 frps 所在服务器的 IP 地址。</span><br></pre></td></tr></tbody></table></figure><p>frpc.ini</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">subdomain = test</span><br></pre></td></tr></tbody></table></figure><p>frps 和 frpc 都启动成功后，通过 test.frps.com 就可以访问到内网的 web 服务。</p><p>注：如果 frps 配置了 subdomain_host，则 custom_domains 中不能是属于 subdomain_host 的子域名或者泛域名。<br>同一个 http 或 https 类型的代理中 custom_domains 和 subdomain 可以同时配置。</p><h3 id="通过密码保护你的-web-服务"><a href="#通过密码保护你的-web-服务" class="headerlink" title="通过密码保护你的 web 服务"></a>通过密码保护你的 web 服务</h3><p>frpc.ini</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = test.yourdomain.com</span><br><span class="line">http_user = abc</span><br><span class="line">http_pwd = abc</span><br></pre></td></tr></tbody></table></figure><p>通过浏览器访问 <a href="http://test.yourdomain.com,需要输入配置的用户名和密码才能访问./">http://test.yourdomain.com，需要输入配置的用户名和密码才能访问。</a></p><h3 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h3><ul><li>对外提供简单的文件访问服务</li><li>安全地暴露内网服务</li><li>点对点内网穿透</li><li>···</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;github:&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;https://github.com/fatedier/frp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;FRP-安装&quot;&gt;&lt;a href=&quot;#FRP-安装&quot; class=&quot;headerlink&quot; title=&quot;FRP 安装&quot;&gt;&lt;/a&gt;FRP 安装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;软件包下载&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- 服务端&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar xzvf frp_0.29.0_linux_amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv frp_0.29.0_linux_amd64 frp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- 客户端&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_windows_amd64.zip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;更多版本前往：&lt;a href=&quot;https://github.com/fatedier/frp/releases&quot;&gt;https://github.com/fatedier/frp/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="工具" scheme="https://haifuns.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Frp" scheme="https://haifuns.com/tags/Frp/"/>
    
  </entry>
  
  <entry>
    <title>pgbench -- PostgreSQL基准测试工具</title>
    <link href="https://haifuns.com/2019/09/17/pgbench/"/>
    <id>https://haifuns.com/2019/09/17/pgbench/</id>
    <published>2019-09-17T13:44:00.000Z</published>
    <updated>2025-02-23T13:53:31.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>pgbench是一种在PostgreSQL上运行基准测试的简单程序。它可能在并发的数据库会话中一遍一遍地运行相同序列的 SQL 命令，并且计算平均事务率（每秒的事务数）。默认情况下，pgbench会测试一种基于 TPC-B 但是要更宽松的场景，其中在每个事务中涉及五个SELECT、UPDATE以及INSERT命令。但是，通过编写自己的事务脚本文件很容易用来测试其他情况。</p><p>pgbench的典型输出像这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">transaction type: &lt;builtin: TPC-B (sort of)&gt;</span><br><span class="line">scaling factor: 10</span><br><span class="line">query mode: simple</span><br><span class="line">number of clients: 10</span><br><span class="line">number of threads: 1</span><br><span class="line">number of transactions per client: 1000</span><br><span class="line">number of transactions actually processed: 10000/10000</span><br><span class="line">tps = 85.184871 (including connections establishing)</span><br><span class="line">tps = 85.296346 (excluding connections establishing)</span><br></pre></td></tr></tbody></table></figure><p>前六行报告一些最重要的参数设置。接下来的行报告完成的事务数以及预期的事务数（后者就是客户端数量与每个客户端事务数的乘积），除非运行在完成之前失败，这些值应该是相等的（在-T模式中，只有实际的事务数会被打印出来）。最后两行报告每秒的事务数，分别代表包括和不包括开始数据库会话所花时间的情况。</p><p>默认的类 TPC-B 事务测试要求预先设置好特定的表。使用-i 进行初始化，创建默认表</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgbench -i [ other-options ] dbname</span><br></pre></td></tr></tbody></table></figure><p>可能会用到-h/-p/-U选项指定数据库。</p><span id="more"></span><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>下面分成三个部分：数据库初始化期间使用的选项、运行基准时使用的选项、两种情况下都有用的选项。</p><h5 id="初始化选项"><a href="#初始化选项" class="headerlink" title="初始化选项"></a>初始化选项</h5><p>pgbench接受下列命令行初始化参数：</p><p>-i<br>–initialize</p><p>要求调用初始化模式。</p><p>-F <em>fillfactor</em><br>–fillfactor=<em>fillfactor</em></p><p>用给定的填充因子创建pgbench_accounts、 pgbench_tellers和 pgbench_branches表。默认值是 100。</p><p>-n<br>–no-vacuum</p><p>初始化以后不执行清理。</p><p>-q<br>–quiet</p><p>把记录切换到安静模式，只是每 5 秒产生一个进度消息。默认的记录会每 100000 行打印一个消息，这经常会在每秒钟输出很多行（特别是在好的硬件上）。</p><p>-s <em>scale_factor</em><br>–scale=<em>scale_factor</em></p><p>将生成的行数乘以比例因子。例如，-s 100将在pgbench_accounts表中创建 10,000,000 行。默认为 1。当比例为 20,000 或更高时，用来保存账号标识符的列（aid列）将切换到使用更大的整数（bigint），这样才能足以保存账号标识符。</p><p>–foreign-keys</p><p>在标准的表之间创建外键约束。</p><p>–index-tablespace=<em>index_tablespace</em></p><p>在指定的表空间而不是默认表空间中创建索引。</p><p>–tablespace=<em>tablespace</em></p><p>在指定的表空间而不是默认表空间中创建表。</p><p>–unlogged-tables</p><p>把所有的表创建为非日志记录表而不是永久表。</p><h5 id="基准选项"><a href="#基准选项" class="headerlink" title="基准选项"></a>基准选项</h5><p>pgbench接受下列命令行基准参数：</p><p>-b <em>scriptname[@weight]</em><br>–builtin=<em>scriptname[@weight]</em></p><p>把指定的内建脚本加入到要执行的脚本列表中。@之后是一个可选的整数权重，它允许调节抽取该脚本的可能性。如果没有指定，它会被设置为 1。可用的内建脚本有：tpcb-like、simple-update和select-only。这里也接受内建名称无歧义的前缀缩写。如果用上特殊的名字list，将会显示内建脚本的列表并且立刻退出。</p><p>-c <em>clients</em><br>–client=<em>clients</em></p><p>模拟的客户端数量，也就是并发数据库会话数量。默认为 1。</p><p>-C<br>–connect</p><p>为每一个事务建立一个新连接，而不是只为每个客户端会话建立一个连接。这对于度量连接开销有用。</p><p>-d<br>–debug</p><p>打印调试输出。</p><p>-D <em>varname</em>=<em>value</em><br>–define=<em>varname</em>=<em>value</em></p><p>定义一个由自定义脚本（见下文）使用的变量。允许多个-D选项。</p><p>-f <em>filename[@weight]</em><br>–file=<em>filename[@weight]</em></p><p>把一个从<em>filename</em>读到的事务脚本加入到被执行的脚本列表中。@后面是一个可选的整数权重，它允许调节抽取该测试的可能性。详见下文。</p><p>-j <em>threads</em><br>–jobs=<em>threads</em></p><p>pgbench中的工作者线程数量。在多 CPU 机器上使用多于一个线程会有用。客户端会尽可能均匀地分布到可用的线程上。默认为 1。</p><p>-l<br>–log</p><p>把每一个事务花费的时间写到一个日志文件中。详见下文。</p><p>-L <em>limit</em><br>–latency-limit=<em>limit</em></p><p>对持续超过<em>limit</em>毫秒的事务进行独立的计数和报告， 这些事务被认为是<em>迟到（late）</em>了的事务。</p><p>在使用限流措施时（–rate=…），滞后于计划超过 <em>limit</em>毫秒并且因此没有希望满足延迟限制的事务根本 不会被发送给服务器。这些事务被认为是<em>被跳过（skipped）</em> 的事务，它们会被单独计数并且报告。</p><p>-M <em>querymode</em><br>–protocol=<em>querymode</em></p><p>要用来提交查询到服务器的协议：</p><ul><li><p>simple：使用简单查询协议。</p></li><li><p>extended使用扩展查询协议。</p></li><li><p>prepared：使用带预备语句的扩展查询语句。</p></li></ul><p>默认是简单查询协议。</p><p>-n<br>–no-vacuum</p><p>在运行测试前不进行清理。如果你在运行一个不包括标准的表pgbench_accounts、 pgbench_branches、pgbench_history和 pgbench_tellers的自定义测试场景时，这个选项是<em>必需的</em>。</p><p>-N<br>–skip-some-updates</p><p>运行内建的简单更新脚本。这是-b simple-update的简写。</p><p>-P <em>sec</em><br>–progress=<em>sec</em></p><p>每<em>sec</em>秒显示进度报告。该报告包括运行了多长时间、从上次报告以来的 tps 以及从上次报告以来事务延迟的平均值和标准偏差。如果低于限流值（-R），延迟会相对于事务预定的开始时间（而不是实际的事务开始时间）计算，因此其中也包括了平均调度延迟时间。</p><p>-r<br>–report-latencies</p><p>在基准结束后，报告平均的每个命令的每语句等待时间（从客户端的角度来说是执行时间）。详见下文。</p><p>-R <em>rate</em><br>–rate=<em>rate</em></p><p>按照指定的速率执行事务而不是尽可能快地执行（默认行为）。该速率 以 tps（每秒事务数）形式给定。如果目标速率高于最大可能速率，则 该速率限制不会影响结果。</p><p>该速率的目标是按照一条泊松分布的调度时间线开始事务。期望的开始 时间表会基于客户端第一次开始的时间（而不是上一个事务结束的时 间）前移。这种方法意味着当事务超过它们的原定结束时间时，更迟的 那些有机会再次追赶上来。</p><p>当限流措施被激活时，运行结束时报告的事务延迟是从预订的开始时间计 算而来的，因此它包括每一个事务不得不等待前一个事务结束所花的时 间。该等待时间被称作调度延迟时间，并且它的平均值和最大值也会被 单独报告。关于实际事务开始时间的事务延迟（即在数据库中执行事务 所花的时间）可以用报告的延迟减去调度延迟时间计算得到。</p><p>如果把–latency-limit和–rate一起使用， 当一个事务在前一个事务结束时已经超过了延迟限制时，它可能会滞后 非常多，因为延迟是从计划的开始时间计算得来。这类事务不会被发送 给服务器，而是一起被跳过并且被单独计数。</p><p>一个高的调度延迟时间表示系统无法用选定的客户端和线程数按照指定 的速率处理事务。当平均的事务执行时间超过每个事务之间的调度间隔 时，每一个后续事务将会落后更多，并且随着测试运行时间越长，调度 延迟时间将持续增加。发生这种情况时，你将不得不降低指定的事务速率。</p><p>-s <em>scale_factor</em><br>–scale=<em>scale_factor</em></p><p>在pgbench的输出中报告指定的比例因子。对于内建测试，这并非必需；正确的比例因子将通过对pgbench_branches表中的行计数来检测。不过，当只测试自定义基准（-f选项）时，比例因子将被报告为 1（除非使用了这个选项）。</p><p>-S<br>–select-only</p><p>执行内建的只有选择的脚本。是-b select-only简写形式。</p><p>-t <em>transactions</em><br>–transactions=<em>transactions</em></p><p>每个客户端运行的事务数量。默认为 10。</p><p>-T <em>seconds</em><br>–time=<em>seconds</em></p><p>运行测试这么多秒，而不是为每个客户端运行固定数量的事务。-t和-T是互斥的。</p><p>-v<br>–vacuum-all</p><p>在运行测试前清理所有四个标准的表。在没有用-n以及-v时， pgbench将清理pgbench_tellers 和pgbench_branches表，并且截断pgbench_history。</p><p>–aggregate-interval=<em>seconds</em></p><p>聚集区间的长度（以秒计）。可以只与-l一起使用 - 通过这个选项，日志会包含每个区间的总结（事务数、最小/最大等待时间以及用于方差估计的两个额外域）。</p><p>当前在 Windows 上不支持这个选项。</p><p>–progress-timestamp</p><p>当显示进度（选项-P）时，使用一个时间戳（Unix 时间）取代从运行开始的秒数。单位是秒，在小数点后是毫秒精度。这可以有助于比较多种工具生成的日志。</p><p>–sampling-rate=<em>rate</em></p><p>采样率，在写入数据到日志时被用来减少日志产生的数量。如果给出这个选项，只有指定比例的事务被记录。1.0 表示所有事务都将被记录，0.05 表示只有 5% 的事务会被记录。</p><p>在处理日志文件时，记得要考虑这个采样率。例如，当计算 tps 值时，你需要相应地乘以这个数字（例如，采样率是 0.01，你将只能得到实际 tps 的 1/100）。</p><h5 id="普通选项"><a href="#普通选项" class="headerlink" title="普通选项"></a>普通选项</h5><p>pgbench接受下列命令行普通参数：</p><p>-h <em>hostname</em><br>–host=<em>hostname</em></p><p>数据库服务器的主机名</p><p>-p <em>port</em><br>–port=<em>port</em></p><p>数据库服务器的端口号</p><p>-U <em>login</em><br>–username=<em>login</em></p><p>要作为哪个用户连接</p><p>-V<br>–version</p><p>打印pgbench版本并退出。</p><p>-?<br>–help</p><p>显示有关pgbench命令行参数的信息，并且退出。</p><h4 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a>自定义脚本</h4><p>pgbench支持通过从一个文件中（-f选项，配合-n）读取事务脚本替换默认的事务脚本，例如（先cmd cd到postgresql bin目录）：</p><p><code>pgbench -M extended -h 127.0.0.1 -p 5432 -U postgres -n -P 60 -c 50 -j 50 -T 180 -f E://select.sql -r db</code></p><p>-n -f 指定sql,50连接50线程持续180s,每60s打印状态，另外-d 可打印debug日志</p><p>select.sql内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\set numb random(1000,2000)</span><br><span class="line">BEGIN;</span><br><span class="line">select "id" from table1 where numb = :numb;</span><br><span class="line">END;</span><br></pre></td></tr></tbody></table></figure><h4 id="每语句延迟"><a href="#每语句延迟" class="headerlink" title="每语句延迟"></a>每语句延迟</h4><p>通过-r选项，pgbench收集每一个客户端执行的每一个语句花费的事务时间。然后在基准完成后，它会报告这些值的平均值，作为每个语句的延迟。</p><p>对于默认脚本，输出看起来会像这样：</p><pre><code> starting vacuum...end.transaction type: &lt;builtin: TPC-B (sort of)&gt;scaling factor: 1query mode: simplenumber of clients: 10number of threads: 1number of transactions per client: 1000number of transactions actually processed: 10000/10000latency average = 15.844 mslatency stddev = 2.715 mstps = 618.764555 (including connections establishing)tps = 622.977698 (excluding connections establishing)script statistics:-   statement latencies in milliseconds:0.002  \set aid random(1, 100000 * :scale) 0.005  \set bid random(1, 1 * :scale) 0.002  \set tid random(1, 10 * :scale) 0.001  \set delta random(-5000, 5000) 0.326  BEGIN; 0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid; 0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid; 5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid; 7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid; 0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP); 1.212  END;</code></pre><p>如果指定了多个脚本文件，会为每一个脚本文件单独报告平均值。</p><p>tps为平均事务率（每秒的事务数）</p><h4 id="pgbench-函数"><a href="#pgbench-函数" class="headerlink" title="pgbench 函数"></a>pgbench 函数</h4><table><thead><tr><th>函数</th><th>返回类型</th><th>描述</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code>abs(*a*)</code></td><td>和<em>a</em>相同</td><td>绝对值</td><td>abs(-17)</td><td>17</td></tr><tr><td><code>debug(*a*)</code></td><td>和<em>a</em>相同</td><td>把<em>a</em>打印到stderr，并且返回<em>a</em></td><td>debug(5432.1)</td><td>5432.1</td></tr><tr><td><code>double(*i*)</code></td><td>double</td><td>转换成 double</td><td>double(5432)</td><td>5432.0</td></tr><tr><td><code>greatest(*a* [, *...* ] )</code></td><td>如果任何一个<em>a</em>是 double 则为 double，否则是 integer</td><td>参数之中的最大值</td><td>greatest(5, 4, 3, 2)</td><td>5</td></tr><tr><td><code>int(*x*)</code></td><td>integer</td><td>转换成 int</td><td>int(5.4 + 3.8)</td><td>9</td></tr><tr><td><code>least(*a* [, *...* ] )</code></td><td>如果任何一个<em>a</em>是 double 则为 double，否则是 integer</td><td>参数之中的最小值</td><td>least(5, 4, 3, 2.1)</td><td>2.1</td></tr><tr><td><code>pi()</code></td><td>double</td><td>常量 PI 的值</td><td>pi()</td><td>3.14159265358979323846</td></tr><tr><td><code>random(*lb*, *ub*)</code></td><td>integer</td><td>[lb, ub]中的均匀分布随机整数</td><td>random(1, 10)</td><td>1和10之间的一个整数</td></tr><tr><td><code>random_exponential(*lb*, *ub*, *parameter*)</code></td><td>integer</td><td>[lb, ub]中的指数分布随机整数，见下文</td><td>random_exponential(1, 10, 3.0)</td><td>1和10之间的一个整数</td></tr><tr><td><code>random_gaussian(*lb*, *ub*, *parameter*)</code></td><td>integer</td><td>[lb, ub]中的高斯分布随机整数，见下文</td><td>random_gaussian(1, 10, 2.5)</td><td>1和10之间的一个整数</td></tr><tr><td><code>sqrt(*x*)</code></td><td>double</td><td>平方根</td><td>sqrt(2.0)</td><td>1.414213562</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h4&gt;&lt;p&gt;pgbench是一种在PostgreSQL上运行基准测试的简单程序。它可能在并发的数据库会话中一遍一遍地运行相同序列的 SQL 命令，并且计算平均事务率（每秒的事务数）。默认情况下，pgbench会测试一种基于 TPC-B 但是要更宽松的场景，其中在每个事务中涉及五个SELECT、UPDATE以及INSERT命令。但是，通过编写自己的事务脚本文件很容易用来测试其他情况。&lt;/p&gt;
&lt;p&gt;pgbench的典型输出像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;transaction type: &amp;lt;builtin: TPC-B (sort of)&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scaling factor: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;query mode: simple&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;number of clients: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;number of threads: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;number of transactions per client: 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;number of transactions actually processed: 10000/10000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tps = 85.184871 (including connections establishing)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tps = 85.296346 (excluding connections establishing)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;前六行报告一些最重要的参数设置。接下来的行报告完成的事务数以及预期的事务数（后者就是客户端数量与每个客户端事务数的乘积），除非运行在完成之前失败，这些值应该是相等的（在-T模式中，只有实际的事务数会被打印出来）。最后两行报告每秒的事务数，分别代表包括和不包括开始数据库会话所花时间的情况。&lt;/p&gt;
&lt;p&gt;默认的类 TPC-B 事务测试要求预先设置好特定的表。使用-i 进行初始化，创建默认表&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pgbench -i [ other-options ] dbname&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可能会用到-h/-p/-U选项指定数据库。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://haifuns.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="PostgreSQL" scheme="https://haifuns.com/tags/PostgreSQL/"/>
    
    <category term="Pgbench" scheme="https://haifuns.com/tags/Pgbench/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础</title>
    <link href="https://haifuns.com/2019/07/15/rabbitmq/"/>
    <id>https://haifuns.com/2019/07/15/rabbitmq/</id>
    <published>2019-07-15T12:30:00.000Z</published>
    <updated>2025-02-23T13:53:31.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>消息 (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、 JSON 等，也可以很复杂，比如内嵌对象。</p><p>消息队列中间件 (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p><p>消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:点对点 (P2P, Point-to-Point) 模式和发布/订阅 (Pub/Sub) 模式。</p><h2 id="中间件作用"><a href="#中间件作用" class="headerlink" title="中间件作用"></a>中间件作用</h2><ul><li>解耦</li><li>冗余（存储）</li><li>扩展性</li><li>削峰</li><li>可恢复性</li><li>顺序保证</li><li>缓冲</li><li>异步通信</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>可靠性：RabbitMQ使用机制保证可靠性，如持久化、传输确认以及发布确认等</li><li>灵活的路由：通过交换器路由消息到队列</li><li>扩展性：可集群</li><li>高可用性： 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用（镜像集群：不同队列消息同步）</li><li>多种协议： 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等</li><li>多语言客户端：如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li><li>管理界面：提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。（rabbitmq_management插件）</li><li>插件机制：插件丰富可扩展</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><span id="more"></span><ul><li>安装Erlang</li></ul><p>第一步，解压安装包（可在<a href="https://www.erlang.org/downloads">官网</a>下载安装），并配置安装目录，这里我们预备安装到/opt/erlang 目录下:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden -)# tar zxvf otp_src_19.3.tar.gz </span><br><span class="line">[root@hidden -)# cd otp src 19.3 </span><br><span class="line">[root@hidden otp src_19.3)# ./configure --prefix=/opt/er1ang </span><br></pre></td></tr></tbody></table></figure><p>第二步，如果出现类似关键报错信息: No curses library functions found。那么此时需要安装 ncurses，安装步骤(遇到提示输入 y 后直接回车即可)如下:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden otp_src_19.3)# yum install ncurses-devel</span><br></pre></td></tr></tbody></table></figure><p>第三步，安装 Erlang:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden otp_src_19.3)# make</span><br><span class="line">[root@hidden otp_src_19.3)# make install</span><br></pre></td></tr></tbody></table></figure><p>第四步，修改/etc/profile 配置文件，添加下面的环境变量:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERLANG HOME=/opt/erlang</span><br><span class="line">export PATH=PATH:ERLANG HOME/bin</span><br><span class="line">export ERLANG_HOME</span><br></pre></td></tr></tbody></table></figure><p>最后执行如下命令让配置文件生效:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden otp_src_19.3) # source /etc/profile</span><br></pre></td></tr></tbody></table></figure><p>可以输入 erl 命令来验证 Erlang 是否安装成功，如果出现类似以下的提示即表示安装成功:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden -)# erl</span><br><span class="line">Erlang/OTP 19 [erts-8.1) [source) [64-bit) [smp:4 : 4) [async-threads : 10) [hipe) [kernel-poll:false) </span><br><span class="line">Eshell V8 . 1 (abort with ^G ) </span><br><span class="line"><span class="meta">1&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>安装RabbitMQ</li></ul><p><a href="https://www.rabbitmq.com/download.html">官网</a>下载地址</p><p>这里选择将 RabbitMQ 安装到/opt</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden -]# tar zvxf rabbitmq-server-generic-unix-3.6.10.tar.gz -C /opt</span><br><span class="line">[root@hidden - ]# cd lopt</span><br><span class="line">[root@hidden -]# mv rabbitmq_server-3.6.10 rabbitmq</span><br></pre></td></tr></tbody></table></figure><p>同样修改/etc/profile 文件 添加下面的环境变量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH : /opt/rabbitmq/sbin</span><br><span class="line">export RABBITMQ HOME=/opt/rabbitmq</span><br></pre></td></tr></tbody></table></figure><p>之后执行 source /etc/profile 命令让配置文件生效。<br>运行 RabbitMQ</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></tbody></table></figure><p>rabbitmq-server 命令后面添加一个 “-detached” 参数是为了能够让RabbitMQ服务以守护进程的方式在后台运行，这样就不会因为当前 Shell 窗口的关闭而影响服务。<br>运行 <code>rabbitmqctl status</code> 命令查看 RabbitMQ 是否正常启动:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hidden -]# rabbitmqctl status</span><br><span class="line">```shell</span><br><span class="line">`rabbitmqctl cluster_status` 命令来查看集群信息，目前只有一个 RabbitMQ 服务节点，可以看作单节点</span><br><span class="line">的集群</span><br><span class="line">```shell</span><br><span class="line">[root@hidden -]# rabbitmqctl cluster_status</span><br></pre></td></tr></tbody></table></figure><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><blockquote><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。</p></blockquote><ul><li>Producer: 生产者，就是投递消息的一方。</li><li>Consumer: 消费者， 就是接收消息的一方。</li><li>Broker: 消息中间件的服务节点。</li><li>Queue: 队列，是 RabbitMQ 的内部对象，用于存储消息。<ul><li>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询） 给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理</li></ul></li><li>Exchange: 交换器。<ul><li><p>fanout：把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</p></li><li><p>direct：把消息路由到那些 BindingKey 和 RoutingKey完全匹配的队列中。</p></li><li><p>headers：不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p></li><li><p>topic：将消息路由到 BindingKey 和 RoutingKey 相匹配的队 列中，但这里的匹配规则有些不同，它约定:</p><ul><li>RoutingKey 为一个点号”.”分隔的字符串(被点号”.”分隔开的每一段独立的字符 串称为一个单词 )，如com.rabbit.client</li><li>BindingKey 和 RoutingKey 一样也是点号”.”分隔的字符串</li><li>BindingKey 中可以存在两种特殊字符串”<em>“和”#”，用于做模糊匹配，其中”</em>“用于匹配一个单词，”#”用于匹配多规格单词(可以是零个)。</li></ul></li></ul></li></ul><ul><li><p>RoutingKey: 路由键。生产者将消息发给交换器的时候， 一般会指定一个 RoutingKey，用 来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键 (BindingKey) 联合使用才能最终生效。</p></li><li><p>Binding: 绑定。 RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键 (BindingKey)。</p></li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><blockquote><p>hello world demo</p></blockquote><ul><li>引入依赖<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>生产消费消息<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"59.110.240.***"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 创建交换器 type="direct"、持久化、非自动删除</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">"exchange_demo"</span>,<span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 创建队列 持久化、非排他、非自动删除</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"queue_demo"</span>,<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 交换器与队列通过路由键绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">"queue_demo"</span>, <span class="string">"exchange_demo"</span>, <span class="string">"routingKey_demo"</span>);</span><br><span class="line">        <span class="comment">// 可绑定多个队列</span></span><br><span class="line">        <span class="comment">// channel.queueBind("queue_demo2", "exchange_demo", "routingKey_demo");</span></span><br><span class="line">        <span class="comment">// 发送持久化消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">"exchange_demo"</span>, <span class="string">"routingKey_demo"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"hello world"</span>.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        log.info(<span class="string">"send message to mq down!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>{</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]{</span><br><span class="line">                <span class="keyword">new</span> Address(<span class="string">"59.110.240.***"</span>,<span class="number">5672</span>)</span><br><span class="line">        };</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        Connection connection = factory.newConnection(addresses);</span><br><span class="line">        <span class="comment">// 创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 设置客户端最多接收未被ack的消息个数</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>{ </span><br><span class="line">                log.info(<span class="string">"receive message:{}"</span>, <span class="keyword">new</span> String(body));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动应答</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动拒绝，(消息标记，multi多条，requeue重新入队)</span></span><br><span class="line">                <span class="comment">// channel.basicNack(envelope.getDeliveryTag(), false, false);</span></span><br><span class="line">                <span class="comment">// 拒绝单条</span></span><br><span class="line">                <span class="comment">// channel.basicReject(envelope.getDeliveryTag(), false);</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        channel.basicConsume(<span class="string">"queue_demo"</span>, consumer);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="运转流程"><a href="#运转流程" class="headerlink" title="运转流程"></a>运转流程</h1><p>无论是生产者还是消费者，都需要和RabbitMQ Broker建立TCP 连接，也就是Connection 。客户端紧接着可以创建AMQP 信道(Channel) ，每个信道都会被指派一个唯一的ID。信道是建立在Connection之上的虚拟连接， RabbitMQ 处理的每条AMQP指令都是通过信道完成。(复用TCP连接，减少性能开销,便于管理)</p><h2 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h2><ol><li>生产者连接到RabbitMQ Broker，建立一个连接(Connection)，开启一个信道(Channel)</li><li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等</li><li>生产者声明一个队列并设置相关属性，比如是否排他、是否持久化、是否自动删除等</li><li>生产者通过路由键将交换器和队列绑定起来</li><li>生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息</li><li>相应的交换器根据接收到的路由键查找相匹配的队列</li><li>如果找到，则将从生产者发送过来的消息存入相应的队列中</li><li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者</li><li>关闭信道</li><li>关闭连接</li></ol><h2 id="消费者接收消息"><a href="#消费者接收消息" class="headerlink" title="消费者接收消息"></a>消费者接收消息</h2><ol><li>消费者连接到RabbitMQ Broker ，建立一个连接(Connection ) ，开启一个信道(Channel)</li><li>消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br>以及做一些准备工作</li><li>等待RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息</li><li>消费者确认( ack) 接收到的消息</li><li>RabbitMQ 从队列中删除相应己经被确认的消息</li><li>关闭信道</li><li>关闭连接</li></ol><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><ul><li>durable: 设置是否持久化。durable设置为true表示持久化，反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li><li>autoDelete: 设置是否自动删除。autoDelete 设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定， 之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为: “当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器” 。</li><li>internal: 设置是否是内置的。如果设置为true，则表示是内置的交换器，客户端无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li><li>argument: 其他一些结构化参数 alternate-exchange:备份交换器</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li>durable: 设置是否持久化。为true则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li><li>exclusive: 设置是否排他。为true则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接(Connection)可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; “首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列<br>适用于一个客户端同时发送和读取消息的应用场景。</li><li>autoAck: 是否自动确认，当autoAck 等于false时， RabbitMQ会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除) 。当autoAck 等于true时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。</li><li>autoDelete: 设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为: “当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li><li>argurnents: 设置队列的其他一些参数，如<ul><li>x-message-ttl:过期时间</li><li>x-expires:自动删除前处于未使用状态的时间</li><li>x-max-length/x-max-length-bytes:最大消息长度/总量(当队列中的消息要超过队列限制时，将失效队首元素)</li><li>x-dead-letter-exchange、x-deadletter-routing-key: 死信</li><li>x-max-priority:优先级</li></ul></li></ul><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>当消息无法被路由时，可以通过设置mandatory/immediate将消息返回给生产者。还可以设置alternate-exchange参数，将消息储存在备份交换器（Altemate Exchange），而不返回客户端。</p><ul><li>mandatory</li></ul><p>当mandatory参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件<br>的队列，那么RabbitMQ会调用Basic.Return命令将消息返回给生产者。当mandatory 参<br>数设置为false 时，出现上述情形，则消息直接被丢弃。</p><ul><li>immediate</li></ul><p>当immediate 参数设为true 时，如果交换器在将消息路由到队列时发现队列上并不存在<br>任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，<br>该消息会通过Basic.Return 返回至生产者。</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>Time to Live，即过期时间，消息在队列中生存时间超过TTL时可能会变成死信</p><ul><li><p>设置方式</p><ul><li>队列属性设置，x-message-ttl参数，单位<code>毫秒</code></li><li>对消息单独设置（1、2两种方式同时使用时以数值小的为准）</li></ul></li><li><p>x-expires:控制队列被自动删除前处于未使用状态的时间</p></li></ul><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>DLX ，全称为Dead-Letter-Exchange ，可以称之为死信交换器</p><p>消息变成死信一般是由于以下几种情况:</p><ol><li>消息被拒绝(Basic.Reject/Basic.Nack)，并且设置requeue参数为false;</li><li>消息过期;</li><li>队列达到最大长度;</li></ol><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>AMQP/Rabbitmq未提供此功能，但是可以通过TTL&amp;DLX模拟延迟队列功能，设置TTL并且订阅死信队列。</p><h2 id="RPC实现"><a href="#RPC实现" class="headerlink" title="RPC实现"></a>RPC实现</h2><p>一般在RabbitMQ 中进行RPC是很简单。客户端发送请求消息，服务端回复响应的消息。为了接收响应的消息，需要在请求消息中发送一个回调队列,可以使用默认的队列，参考下面代码中的replyTo。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String callbackQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties .Builder().replyTo(callbackQueueName).build();</span><br><span class="line">channel.basicPubish(<span class="string">""</span>,<span class="string">"rpc queue"</span>,props,message.getBytes()) ;</span><br><span class="line"><span class="comment">// then code to read a response message from the callback_queue...</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>replyTo:通常用来设置回调队列</p></li><li><p>correlationId:用来关联请求(request) 和其调用RPC之后的回复(response)。</p></li></ul><p>RabbitMQ官方 RRC<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCClient.java">客户端</a>&amp;<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/RPCServer.java">服务端</a>调用样例</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li>Excahnge</li></ul><p>durable=true</p><ul><li>Queue</li></ul><p>durable=true</p><ul><li>Message</li></ul><p>BasicProperties 中deliveryMode属性;deliveryMode=1代表不持久化，deliveryMode=2代表持久化。</p><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><ul><li>channel.txSelect:客户端将信道置为事务模式;</li><li>channel.tx.Select-Ok:Broker确认己将信道置为事务模式:</li><li>channel.txCommit:客户端提交事务;</li><li>channel.tx.Commit-Ok:Broker确认事务提交;</li><li>channel.txRollback:客户端提交事务回滚;</li><li>channel.txRollback-Ok:Broker确认事务回滚;</li></ul><p>代码示例:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>事务确认流程：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-tx-commit.png" alt="Image text"></p><p>事务回滚流程：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-tx-rollback.png" alt="Image text"></p><h3 id="发送方确认机制（publisher-confirm）"><a href="#发送方确认机制（publisher-confirm）" class="headerlink" title="发送方确认机制（publisher confirm）"></a>发送方确认机制（publisher confirm）</h3><p>生产者通过调用channel.confirmSelect将信道设置成confirm(确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID从l开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(Basic.Ack) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ 回传给生产者的确认消息中的delivery Tag包含了确认消息的序号， 此外RabbitMQ也可以设置channel.basicAck方法中的multiple参数，表示到这个序号之前的所有消息都己经得到了处理。</p><p>相比之下，发送方确认机制优势在于它是异步的，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack （Basic.Nack) 命令，生产者应用程序同样可以在回调方法中处理该nack 命令。</p><p>代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    channel.confirmSelect() ; <span class="comment">//将信道置为publisher confirm模式</span></span><br><span class="line">    <span class="comment">//之后正常发送消息</span></span><br><span class="line">    channel.basicPublish( <span class="string">"exchange"</span> , <span class="string">"routingKey"</span> , <span class="keyword">null</span> , <span class="string">"publisher confirm test"</span>.getBytes());</span><br><span class="line">    <span class="keyword">if</span>(!channel.waitForConfirms()) {</span><br><span class="line">        System.out.println(<span class="string">"send message failed"</span>);</span><br><span class="line">        <span class="comment">// do something else..</span></span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e){ </span><br><span class="line">    e.printStackTrace() ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步confirm</span></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    channel.confirmSelect() ;</span><br><span class="line">    channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Basic.Ack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag , <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">//deliveryTag:消息唯一有序序号</span></span><br><span class="line">    System.out.println(<span class="string">"Nack, SeqNo : "</span> + deliveryTag + <span class="string">", multiple : "</span> + multiple);</span><br><span class="line">    <span class="comment">// multiple=false一条, true多条</span></span><br><span class="line">    <span class="keyword">if</span> (multiple) {</span><br><span class="line">    <span class="comment">// unconfirm有序集合 SortedSet</span></span><br><span class="line">    confirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">    confirmSet.remove(deliveryTag);</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Basic.Nack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">if</span> (multiple) {</span><br><span class="line">    confirmSet.headSet (deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">    confirmSet.remove(deliveryTag) ;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 消息重发</span></span><br><span class="line">    }</span><br><span class="line">    });</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e){ </span><br><span class="line">    e.printStackTrace() ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发送方确认机制：</p><p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-confirm.png" alt="Image text"></p><h2 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h2><p>消息可靠传输一般是业务系统接入消息中间件时首先需要考虑的问题,一般消息中间件的消息传输保障分为三个层次：</p><ul><li>At most once: 最多一次。消息可能会丢失，但绝不会重复传输。</li><li>At least once: 最少一次。消息绝不会丢失，但可能会重复传输。</li><li>Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。</li></ul><p>rabbitmq可以支持其中的“最多一次”和“最少一次”。</p><p>最少一次投递需要考虑以下几方面内容：</p><ol><li>消息生产者需要开启事务机制或者发送方确认机制，保证消息可靠的传输到mq</li><li>生产者配合使用mandatory参数或者备份数据库来确认消息能从交换器路由到队列</li><li>消息和队列进行持久化处理</li><li>消费者手动确认，autoAck=false</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;消息 (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、 JSON 等，也可以很复杂，比如内嵌对象。&lt;/p&gt;
&lt;p&gt;消息队列中间件 (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。&lt;/p&gt;
&lt;p&gt;消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:点对点 (P2P, Point-to-Point) 模式和发布/订阅 (Pub/Sub) 模式。&lt;/p&gt;
&lt;h2 id=&quot;中间件作用&quot;&gt;&lt;a href=&quot;#中间件作用&quot; class=&quot;headerlink&quot; title=&quot;中间件作用&quot;&gt;&lt;/a&gt;中间件作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;冗余（存储）&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;削峰&lt;/li&gt;
&lt;li&gt;可恢复性&lt;/li&gt;
&lt;li&gt;顺序保证&lt;/li&gt;
&lt;li&gt;缓冲&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可靠性：RabbitMQ使用机制保证可靠性，如持久化、传输确认以及发布确认等&lt;/li&gt;
&lt;li&gt;灵活的路由：通过交换器路由消息到队列&lt;/li&gt;
&lt;li&gt;扩展性：可集群&lt;/li&gt;
&lt;li&gt;高可用性： 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用（镜像集群：不同队列消息同步）&lt;/li&gt;
&lt;li&gt;多种协议： 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等&lt;/li&gt;
&lt;li&gt;多语言客户端：如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。&lt;/li&gt;
&lt;li&gt;管理界面：提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。（rabbitmq_management插件）&lt;/li&gt;
&lt;li&gt;插件机制：插件丰富可扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://haifuns.com/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://haifuns.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>GitHub SSH配置</title>
    <link href="https://haifuns.com/2019/06/28/git/"/>
    <id>https://haifuns.com/2019/06/28/git/</id>
    <published>2019-06-28T14:31:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<ul><li>设置账号、email<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></tbody></table></figure></li><li>检查<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></tbody></table></figure></li><li>创建SSH ;<code>id_rsa</code>:私人秘钥<code>id_rsa.pub</code>:公共秘钥<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></tbody></table></figure></li><li>GitHub -&gt; New SSH key -&gt;id_rsa.pub</li><li>检查<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;设置账号、email&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="工具" scheme="https://haifuns.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="https://haifuns.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="https://haifuns.com/2019/06/28/hexo/"/>
    <id>https://haifuns.com/2019/06/28/hexo/</id>
    <published>2019-06-28T13:24:00.000Z</published>
    <updated>2025-02-23T13:53:31.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>nodejs</li><li>git</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><h4 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h4><ul><li>生成SSH添加到GitHub</li><li>修改配置文件 _config.yml<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">      type: git</span><br><span class="line">      repo: https://github.com/**/*.github.io.git</span><br><span class="line">      branch: master</span><br></pre></td></tr></tbody></table></figure></li><li>安装deploy-git<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></tbody></table></figure><h4 id="生成静态文章"><a href="#生成静态文章" class="headerlink" title="生成静态文章"></a>生成静态文章</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><h4 id="部署提交"><a href="#部署提交" class="headerlink" title="部署提交"></a>部署提交</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d </span><br></pre></td></tr></tbody></table></figure><h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new newpapername</span><br></pre></td></tr></tbody></table></figure><h4 id="创建草稿"><a href="#创建草稿" class="headerlink" title="创建草稿"></a>创建草稿</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft newpage</span><br></pre></td></tr></tbody></table></figure><h4 id="预览草稿"><a href="#预览草稿" class="headerlink" title="预览草稿"></a>预览草稿</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></tbody></table></figure><h4 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish draft newpage</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="Hexo-Admin-在线编辑"><a href="#Hexo-Admin-在线编辑" class="headerlink" title="Hexo Admin(在线编辑)"></a>Hexo Admin(在线编辑)</h4><ul><li>安装</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></tbody></table></figure><ul><li>使用<br> <a href="http://localhost:4000/admin/">http://localhost:4000/admin/</a></li></ul><h4 id="emoji-表情"><a href="#emoji-表情" class="headerlink" title="emoji 表情"></a><a href="https://github.com/crimx/hexo-filter-github-emojis">emoji 表情</a></h4><ul><li>安装<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure></li><li>启用插件</li></ul><p>向站点配置文件_config.yml 中添加如下设置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">githubEmojis:</span><br><span class="line">  enable: true</span><br><span class="line">  className: github-emoji</span><br><span class="line">  unicode: true</span><br><span class="line">  styles:</span><br><span class="line">    display: inline</span><br><span class="line">    vertical-align: middle </span><br><span class="line">  localEmojis:</span><br></pre></td></tr></tbody></table></figure><ul><li>使用</li></ul><p>在<a href="https://www.webfx.com/tools/emoji-cheat-sheet/"> emoji-cheat-sheet </a>中找到你想要的表情，然后复制编码。比如你想发一个😄 直接输入😄对应的 emoji 编码 <code>:smile</code>： 就可以了。展示一波表情<span class="github-emoji"><span> </span><img src="https://github.githubassets.com/images/icons/emoji/bowtie.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>☀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>☔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2614.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>☁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2601.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>❄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2744.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>⛄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26c4.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;nodejs&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="https://haifuns.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Hexo" scheme="https://haifuns.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
