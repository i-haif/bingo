<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="网络分区网络分区意义RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 R">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ 网络分区&amp;扩展">
<meta property="og:url" content="https://haifuns.com/2020/12/26/rabbitmq-4/index.html">
<meta property="og:site_name" content="haifun&#39;s blog">
<meta property="og:description" content="网络分区网络分区意义RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png">
<meta property="og:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition2.png">
<meta property="article:published_time" content="2020-12-26T09:00:00.000Z">
<meta property="article:modified_time" content="2025-02-13T13:49:33.550Z">
<meta property="article:author" content="haifun">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>RabbitMQ 网络分区&amp;扩展</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="haifun&#39;s blog" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2020/12/26/jvm-1/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2020/12/26/rabbitmq-3/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haifuns.com/2020/12/26/rabbitmq-4/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haifuns.com/2020/12/26/rabbitmq-4/&text=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haifuns.com/2020/12/26/rabbitmq-4/&is_video=false&description=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RabbitMQ 网络分区&amp;扩展&body=Check out this article: https://haifuns.com/2020/12/26/rabbitmq-4/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haifuns.com/2020/12/26/rabbitmq-4/&name=RabbitMQ 网络分区&amp;扩展&description=&lt;h1 id=&#34;网络分区&#34;&gt;&lt;a href=&#34;#网络分区&#34; class=&#34;headerlink&#34; title=&#34;网络分区&#34;&gt;&lt;/a&gt;网络分区&lt;/h1&gt;&lt;h2 id=&#34;网络分区意义&#34;&gt;&lt;a href=&#34;#网络分区意义&#34; class=&#34;headerlink&#34; title=&#34;网络分区意义&#34;&gt;&lt;/a&gt;网络分区意义&lt;/h2&gt;&lt;p&gt;RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。&lt;/p&gt;
&lt;p&gt;当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。&lt;/p&gt;
&lt;p&gt;RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haifuns.com/2020/12/26/rabbitmq-4/&t=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%84%8F%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">网络分区意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%88%A4%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text">网络分区判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">模拟网络分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.</span> <span class="toc-text">网络分区的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">未配置镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">已配置镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">手动处理网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E4%BF%A1%E4%BB%BB%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">如何挑选信任分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E5%90%AF%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">如何重启节点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BD%95%E8%80%83%E7%A9%B6%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">重启的顺序有何考究？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.4.</span> <span class="toc-text">网络分区处理步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">自动处理网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pause-minority-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">pause-minority 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pause-if-all-down-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">pause-if-all-down 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autoheal-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">autoheal 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.4.</span> <span class="toc-text">模式选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA"><span class="toc-number">2.1.</span> <span class="toc-text">消息追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Firehose"><span class="toc-number">2.1.1.</span> <span class="toc-text">Firehose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-tracing-%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">rabbitmq_tracing 插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">负载均衡</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        RabbitMQ 网络分区&amp;扩展
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Haif.</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-12-26T09:00:00.000Z" class="dt-published" itemprop="datePublished">2020-12-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h1><h2 id="网络分区意义"><a href="#网络分区意义" class="headerlink" title="网络分区意义"></a>网络分区意义</h2><p>RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。</p>
<p>当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。</p>
<p>RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：</p>
<span id="more"></span>

<p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition1.png" alt="image"></p>
<p>图中为某队列配置了4 个镜像，其中A 节点作为 master 节点，其余B、C、D 节点为 slave 节点，4 个镜像节点组成一个环形结构。</p>
<p>假如需要确认(ack)一条消息，先会在A 节点即master 节点上执行确认命令，之后转向B 节点，然后是C 节点，最后由D 将执行操作返回给A 节点，这样才真正确认了一条消息，之后才可以继续相应的处理。</p>
<p>这种复制原理与ZooKeeper 的Quorum 原理不同，它可以保证更强的一致性。在这种一致性数据模型下，如果出现网络波动或者网络故障等异常情况，那么整个数据链的性能就会大大降低。如果C 节点网络异常，那么整个 A -&gt; B -&gt; C -&gt; D -&gt; A 数据链就会被阻塞，继而相关服务也会被阻塞，所以这里就需要引入网络分区来将异常的节点剥离出整个分区，以确保 RabbitMQ 服务的可用性及可靠性。等待网络恢复之后，可以进行相应的处理来将此前的异常节点加入集群中。</p>
<h2 id="网络分区判定"><a href="#网络分区判定" class="headerlink" title="网络分区判定"></a>网络分区判定</h2><p>RabbitMQ 集群节点内部通信端口默认为25672 ，两两节点之间都会有信息交互，如果某节点出现网络故障，或者是端口不通，会致使与此节点的交互出现中断，这里就会有个超时判定机制，继而判定网络分区。</p>
<p>对于网络分区的判定是与 net_ticktime 参数息息相关的，此参数默认值为60 秒。注意与heartbeat_time 的区别heartbeat_time 是指客户端与 RabbitMQ 服务之间通信的心跳时间，针对 5672 端口而言。如果发生超时则会有 net_tick_timeout 的信息报出RabbitMQ 集群内部的每个节点之间会每隔四分之一的 net_ticktime 次应答(tick)。如果有任何数据被写入节点中，则此节点被认为已经被应答(ticked)了。如果连续4 次，某节点都没有被 ticked，则可以判定此节点已处于 “down” 状态，其余节点可将此节点剥离出当前分区。</p>
<p>将连续4 次的 tick 时间记为 T，那么T 的取值范围为 <code>0.75 * net_ticktime &lt; T &lt; 1.25 * net_ticktime</code>。下图可以形象地描绘出这个取值范围的缘由：</p>
<p><img src="https://haif-cloud.oss-cn-beijing.aliyuncs.com/mq/rabbitmq-network-partition2.png" alt="image"></p>
<p>图中每个节点代表一次 tick 判定的时间戳，在2 个临界值 0.75  * net_ticktime 和<br>1.25 * net_ticktime 之间可以连续执行4 次的 tick 判定。默认情况下，在 45s &lt; T &lt; 75s 之间会判定出net_tick_timeout。</p>
<p>RabbtMQ 不仅会将队列、交换器及绑定等信息存储在 Mnesia 数据库中，而且许多围绕网络分区的一些细节也都和这个 Mneia 的行为相关。如果一个节点不能在T 时间连上另一个节点，那么 Mnesia 通常认为这个节点己经挂了，就算之后两个节点又重新恢复了内部通信，但是这两个节点都会认为对方已经挂了，Mnesia 此时认定了发生网络分区的情况。这些会被记录到RabbitMQ 的服务日志之中如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mnesia('rabbit@node1'): ** ERROR ** mnesia event got</span><br><span class="line">{inconsistent_database, running_partitioned_network, 'rabbit@node2'}</span><br></pre></td></tr></tbody></table></figure>

<p>除了通过查看 RabbitMQ 服务日志的方式，还有以下3 种方法可以查看是否出现网络分区：</p>
<ol>
<li>采用 rabbitmqctl 工具来查看，即采用<code>rabbitmqctl cluster_status</code>，通过这条命令可以看到集群相关信息，未发生网络分区时的情形举例如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node2,rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitio, []}]</span><br></pre></td></tr></tbody></table></figure>
由上面的信息可知，集群中一共有3 个节点，分别为rabbit@node1、rabbit@node2、rabbit@node3。在partitions这一项中没有相关记录，则说明没有产生网络分区。如果partitions 项中有相关容，则说明产生了网络分区，例如：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[{nodes, [{disc, [rabbit@node1,rabbit@node2,rabbit@node3]}]},</span><br><span class="line">{running_nodes, [rabbit@node3,rabbit@node1]},</span><br><span class="line">{cluster_name, &lt;&lt;"rabbit@node1"&gt;&gt;},</span><br><span class="line">{partitions, [{rabbit@node3,[rabbit@node2]},{rabbit@node1,[rabbit@node2]}]}]</span><br></pre></td></tr></tbody></table></figure>
上面partitions 项中的内容表示：</li>
</ol>
<ul>
<li>rabbit@node3与rabbit@node2 发生了分区，即 {rabbit@node3,[rabbit@node2]}</li>
<li>rabbit@node1与rabbit@node2 发生了分区，即 {rabbit@node1,[rabbit@node2]}</li>
</ul>
<ol start="2">
<li>通过 Web 管理界面的方式查看。如果发生了网络分区页面会出现警告。推荐采用这种方式来检测是否发生了网络分区。</li>
<li>通过 HTTP API 的方式调取节点信息来检测是否发生网络分区，比如通过 curl 命令来调取节点信息：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -u root:root123 -H "content-type:application/json" -X GET http://localhost:15672/api/nodes</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="模拟网络分区"><a href="#模拟网络分区" class="headerlink" title="模拟网络分区"></a>模拟网络分区</h2><p>正常情况下，很难观察到 RabbitMQ 网络分区的发生。为了更好地理解网络分区，需要采取某些手段将其模拟出来，以便对其进行相应的分析处理，进而在实际应用环境中遇到类似情形可以处理游刃有余。往长远方面讲，也可以采取一些要的手段去规避网络分区的发生，或者可以监控网络分区以及准备相关的处理预案。</p>
<p>模拟网络分区的方式有多种，主要分为以下三大类:</p>
<ul>
<li>iptables 封禁/解封 IP 地址或者端口号；</li>
<li>关闭/开启网卡；</li>
<li>挂起/恢复操作系统；</li>
</ul>
<h2 id="网络分区的影响"><a href="#网络分区的影响" class="headerlink" title="网络分区的影响"></a>网络分区的影响</h2><h3 id="未配置镜像"><a href="#未配置镜像" class="headerlink" title="未配置镜像"></a>未配置镜像</h3><p>node1、node2、node3 三个节点组成一个RabbitMQ 集群，且在这三个节点中分别创建queue1、queue2、queue3这三个队列，并且相应的交换器与绑定关系如下：</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>node3</td>
<td>exchange</td>
<td>rk3</td>
<td>queue3</td>
</tr>
</tbody></table>
<p><strong>客户端分别连接node1 和node2 并分别向/从queue1 和queue2 发送/消费消息</strong></p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>client1(producer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client2(producer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client3(consumer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client4(consumer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
</tbody></table>
<p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，对于消息生产端client1、client2 而言，没有任何异常，消息正常发送也没有消息丢失。消费端client3、client4 也都能正常消费，无任何异常发生。</p>
<p><strong>客户端分别连接node1 和node2 并分别向/从queue2 和queue1 发送/消费消息</strong></p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>节点名称</th>
<th>交换器</th>
<th>绑定</th>
<th>队列</th>
</tr>
</thead>
<tbody><tr>
<td>client1(producer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client2(producer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
<tr>
<td>client3(consumer)</td>
<td>node1</td>
<td>exchange</td>
<td>rk2</td>
<td>queue2</td>
</tr>
<tr>
<td>client4(consumer)</td>
<td>node2</td>
<td>exchange</td>
<td>rk1</td>
<td>queue1</td>
</tr>
</tbody></table>
<p>在发生网络分区后，node1、node2 存在于两个不同的分区之中，client1 不能将消息正确地送达到queue2 ，同样client2 不能将消息送达到queue1 中。如果客户端中设置了ReturnListener 来监听 Basic.Return 的信息，并附带有消息重传机制，那么在整个网络分区前后的过程中可以保证发送端的消息不丢失。</p>
<p>在网络分区之前queue1 进程存在于node1 节点中，queue2 进程存在于node2 节点中。<br>在网络分区之后，在node1 所在的分区并不会创建新的queue2 进程，同样在node2 所在的分区也不会创建新的queue1 的进程。这样在网络分区发生之后，虽然可以通过 <code>rabbitmqctl list_queues name</code> 命令在node1 节点上查看到queue2，但是在node1 上已经没有真实的queue2 进程的存在。</p>
<p>client1 将消息发往交换器exchange 之后并不能路由到queue2 中，因此消息也就不能存储。如果客户端没有设置mandatory 参数并且没有通过ReturnListener 进行消息重试(或者其他措施)来保障消息可靠性，那么在发送端就会有消息丢失。</p>
<p>对于消费端client3、client4，客户端没有异常报错，且可以消费到相关数据，但是此时会有一些怪异的现象发生，比如对于已消费消息的ack 失效。在从网络分区中恢复之后，数据不会丢失。</p>
<p>如果分区之后，重启client3 或者有个新的客户端client5 连接node1 IP 来消费queue2 则会报错。</p>
<p><strong>小结</strong></p>
<p>对于未配置镜像的集群，网络分区发生之后，队列也会伴随着宿主节点而分散在各自的分区之中。对于消息发送方而言，可以成功发送消息，但是会有路由失败的现象，要需要配合mandatory 等机制保障消息的可靠性。对于消息消费方来说，有可能会有诡异、不可预知的现象发生，比如对于已消费消息的ack 会失效。如果网络分区发生之后，客户端与某分区重新建立通信链路，其分区中如果没有相应的队列进程，则会有异常报出。如果从网络分区中恢复之后，数据不会丢失，但是客户端会重复消费。</p>
<h3 id="已配置镜像"><a href="#已配置镜像" class="headerlink" title="已配置镜像"></a>已配置镜像</h3><p>如果集群中配置了镜像队列，那么在发生网络分区时，情形比未配置镜像队列的情况复杂得多，尤其是发生多个网络分区的时候。这里先简单地从3 个节点分裂成2 个网络分区的情形展开讨论。如前文所述，集群中有node1、node2、node3 三个节点，分别在这些节点上创建队列queue1、queue2、queue3 并配置镜像队列。采用iptables 的方式将集群模拟分裂[node1,node3] [node2] 这两个网络分区。</p>
<p>镜像队列的相关配置可以参考如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ha-mode:exactly </span><br><span class="line">ha-param:2 </span><br><span class="line">ha-sync-mode:automatic</span><br></pre></td></tr></tbody></table></figure>

<p>首先来分析第一种情况。如下表示，3 个队列的master 镜像和slave 镜像分别做相应分布。</p>
<p>分区之前：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>node3</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node2</td>
</tr>
</tbody></table>
<p>分区之后：</p>
<p>[node1,node3]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node3</td>
<td>node1</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>在发生网络分区之后 [node1,node3] 分区中的队列有了新的部署。除了queue1 未发生改变，queue2 于原宿主节点node2 被剥离当前分区，那么node3 提升为master ，同时选择node1 作为slave 。在queue3 重新选择node1 作为其新的slave。</p>
<p>[node2]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue3</td>
<td>node2</td>
<td>[]</td>
</tr>
</tbody></table>
<p>对于[node2] 分区而言，queue2、queue3的分布比较容易理解，此分区中只有一个节点，所有slave 列为空。但是对于queue1而言，其部署还是和分区前如出一辙。不管是在网络分区前，还是在网络分区之后，再或者是又从网络分区中恢复，对于queue1而言生产和消费消息都不会受到任何的影响，就如未发生过网络分区一样。对于队列queue2、queue3 情形可以参考上面未配置镜像的相关细节，从网络分区中恢复(即恢复成之前的[node1,node2,node3] 组成的完整分区)之后可能会有数据丢失。</p>
<p>再考虑另一种情形，分区之前如下所示：</p>
<p>分区之前：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node2</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>node3</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>分区之后：</p>
<p>[node1,node3]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node1</td>
<td>node3</td>
</tr>
<tr>
<td>queue2</td>
<td>node3</td>
<td>node1</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<p>[node2]分区：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>queue1</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue2</td>
<td>node2</td>
<td>[]</td>
</tr>
<tr>
<td>queue3</td>
<td>node3</td>
<td>node1</td>
</tr>
</tbody></table>
<h2 id="手动处理网络分区"><a href="#手动处理网络分区" class="headerlink" title="手动处理网络分区"></a>手动处理网络分区</h2><p>为了从网络分区中恢复，首先需要挑选一个信任分区，这个分区才有决定Mnesia 内容的权限，发生在其他分区的改变将不会被记录到Mnesia 中而被直接丢弃。在挑选完信任分区之后，重启非信任分区中的节点，如果此时还有网络分区的告警，紧接着重启信任分区中的节点。</p>
<p>这里有3 个要点需要详细阐述：</p>
<ul>
<li>如何挑选信任分区？</li>
<li>如何重启节点？</li>
<li>重启的顺序有何考究？</li>
</ul>
<h3 id="如何挑选信任分区？"><a href="#如何挑选信任分区？" class="headerlink" title="如何挑选信任分区？"></a>如何挑选信任分区？</h3><p>挑选信任分区一般可以按照这几个指标进行：</p>
<ul>
<li>分区中要有disc 节点；</li>
<li>分区中的节点数最多；</li>
<li>分区中的队列数最多；</li>
<li>分区中的客户端连接数最多；</li>
</ul>
<p>优先级从前到后，例如信任分区中要有disc 节点；如果有两个或者多个分区满足，则挑选节点数最多的分区作为信任分区；如果又有两个或者多个分区满足，那么挑选队列数最多的分区作为信任分区。依次类推如果有两个或者多个分区对于这些指标都均等，那么可以随机挑选一个分区。</p>
<h3 id="如何重启节点？"><a href="#如何重启节点？" class="headerlink" title="如何重启节点？"></a>如何重启节点？</h3><p>RabbitMQ 中有两种重启方式：</p>
<ul>
<li>使用 <code>rabbitmqctl stop</code> 命令关闭，然后再用 <code>rabbitmq-server -detached</code>命令启动</li>
<li>使用 <code>rabbitmqctl stop_app</code> 关闭，然后使用 <code>rabbitmqctl start_app</code>命令启动。</li>
</ul>
<p>第一种方式需要同时重启erlang 虚拟机和RabbitMQ 应用，而第二种方式只是重启RabbitMQ 应用。两种方式都可以从网络分区中恢复，但是更加推荐使用第二种方式，包括后面的自动处理网络分区的方式，其内部是采用的第二种方式进行重启节点。</p>
<h3 id="重启的顺序有何考究？"><a href="#重启的顺序有何考究？" class="headerlink" title="重启的顺序有何考究？"></a>重启的顺序有何考究？</h3><p>RabbitMQ 的重启顺序也比较讲究，必须在以下两种重启顺序中择其一进行重启操作：</p>
<ol>
<li>停止其他非信任分区中的所有节点，然后再启动这些节点。如果此时还有网络分区的告警，则再重启信任分区中的节点以去除告警。</li>
<li>关闭整个集群中的节点，然后再启动每一个节点，这里需要确保启动的第一个节点在<br>信任的分区之中。</li>
</ol>
<p>在选择哪种重启顺序之前 首先考虑一下队列“漂移”的现象。所谓的队列“漂移”是在配置镜像队列的情况下才会发生的。在配置镜像的集群中重启会有队列“漂移”的情况发生，造成负载不均衡。</p>
<blockquote>
<p>注意：一定要按照前面提及的两种方式择其一进行重启，如果选择挨个节点重启的方式，同样可以处理网络分区，但是这里会有一个严重的问题，即Mnesia 内容权限的归属问题。比如有两个分区[node1,node2] [node3,node4]，其中[node1,node2] 为信任分区，此时若按照挨个重启的方式进行重启，比如先重启node3 ，在node3 节点启动之时无法判断其节点的Mnesia 内容是向[node1,node2] 分区靠齐还是向node4 节点靠齐，至此，如果挨个一轮重启之后，最终集群中的Mnesia 数据是[node3 node4] 这个非信任分区，就会造成无法估量的损失。挨个节点重启也有可能会引起二次网络分区的发生。</p>
</blockquote>
<p>如果原本配置了镜像队列，从发生网络分区到恢复的过程中队列可能会出现“漂移”的现象。可以重启之前先删除镜像队列的配置，这样能够在一定程度上阻止队列的“过分漂移”，即阻止可能所有队列都“漂移”到一个节点上的情况。</p>
<p>删除镜像队列的配置可以采用 rabbitmqctl 工具删除：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_policy [-p vhost] {mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure>

<p>可以通过 Web 管理界面进行删除，也可以通过 HTTPAPI 的方式进行删除:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -u {username:password} -X DELETE http://localhost:15672/api/policies/default/{mirror_queue_name}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="网络分区处理步骤"><a href="#网络分区处理步骤" class="headerlink" title="网络分区处理步骤"></a>网络分区处理步骤</h3><ul>
<li>步骤 1：挂起生产者和消费者进程。这样可以减少消息不必要的丢失，如果进程数过多，情形又比较紧急，也可跳过此步骤。</li>
<li>步骤 2：删除镜像队列的配置。</li>
<li>步骤 3：挑选信任分区。</li>
<li>步骤 4：关闭非信任分区中的节点。采用 <code>rabbitmqctl stop_app</code> 命令关闭。</li>
<li>步骤 5：启动非信任分区中的节点。采用与步骤4 对应的 <code>rabbitmqctl start_app</code> 命令启动。</li>
<li>步骤 6：检查网络分区是否恢复，如果已经恢复则转步骤8，如果还有网络分区的报警则转步骤7。</li>
<li>步骤 7：重启信任分区中的节点。</li>
<li>步骤 8：添加镜像队列的配置。</li>
<li>步骤 9：恢复生产者和消费者的进程。</li>
</ul>
<h2 id="自动处理网络分区"><a href="#自动处理网络分区" class="headerlink" title="自动处理网络分区"></a>自动处理网络分区</h2><p>RabbitMQ 提供了三种方法自动地处理网络分区pause-minority 模式、pause-if-all-down 模式和autoheal 模式。默认是 ignore 模式，即不自动处理网络分区，所以在这种模式下，当网络分区的时候需要人工介入。在 rabbitmq.config 配置文件中配置<code>cluster_partition_handling</code> 参数即可实现相应的功能。默认的 ignore 模式的配置如下，注意最后有个点号：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, ignore}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>

<h3 id="pause-minority-模式"><a href="#pause-minority-模式" class="headerlink" title="pause-minority 模式"></a>pause-minority 模式</h3><p>在pause-minority 模式下，当发生网络分区时，集群中的节点在观察到某些节点”down”的时候，会自动检测其自身是否处于”少数派”(分区中的节点小于或者等于集群中一半的节点数)，RabbitMQ 会自动关闭这些节点的运作。根据 CAP 原理，这里保障了P，即分区耐受性。这样确保了在发生网络分区的情况下，大多数节点(当然这些节点得在同一个分区中)可以继续运行。”少数派”中的节点在分区开始时会关闭，当分区结束时又会启动。这里关闭是指RabbitMQ 应用的关闭，而Erlang 虚拟机并不关闭，类似于执行了 <code>rabbitmqctl stop_app</code> 命令。处于关闭的节点会每秒检测一次是否可连通到剩余集群中，如果可以则启动自身的应用。相当于执行 <code>rabbitmqctl start_app</code> 命令。</p>
<p>pause-minority 模式相应的配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, pause-minority}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是RabbitMQ 会关闭不是严格意义上的大多数，比如在一个集群中只有两个节点的时候并不适合采用pause-minority 的模式，因为其中任何一个节点失败而发生网络分区时，两个节点都会关闭。当网络恢复时有可能两个节点会自动启动恢复网络分区，也有可能仍保持关闭状态，然而如果集群中的节点数远大于2 个时，pause-minority 模式比 ignore 模式更加可靠，特别是网络分区通常是由单节点网络故障而脱离原有分区引起的。</p>
<p>当对等分区出现时，会关闭这些分区内的所有节点，对于前面的[node1,node2] [node3,node4] 的例子而言，这四个节点上的RabbitMQ 应用都会被关闭，只有等待网络恢复之后，才会自动启动所有的节点以求从网络分区中恢复。</p>
<h3 id="pause-if-all-down-模式"><a href="#pause-if-all-down-模式" class="headerlink" title="pause-if-all-down 模式"></a>pause-if-all-down 模式</h3><p>在pause-if-all-down 模式下，RabbitMQ 集群中的节点在和所配置的列表中的任何节点不能交互时才会关闭 语法为 {pause_if_all_down, [nodes], ignore|autoheal}，其中[nodes]为受信节点，参考配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, {pause_if_all_down, ['rabbit@node1'], ignore}}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个节点与 rabbit@node1 节点无法通信时，则会关闭自身的 RabbitMQ 应用。如果是rabbit@node1 本身发生了故障造成网络不可用，而其他节点都是正常的情况下，这种规则会让所有的节点中 RabbitMQ 应用都关闭，待rabbit@node1 中的网络恢复之后，各个节点再启动自身应用以从网络分区中恢复。</p>
<p>pause-if-all-down 模式下有ignore 和autoheal 两种不同的配置。考虑前面pause-minority 模式中提及的一种情形，node1、node2 部署在机架A 上，而node3、node4 部署在机架B，此时配置{cluster_partition_handling,{pause_if_all_down,[‘rabbit@node1’ ,‘rabbit@node3’], ignore}}，那么当机架A 和机架B 通信出现异常时，由于node1、node2 保持着通信，node3、node4 保持着通信，这4 个节点都不会自行关闭，但是会形成两个分区，所以这样不能实现自动处理的功能。所以如果将配置中的ignore 替换成autoheal 就可以处理此种情形。</p>
<h3 id="autoheal-模式"><a href="#autoheal-模式" class="headerlink" title="autoheal 模式"></a>autoheal 模式</h3><p>在autoheal 模式下，当认为发生网络分区时，RabbitMQ 会自动决定一个获胜(winning)的分区，然后重启不在这个分区中的节点来从网络分区中恢复。一个获胜的分区是指客户端连接最多的分区，如果产生一个平局，即有两个或者多个分区的客户端连接数一样多，那么节点数最多的一个分区就是获胜分区，如果此时节点数也一样多，将以节点名称的字典序来挑选获胜分区。</p>
<p>autoheal 模式参考配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        rabbit, [</span><br><span class="line">            {cluster_partition_handling, autoheal}</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">].</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：在autoheal 模式下，如果集群中有节点处于非运行状态，那么当发生网络分区的时候，将不会有任何自动处理的动作。</p>
</blockquote>
<h3 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h3><p>允许RabbitMQ 够自动处理网络分区并不一定会有正面的成效，也有可能会带来更多的问题。网络分区会导致RabbitMQ 集群产生众多的问题，需要对遇到的问题做出一定的选择。如果置RabbitMQ 于一个不可靠的网络环境下，需要使用Federation 或者Shovel。就算从网络分区中恢复了之后，也要谨防发生二次网络分区。</p>
<p>每种模式都有自身的优缺点，没有哪种模式是万无一失的，要根据实际情形做出相应的选择，下面简要概论以下4 个模式：</p>
<ul>
<li>ignore 模式：发生网络分区时，不做任何动作，需要人工介入；</li>
<li>pause-minority 模式：对于对等分区的处理不够优雅，可能会关闭所有的节点。一般情况下，可应用于非跨机架、奇数节点数的集群中；</li>
<li>pause-if-all-down 模式：对于受信节点的选择尤为考究，尤其是在集群中所有节点硬件配置相同的情况下。此种模式可以处理对等分区的情形；</li>
<li>autoheal 模式：可以处于各个情形下的网络分区。但是如果集群中有节点处于非运行状态，则此种模式会失效；</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><h3 id="Firehose"><a href="#Firehose" class="headerlink" title="Firehose"></a>Firehose</h3><p>在RabbitMQ 中可以使用Firehose 功能来实现消息追踪，Firehose 可以记录每一次发送或者<br>消费消息的记录，方便RabbitMQ 的使用者进行调试、排错等。</p>
<p>开启Firehose 命令: <code>rabbitmqctl trace_on [-p vhost]</code> 其中 [-p vhost] 是可选参数用来指定虚拟主机vhost 。对应的关闭命令为 <code>rabbitmqctl trace_off [-p vhost]</code>。</p>
<p>Firehose 默认情况下处于关闭状态，并且Firehose 的状态也是非持久化的，会在RabbitMQ 服务重启的时候还原成默认的状态。Firehose 开启之后多少会影响RabbitMQ 整体服务的性能，因为它会引起额外的消息生成、路由和存储。</p>
<h3 id="rabbitmq-tracing-插件"><a href="#rabbitmq-tracing-插件" class="headerlink" title="rabbitmq_tracing 插件"></a>rabbitmq_tracing 插件</h3><p>rabbitrnq_tracing 插件相当于Firehose 的GUI 版本，它同样能跟踪RabbitMQ 中消息的流入流出情况。rabbitrnq_tracing 插件同样会对流入流出的消息进行封装，然后将封装后的消息日志存入相应的trace 文件之中。</p>
<p>可以使用<code>rabbitmq-plugins enable rabbitrnq_tracing</code> 命令来启动rabbitmq_tracing 插件。对应的关闭插件的命令是 <code>rabbitrnq-plugins disable rabbitrnq_tracing</code>。</p>
<p>开启后在Web 管理界面会多Tracing 页签。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li><p>客户端内部实现负载均衡</p>
</li>
<li><p>使用HAProxy实现负载均衡</p>
</li>
<li><p>使用Keepalived实现高可靠负载均衡</p>
</li>
<li><p>使用Keepalived+LVS实现负载均衡</p>
</li>
</ul>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.</span> <span class="toc-text">网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%84%8F%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">网络分区意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%88%A4%E5%AE%9A"><span class="toc-number">1.2.</span> <span class="toc-text">网络分区判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">模拟网络分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.</span> <span class="toc-text">网络分区的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">未配置镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">已配置镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">手动处理网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8C%91%E9%80%89%E4%BF%A1%E4%BB%BB%E5%88%86%E5%8C%BA%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">如何挑选信任分区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E5%90%AF%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">如何重启节点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BD%95%E8%80%83%E7%A9%B6%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">重启的顺序有何考究？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.4.</span> <span class="toc-text">网络分区处理步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">自动处理网络分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pause-minority-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">pause-minority 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pause-if-all-down-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">pause-if-all-down 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autoheal-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">autoheal 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.4.</span> <span class="toc-text">模式选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA"><span class="toc-number">2.1.</span> <span class="toc-text">消息追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Firehose"><span class="toc-number">2.1.1.</span> <span class="toc-text">Firehose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabbitmq-tracing-%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">rabbitmq_tracing 插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">负载均衡</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haifuns.com/2020/12/26/rabbitmq-4/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haifuns.com/2020/12/26/rabbitmq-4/&text=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haifuns.com/2020/12/26/rabbitmq-4/&is_video=false&description=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RabbitMQ 网络分区&amp;扩展&body=Check out this article: https://haifuns.com/2020/12/26/rabbitmq-4/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haifuns.com/2020/12/26/rabbitmq-4/&title=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haifuns.com/2020/12/26/rabbitmq-4/&name=RabbitMQ 网络分区&amp;扩展&description=&lt;h1 id=&#34;网络分区&#34;&gt;&lt;a href=&#34;#网络分区&#34; class=&#34;headerlink&#34; title=&#34;网络分区&#34;&gt;&lt;/a&gt;网络分区&lt;/h1&gt;&lt;h2 id=&#34;网络分区意义&#34;&gt;&lt;a href=&#34;#网络分区意义&#34; class=&#34;headerlink&#34; title=&#34;网络分区意义&#34;&gt;&lt;/a&gt;网络分区意义&lt;/h2&gt;&lt;p&gt;RabbitMQ 集群的网络分区的容错性并不是很高，一般都是使用 Federation 或者 Shovel 解决广域网中的使用问题。不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备(比如中继设备、网卡)出现故障也会导致网络分区。当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂(down)了，对于队列、交换器、绑定的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题。RabbitMQ 3.1 版本开始会自动探测网络分区，并且提供了相应的配置来解决这个问题。&lt;/p&gt;
&lt;p&gt;当一个集群发生网络分区时，这个集群会分成两个部分或者更多，它们各自为政，互相都认为对方分区内的节点已经挂了，包括队列、交换器及绑定等元数据的创建和销毁都处于自身分区内，与其他分区无关。如果原集群中配置了镜像队列，而这个镜像队列又牵涉两个或者更多个网络分区中的节点时，每一个网络分区中都会出现一个 master 节点，对于各个网络分区，此队列都是相互独立的。当然也会有一些其他未知的、怪异的事情发生。当网络恢复时，网络分区的状态还是会保持，除非采取了一些措施去解决它。&lt;/p&gt;
&lt;p&gt;RabbitMQ 网络分区带来的影响大多是负面的，极端情况下不仅会造成数据丢失，还会影响服务的可用性。那为什么RabbitMQ 还要引入网络分区的设计理念呢？其中一个原因就与它本身的数据一致性复制原理有关，RabbitMQ 采用的镜像队列是一种环形的逻辑结构 ，如下图所示：&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haifuns.com/2020/12/26/rabbitmq-4/&t=RabbitMQ 网络分区&amp;扩展"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2019-2025
    haifun
    <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">
      鲁ICP备19052103号
    </a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d3c8edb388553a2084296cbfe9a0785a";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'haifuns/haifuns.github.io';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-light';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
